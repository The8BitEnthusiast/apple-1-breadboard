ca65 V2.19 - Git 3dfe03300
Main file   : msbasic.s
Current file: msbasic.s

000000r 1               .feature force_range
000000r 1               .debuginfo +
000000r 1               
000000r 1               .setcpu "6502"
000000r 1               .macpack longbranch
000000r 2               .macro  jeq     Target
000000r 2                       .if     .match(Target, 0)
000000r 2                       bne     *+5
000000r 2                       jmp     Target
000000r 2                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 2                               beq     Target
000000r 2                       .else
000000r 2                               bne     *+5
000000r 2                               jmp     Target
000000r 2                       .endif
000000r 2               .endmacro
000000r 2               .macro  jne     Target
000000r 2                       .if     .match(Target, 0)
000000r 2                               beq     *+5
000000r 2                               jmp     Target
000000r 2                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 2                               bne     Target
000000r 2                       .else
000000r 2                               beq     *+5
000000r 2                               jmp     Target
000000r 2                       .endif
000000r 2               .endmacro
000000r 2               .macro  jmi     Target
000000r 2                       .if     .match(Target, 0)
000000r 2                               bpl     *+5
000000r 2                               jmp     Target
000000r 2                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 2                               bmi     Target
000000r 2                       .else
000000r 2                               bpl     *+5
000000r 2                               jmp     Target
000000r 2                       .endif
000000r 2               .endmacro
000000r 2               .macro  jpl     Target
000000r 2                       .if     .match(Target, 0)
000000r 2                               bmi     *+5
000000r 2                               jmp     Target
000000r 2                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 2                               bpl     Target
000000r 2                       .else
000000r 2                               bmi     *+5
000000r 2                               jmp     Target
000000r 2                       .endif
000000r 2               .endmacro
000000r 2               .macro  jcs     Target
000000r 2                       .if     .match(Target, 0)
000000r 2                               bcc     *+5
000000r 2                               jmp     Target
000000r 2                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 2                               bcs     Target
000000r 2                       .else
000000r 2                               bcc     *+5
000000r 2                               jmp     Target
000000r 2                       .endif
000000r 2               .endmacro
000000r 2               .macro  jcc     Target
000000r 2                       .if     .match(Target, 0)
000000r 2                               bcs     *+5
000000r 2                               jmp     Target
000000r 2                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 2                               bcc     Target
000000r 2                       .else
000000r 2                               bcs     *+5
000000r 2                               jmp     Target
000000r 2                       .endif
000000r 2               .endmacro
000000r 2               .macro  jvs     Target
000000r 2                       .if     .match(Target, 0)
000000r 2                               bvc     *+5
000000r 2                               jmp     Target
000000r 2                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 2                               bvs     Target
000000r 2                       .else
000000r 2                               bvc     *+5
000000r 2                               jmp     Target
000000r 2                       .endif
000000r 2               .endmacro
000000r 2               .macro  jvc     Target
000000r 2                       .if     .match(Target, 0)
000000r 2                               bvs     *+5
000000r 2                               jmp     Target
000000r 2                       .elseif .def(Target) .and .const((*-2)-(Target)) .and ((*+2)-(Target) <= 127)
000000r 2                               bvc     Target
000000r 2                       .else
000000r 2                               bvs     *+5
000000r 2                               jmp     Target
000000r 2                       .endif
000000r 2               .endmacro
000000r 2               
000000r 1               
000000r 1               .include "defines.s"
000000r 2               .if .def(cbmbasic1)
000000r 2               CBM1 := 1
000000r 2               .include "defines_cbm1.s"
000000r 2               .elseif .def(osi)
000000r 2               OSI := 1
000000r 2               .include "defines_osi.s"
000000r 2               .elseif .def(applesoft)
000000r 2               APPLE := 1
000000r 2               .include "defines_apple.s"
000000r 2               .elseif .def(kb9)
000000r 2               KIM := 1
000000r 2               .include "defines_kim.s"
000000r 2               .elseif .def(cbmbasic2)
000000r 2               CBM2 := 1
000000r 2               .include "defines_cbm2.s"
000000r 2               .elseif .def(kbdbasic)
000000r 2               KBD := 1
000000r 2               .include "defines_kbd.s"
000000r 2               .elseif .def(microtan)
000000r 2               MICROTAN := 1
000000r 2               .include "defines_microtan.s"
000000r 2               .elseif .def(aim65)
000000r 2               AIM65 := 1
000000r 2               .include "defines_aim65.s"
000000r 2               .elseif .def(sym1)
000000r 2               SYM1 := 1
000000r 2               .include "defines_sym1.s"
000000r 2               .elseif .def(eater)
000000r 2               EATER := 1
000000r 2               .include "defines_eater.s"
000000r 3               ; configuration
000000r 3               CONFIG_2A := 1
000000r 3               
000000r 3               CONFIG_SCRTCH_ORDER := 2
000000r 3               
000000r 3               ; zero page
000000r 3               ZP_START0 = $00
000000r 3               ZP_START1 = $02
000000r 3               ZP_START2 = $0C
000000r 3               ZP_START3 = $62
000000r 3               ZP_START4 = $6D
000000r 3               
000000r 3               ; extra/override ZP variables
000000r 3               USR := GORESTART
000000r 3               
000000r 3               ; constants
000000r 3               SPACE_FOR_GOSUB := $3E
000000r 3               STACK_TOP := $FA
000000r 3               WIDTH := 40
000000r 3               WIDTH2 := 30
000000r 3               RAMSTART2 := $0400
000000r 3               
000000r 2               .endif
000000r 2               
000000r 2               .ifdef CONFIG_2C
000000r 2               CONFIG_2B := 1
000000r 2               .endif
000000r 2               .ifdef CONFIG_2B
000000r 2               CONFIG_2A := 1
000000r 2               .endif
000000r 2               .ifdef CONFIG_2A
000000r 2               CONFIG_2 := 1
000000r 2               .endif
000000r 2               .ifdef CONFIG_2
000000r 2               CONFIG_11A := 1
000000r 2               .endif
000000r 2               .ifdef CONFIG_11A
000000r 2               CONFIG_11 := 1
000000r 2               .endif
000000r 2               .ifdef CONFIG_11
000000r 2               CONFIG_10A := 1
000000r 2               .endif
000000r 2               
000000r 2               .ifdef CONFIG_SMALL
000000r 2               BYTES_FP		:= 4
000000r 2               CONFIG_SMALL_ERROR := 1
000000r 2               .else
000000r 2               BYTES_FP		:= 5
000000r 2               .endif
000000r 2               
000000r 2               .ifndef BYTES_PER_ELEMENT
000000r 2               BYTES_PER_ELEMENT := BYTES_FP
000000r 2               .endif
000000r 2               BYTES_PER_VARIABLE := BYTES_FP+2
000000r 2               MANTISSA_BYTES	:= BYTES_FP-1
000000r 2               BYTES_PER_FRAME := 2*BYTES_FP+8
000000r 2               FOR_STACK1		:= 2*BYTES_FP+5
000000r 2               FOR_STACK2		:= BYTES_FP+4
000000r 2               
000000r 2               .ifndef MAX_EXPON
000000r 2               MAX_EXPON = 10
000000r 2               .endif
000000r 2               
000000r 2               STACK           := $0100
000000r 2               .ifndef STACK2
000000r 2               STACK2          := STACK
000000r 2               .endif
000000r 2               
000000r 2               .ifdef INPUTBUFFER
000000r 2                 .if INPUTBUFFER >= $0100
000000r 2               CONFIG_NO_INPUTBUFFER_ZP := 1
000000r 2                 .endif
000000r 2                 .if INPUTBUFFER = $0200
000000r 2               CONFIG_INPUTBUFFER_0200 := 1
000000r 2                 .endif
000000r 2               .endif
000000r 2               INPUTBUFFERX = INPUTBUFFER & $FF00
000000r 2               
000000r 2               CR=13
000000r 2               LF=10
000000r 2               
000000r 2               .ifndef CRLF_1
000000r 2               CRLF_1 := CR
000000r 2               CRLF_2 := LF
000000r 2               .endif
000000r 2               
000000r 2               
000000r 2               
000000r 2               
000000r 1               .include "macros.s"
000000r 2               ; htasc - set the hi bit on the last byte of a string for termination
000000r 2               ; (by Tom Greene)
000000r 2               .macro htasc str
000000r 2               	.repeat	.strlen(str)-1,I
000000r 2               		.byte	.strat(str,I)
000000r 2               	.endrep
000000r 2               	.byte	.strat(str,.strlen(str)-1) | $80
000000r 2               .endmacro
000000r 2               
000000r 2               ; For every token, a byte gets put into segment "DUMMY".
000000r 2               ; This way, we count up with every token. The DUMMY segment
000000r 2               ; doesn't get linked into the binary.
000000r 2               .macro init_token_tables
000000r 2                       .segment "VECTORS"
000000r 2               TOKEN_ADDRESS_TABLE:
000000r 2                       .segment "KEYWORDS"
000000r 2               TOKEN_NAME_TABLE:
000000r 2               		.segment "DUMMY"
000000r 2               DUMMY_START:
000000r 2               .endmacro
000000r 2               
000000r 2               ; optionally define token symbol
000000r 2               ; count up token number
000000r 2               .macro define_token token
000000r 2                       .segment "DUMMY"
000000r 2               		.ifnblank token
000000r 2               			token := <(*-DUMMY_START)+$80
000000r 2               		.endif
000000r 2               		.res 1; count up in any case
000000r 2               .endmacro
000000r 2               
000000r 2               ; lay down a keyword, optionally define a token symbol
000000r 2               .macro keyword key, token
000000r 2               		.segment "KEYWORDS"
000000r 2               		htasc	key
000000r 2               		define_token token
000000r 2               .endmacro
000000r 2               
000000r 2               ; lay down a keyword and an address (RTS style),
000000r 2               ; optionally define a token symbol
000000r 2               .macro keyword_rts key, vec, token
000000r 2                       .segment "VECTORS"
000000r 2               		.word	vec-1
000000r 2               		keyword key, token
000000r 2               .endmacro
000000r 2               
000000r 2               ; lay down a keyword and an address,
000000r 2               ; optionally define a token symbol
000000r 2               .macro keyword_addr key, vec, token
000000r 2                       .segment "VECTORS"
000000r 2               		.addr	vec
000000r 2               		keyword key, token
000000r 2               .endmacro
000000r 2               
000000r 2               .macro count_tokens
000000r 2                       .segment "DUMMY"
000000r 2               		NUM_TOKENS := <(*-DUMMY_START)
000000r 2               .endmacro
000000r 2               
000000r 2               .macro init_error_table
000000r 2                       .segment "ERROR"
000000r 2               ERROR_MESSAGES:
000000r 2               .endmacro
000000r 2               
000000r 2               .macro define_error error, msg
000000r 2                       .segment "ERROR"
000000r 2               		error := <(*-ERROR_MESSAGES)
000000r 2               		htasc msg
000000r 2               .endmacro
000000r 2               
000000r 2               ;---------------------------------------------
000000r 2               ; set the MSB of every byte of a string
000000r 2               .macro asc80 str
000000r 2               	.repeat	.strlen(str),I
000000r 2               		.byte	.strat(str,I)+$80
000000r 2               	.endrep
000000r 2               .endmacro
000000r 2               
000000r 2               
000000r 1               .include "zeropage.s"
000000r 2               
000000r 2               .feature org_per_seg
000000r 2               .zeropage
000000r 2               
000000r 2               .org ZP_START1
000002  2               
000002  2               GORESTART:
000002  2  xx xx xx     	.res 3
000005  2               GOSTROUT:
000005  2  xx xx xx     	.res 3
000008  2               GOAYINT:
000008  2  xx xx        	.res 2
00000A  2               GOGIVEAYF:
00000A  2  xx xx        	.res 2
00000C  2               
00000C  2               .org ZP_START2
00000C  2               Z15:
00000C  2  xx           	.res 1
00000D  2               .ifndef POSX; allow override
00000D  2               POSX:
00000D  2               .endif
00000D  2  xx           	.res 1
00000E  2               .ifndef Z17; allow override
00000E  2               Z17:
00000E  2               .endif
00000E  2  xx           	.res 1
00000F  2               .ifndef Z18; allow override
00000F  2               Z18:
00000F  2               .endif
00000F  2  xx           	.res 1
000010  2               LINNUM:
000010  2               .ifndef TXPSV; allow override
000010  2               TXPSV:
000010  2               .endif
000010  2  xx xx        	.res 2
000012  2               .ifndef INPUTBUFFER; allow override
000012  2               INPUTBUFFER:
000012  2               .endif
000012  2               
000012  2               .org ZP_START3
000062  2               
000062  2               CHARAC:
000062  2  xx           	.res 1
000063  2               ENDCHR:
000063  2  xx           	.res 1
000064  2               EOLPNTR:
000064  2  xx           	.res 1
000065  2               DIMFLG:
000065  2  xx           	.res 1
000066  2               VALTYP:
000066  2               .ifdef CONFIG_SMALL
000066  2               	.res 1
000066  2               .else
000066  2  xx xx        	.res 2
000068  2               .endif
000068  2               DATAFLG:
000068  2  xx           	.res 1
000069  2               SUBFLG:
000069  2  xx           	.res 1
00006A  2               INPUTFLG:
00006A  2  xx           	.res 1
00006B  2               CPRMASK:
00006B  2  xx           	.res 1
00006C  2               Z14:
00006C  2  xx           	.res 1
00006D  2               
00006D  2               .org ZP_START4
00006D  2               
00006D  2               TEMPPT:
00006D  2  xx           	.res 1
00006E  2               LASTPT:
00006E  2  xx xx        	.res 2
000070  2               TEMPST:
000070  2  xx xx xx xx  	.res 9
000074  2  xx xx xx xx  
000078  2  xx           
000079  2               INDEX:
000079  2  xx xx        	.res 2
00007B  2               DEST:
00007B  2  xx xx        	.res 2
00007D  2               RESULT:
00007D  2  xx xx xx xx  	.res BYTES_FP
000081  2  xx           
000082  2               RESULT_LAST = RESULT + BYTES_FP-1
000082  2               TXTTAB:
000082  2  xx xx        	.res 2
000084  2               VARTAB:
000084  2  xx xx        	.res 2
000086  2               ARYTAB:
000086  2  xx xx        	.res 2
000088  2               STREND:
000088  2  xx xx        	.res 2
00008A  2               FRETOP:
00008A  2  xx xx        	.res 2
00008C  2               FRESPC:
00008C  2  xx xx        	.res 2
00008E  2               MEMSIZ:
00008E  2  xx xx        	.res 2
000090  2               CURLIN:
000090  2  xx xx        	.res 2
000092  2               OLDLIN:
000092  2  xx xx        	.res 2
000094  2               OLDTEXT:
000094  2  xx xx        	.res 2
000096  2               Z8C:
000096  2  xx xx        	.res 2
000098  2               DATPTR:
000098  2  xx xx        	.res 2
00009A  2               INPTR:
00009A  2  xx xx        	.res 2
00009C  2               VARNAM:
00009C  2  xx xx        	.res 2
00009E  2               VARPNT:
00009E  2  xx xx        	.res 2
0000A0  2               FORPNT:
0000A0  2  xx xx        	.res 2
0000A2  2               LASTOP:
0000A2  2  xx xx        	.res 2
0000A4  2               CPRTYP:
0000A4  2  xx           	.res 1
0000A5  2               FNCNAM:
0000A5  2               TEMP3:
0000A5  2  xx xx        	.res 2
0000A7  2               DSCPTR:
0000A7  2               .ifdef CONFIG_SMALL
0000A7  2               		.res 2
0000A7  2               .else
0000A7  2  xx xx xx     		.res 3
0000AA  2               .endif
0000AA  2               DSCLEN:
0000AA  2  xx xx        	.res 2
0000AC  2               .ifndef JMPADRS ; allow override
0000AC  2               JMPADRS			:= DSCLEN + 1
0000AC  2               .endif
0000AC  2               Z52:
0000AC  2  xx           	.res 1
0000AD  2               ARGEXTENSION:
0000AD  2               .ifndef CONFIG_SMALL
0000AD  2  xx           	.res 1
0000AE  2               .endif
0000AE  2               TEMP1:
0000AE  2  xx           	.res 1
0000AF  2               HIGHDS:
0000AF  2  xx xx        	.res 2
0000B1  2               HIGHTR:
0000B1  2  xx xx        	.res 2
0000B3  2               .ifndef CONFIG_SMALL
0000B3  2               TEMP2:
0000B3  2  xx           	.res 1
0000B4  2               .endif
0000B4  2               INDX:
0000B4  2               TMPEXP:
0000B4  2               .ifdef CONFIG_SMALL
0000B4  2               TEMP2:
0000B4  2               .endif
0000B4  2  xx           	.res 1
0000B5  2               EXPON:
0000B5  2  xx           	.res 1
0000B6  2               LOWTR:
0000B6  2               .ifndef LOWTRX ; allow override
0000B6  2               LOWTRX:
0000B6  2               .endif
0000B6  2  xx           	.res 1
0000B7  2               EXPSGN:
0000B7  2  xx           	.res 1
0000B8  2               FAC:
0000B8  2  xx xx xx xx  	.res BYTES_FP
0000BC  2  xx           
0000BD  2               FAC_LAST = FAC + BYTES_FP-1
0000BD  2               FACSIGN:
0000BD  2  xx           	.res 1
0000BE  2               SERLEN:
0000BE  2  xx           	.res 1
0000BF  2               SHIFTSIGNEXT:
0000BF  2  xx           	.res 1
0000C0  2               ARG:
0000C0  2  xx xx xx xx  	.res BYTES_FP
0000C4  2  xx           
0000C5  2               ARG_LAST = ARG + BYTES_FP-1
0000C5  2               ARGSIGN:
0000C5  2  xx           	.res 1
0000C6  2               STRNG1:
0000C6  2  xx xx        	.res 2
0000C8  2               SGNCPR = STRNG1
0000C8  2               FACEXTENSION = STRNG1+1
0000C8  2               STRNG2:
0000C8  2  xx xx        	.res 2
0000CA  2               .ifdef AIM65
0000CA  2               ATN:
0000CA  2               	.res 3
0000CA  2               ZBE:
0000CA  2               	.res 1
0000CA  2               .endif
0000CA  2               .ifdef SYM1
0000CA  2               USR1:
0000CA  2               	.res 3
0000CA  2               USR2:
0000CA  2               	.res 3
0000CA  2               USR3:
0000CA  2               	.res 3
0000CA  2               .endif
0000CA  2               CHRGET:
0000CA  2               TXTPTR = <(GENERIC_TXTPTR-GENERIC_CHRGET + CHRGET)
0000CA  2               CHRGOT = <(GENERIC_CHRGOT-GENERIC_CHRGET + CHRGET)
0000CA  2               CHRGOT2 = <(GENERIC_CHRGOT2-GENERIC_CHRGET + CHRGET)
0000CA  2               RNDSEED = <(GENERIC_RNDSEED-GENERIC_CHRGET + CHRGET)
0000CA  2               
0000CA  2               
0000CA  2               
0000CA  1               
0000CA  1               .include "header.s"
0000CA  2               		.segment "HEADER"
000000r 2               .ifdef KBD
000000r 2                       jmp     LE68C
000000r 2                       .byte   $00,$13,$56
000000r 2               .endif
000000r 2               .ifdef AIM65
000000r 2                       jmp     COLD_START
000000r 2                       jmp     RESTART
000000r 2                       .word   AYINT,GIVAYF
000000r 2               .endif
000000r 2               .ifdef SYM1
000000r 2                       jmp     PR_WRITTEN_BY
000000r 2               .endif
000000r 2               .ifdef EATER
000000r 2  4C rr rr             jmp COLD_START
000003r 2               .endif
000003r 2               
000003r 1               .include "token.s"
000003r 2               		init_token_tables
000000r 2               
000000r 2  rr rr 45 4E  		keyword_rts "END", END
000004r 2  C4 xx        
000001r 2  rr rr 46 4F  		keyword_rts "FOR", FOR
000005r 2  D2 xx        
000002r 2  rr rr 4E 45  		keyword_rts "NEXT", NEXT
000006r 2  58 D4 xx     
000003r 2  rr rr 44 41  		keyword_rts "DATA", DATA
000007r 2  54 C1 xx     
000004r 2               .ifdef CONFIG_FILE
000004r 2               		keyword_rts "INPUT#", INPUTH
000004r 2               .endif
000004r 2  rr rr 49 4E  		keyword_rts "INPUT", INPUT
000008r 2  50 55 D4 xx  
000005r 2  rr rr 44 49  		keyword_rts "DIM", DIM
000009r 2  CD xx        
000006r 2  rr rr 52 45  		keyword_rts "READ", READ
00000Ar 2  41 C4 xx     
000007r 2               .ifdef APPLE
000007r 2               		keyword_rts "PLT", PLT
000007r 2               .else
000007r 2  rr rr 4C 45  		keyword_rts "LET", LET
00000Br 2  D4 xx        
000008r 2               .endif
000008r 2  rr rr 47 4F  		keyword_rts "GOTO", GOTO, TOKEN_GOTO
00000Cr 2  54 CF xx     
000009r 2  rr rr 52 55  		keyword_rts "RUN", RUN
00000Dr 2  CE xx        
00000Ar 2  rr rr 49 C6  		keyword_rts "IF", IF
00000Er 2  xx           
00000Br 2  rr rr 52 45  		keyword_rts "RESTORE", RESTORE
00000Fr 2  53 54 4F 52  
000013r 2  C5 xx        
00000Cr 2  rr rr 47 4F  		keyword_rts "GOSUB", GOSUB, TOKEN_GOSUB
000010r 2  53 55 C2 xx  
00000Dr 2  rr rr 52 45  		keyword_rts "RETURN", POP
000011r 2  54 55 52 CE  
000015r 2  xx           
00000Er 2               .ifdef APPLE
00000Er 2               		keyword_rts "TEX", TEX, TOKEN_REM
00000Er 2               .else
00000Er 2  rr rr 52 45  		keyword_rts "REM", REM, TOKEN_REM
000012r 2  CD xx        
00000Fr 2               .endif
00000Fr 2  rr rr 53 54  		keyword_rts "STOP", STOP
000013r 2  4F D0 xx     
000010r 2  rr rr 4F CE  		keyword_rts "ON", ON
000014r 2  xx           
000011r 2               .ifdef CONFIG_NULL
000011r 2               		keyword_rts "NULL", NULL
000011r 2               .endif
000011r 2               .ifdef KBD
000011r 2               		keyword_rts "PLOD", PLOD
000011r 2               		keyword_rts "PSAV", PSAV
000011r 2               		keyword_rts "VLOD", VLOD
000011r 2               		keyword_rts "VSAV", VSAV
000011r 2               .endif
000011r 2               .ifndef CONFIG_NO_POKE
000011r 2  rr rr 57 41  		keyword_rts "WAIT", WAIT
000015r 2  49 D4 xx     
000012r 2               .endif
000012r 2               .ifndef KBD
000012r 2  rr rr 4C 4F  		keyword_rts "LOAD", LOAD
000016r 2  41 C4 xx     
000013r 2  rr rr 53 41  		keyword_rts "SAVE", SAVE
000017r 2  56 C5 xx     
000014r 2               .endif
000014r 2               .ifdef CONFIG_CBM_ALL
000014r 2               		keyword_rts "VERIFY", VERIFY
000014r 2               .endif
000014r 2  rr rr 44 45  		keyword_rts "DEF", DEF
000018r 2  C6 xx        
000015r 2               .ifdef KBD
000015r 2               		keyword_rts "SLOD", SLOD
000015r 2               .endif
000015r 2               .ifndef CONFIG_NO_POKE
000015r 2  rr rr 50 4F  		keyword_rts "POKE", POKE
000019r 2  4B C5 xx     
000016r 2               .endif
000016r 2               .ifdef CONFIG_FILE
000016r 2               		keyword_rts "PRINT#", PRINTH
000016r 2               .endif
000016r 2  rr rr 50 52  		keyword_rts "PRINT", PRINT, TOKEN_PRINT
00001Ar 2  49 4E D4 xx  
000017r 2  rr rr 43 4F  		keyword_rts "CONT", CONT
00001Br 2  4E D4 xx     
000018r 2  rr rr 4C 49  		keyword_rts "LIST", LIST
00001Cr 2  53 D4 xx     
000019r 2               .ifdef CONFIG_CBM_ALL
000019r 2               		keyword_rts "CLR", CLEAR
000019r 2               .else
000019r 2  rr rr 43 4C  		keyword_rts "CLEAR", CLEAR
00001Dr 2  45 41 D2 xx  
00001Ar 2               .endif
00001Ar 2               .ifdef CONFIG_FILE
00001Ar 2               		keyword_rts "CMD", CMD
00001Ar 2               		keyword_rts "SYS", SYS
00001Ar 2               		keyword_rts "OPEN", OPEN
00001Ar 2               		keyword_rts "CLOSE", CLOSE
00001Ar 2               .endif
00001Ar 2               .ifndef CONFIG_SMALL
00001Ar 2  rr rr 47 45  		keyword_rts "GET", GET
00001Er 2  D4 xx        
00001Br 2               .endif
00001Br 2               .ifdef KBD
00001Br 2               		keyword_rts "PRT", PRT
00001Br 2               .endif
00001Br 2  rr rr 4E 45  		keyword_rts "NEW", NEW
00001Fr 2  D7 xx        
00001Cr 2               .ifdef EATER
00001Cr 2  rr rr 4C 43  		keyword_rts "LCDCMD", LCDCMD
000020r 2  44 43 4D C4  
000024r 2  xx           
00001Dr 2  rr rr 4C 43  		keyword_rts "LCDPRINT", LCDPRINT
000021r 2  44 50 52 49  
000025r 2  4E D4 xx     
00001Er 2               .endif
00001Er 2               
00001Er 2               		count_tokens
00001Er 2               
00001Er 2  54 41 42 A8  		keyword	"TAB(", TOKEN_TAB
000022r 2  xx           
00001Fr 2  54 CF xx     		keyword	"TO", TOKEN_TO
000020r 2  46 CE xx     		keyword	"FN", TOKEN_FN
000021r 2  53 50 43 A8  		keyword	"SPC(", TOKEN_SPC
000025r 2  xx           
000022r 2  54 48 45 CE  		keyword	"THEN", TOKEN_THEN
000026r 2  xx           
000023r 2  4E 4F D4 xx  		keyword	"NOT", TOKEN_NOT
000024r 2  53 54 45 D0  		keyword	"STEP", TOKEN_STEP
000028r 2  xx           
000025r 2  AB xx        		keyword	"+", TOKEN_PLUS
000026r 2  AD xx        		keyword	"-", TOKEN_MINUS
000027r 2  AA xx        		keyword	"*"
000028r 2  AF xx        		keyword	"/"
000029r 2               .ifdef KBD
000029r 2               		keyword	"#"
000029r 2               .else
000029r 2  DE xx        		keyword	"^"
00002Ar 2               .endif
00002Ar 2  41 4E C4 xx  		keyword	"AND"
00002Br 2  4F D2 xx     		keyword	"OR"
00002Cr 2  BE xx        		keyword	">", TOKEN_GREATER
00002Dr 2  BD xx        		keyword	"=", TOKEN_EQUAL
00002Er 2  BC xx        		keyword	"<"
00002Fr 2               
00002Fr 2                       .segment "VECTORS"
00003Cr 2               UNFNC:
00003Cr 2               
00003Cr 2  rr rr 53 47  		keyword_addr "SGN", SGN, TOKEN_SGN
000040r 2  CE xx        
000030r 2  rr rr 49 4E  		keyword_addr "INT", INT
000034r 2  D4 xx        
000031r 2  rr rr 41 42  		keyword_addr "ABS", ABS
000035r 2  D3 xx        
000032r 2               .ifdef KBD
000032r 2               		keyword_addr "VER", VER
000032r 2               .endif
000032r 2               .ifndef CONFIG_NO_POKE
000032r 2                 .ifdef CONFIG_RAM
000032r 2               		keyword_addr "USR", IQERR
000032r 2                 .else
000032r 2  02 00 55 53  		keyword_addr "USR", USR, TOKEN_USR
000036r 2  D2 xx        
000033r 2                 .endif
000033r 2               .endif
000033r 2  rr rr 46 52  		keyword_addr "FRE", FRE
000037r 2  C5 xx        
000034r 2  rr rr 50 4F  		keyword_addr "POS", POS
000038r 2  D3 xx        
000035r 2  rr rr 53 51  		keyword_addr "SQR", SQR
000039r 2  D2 xx        
000036r 2  rr rr 52 4E  		keyword_addr "RND", RND
00003Ar 2  C4 xx        
000037r 2  rr rr 4C 4F  		keyword_addr "LOG", LOG
00003Br 2  C7 xx        
000038r 2  rr rr 45 58  		keyword_addr "EXP", EXP
00003Cr 2  D0 xx        
000039r 2               .segment "VECTORS"
000050r 2               UNFNC_COS:
000050r 2  rr rr 43 4F  		keyword_addr "COS", COS
000054r 2  D3 xx        
00003Ar 2               .segment "VECTORS"
000052r 2               UNFNC_SIN:
000052r 2  rr rr 53 49  		keyword_addr "SIN", SIN
000056r 2  CE xx        
00003Br 2               .segment "VECTORS"
000054r 2               UNFNC_TAN:
000054r 2  rr rr 54 41  		keyword_addr "TAN", TAN
000058r 2  CE xx        
00003Cr 2               .segment "VECTORS"
000056r 2               UNFNC_ATN:
000056r 2  rr rr 41 54  		keyword_addr "ATN", ATN
00005Ar 2  CE xx        
00003Dr 2               .ifdef KBD
00003Dr 2               		keyword_addr "GETC", GETC
00003Dr 2               .endif
00003Dr 2               .ifndef CONFIG_NO_POKE
00003Dr 2  rr rr 50 45  		keyword_addr "PEEK", PEEK
000041r 2  45 CB xx     
00003Er 2               .endif
00003Er 2  rr rr 4C 45  		keyword_addr "LEN", LEN
000042r 2  CE xx        
00003Fr 2  rr rr 53 54  		keyword_addr "STR$", STR
000043r 2  52 A4 xx     
000040r 2  rr rr 56 41  		keyword_addr "VAL", VAL
000044r 2  CC xx        
000041r 2  rr rr 41 53  		keyword_addr "ASC", ASC
000045r 2  C3 xx        
000042r 2  rr rr 43 48  		keyword_addr "CHR$", CHRSTR
000046r 2  52 A4 xx     
000043r 2  rr rr 4C 45  		keyword_addr "LEFT$", LEFTSTR, TOKEN_LEFTSTR
000047r 2  46 54 A4 xx  
000044r 2  rr rr 52 49  		keyword_addr "RIGHT$", RIGHTSTR
000048r 2  47 48 54 A4  
00004Cr 2  xx           
000045r 2  rr rr 4D 49  		keyword_addr "MID$", MIDSTR
000049r 2  44 A4 xx     
000046r 2               .ifdef CONFIG_2
000046r 2  47 CF xx     		keyword	"GO", TOKEN_GO
000047r 2               .endif
000047r 2                       .segment "KEYWORDS"
0000EEr 2  00           		.byte   0
0000EFr 2               
0000EFr 2                       .segment "VECTORS"
00006Ar 2               MATHTBL:
00006Ar 2  79                   .byte   $79
00006Br 2  rr rr                .word   FADDT-1
00006Dr 2  79                   .byte   $79
00006Er 2  rr rr                .word   FSUBT-1
000070r 2  7B                   .byte   $7B
000071r 2  rr rr                .word   FMULTT-1
000073r 2  7B                   .byte   $7B
000074r 2  rr rr                .word   FDIVT-1
000076r 2  7F                   .byte   $7F
000077r 2  rr rr                .word   FPWRT-1
000079r 2  50                   .byte   $50
00007Ar 2  rr rr                .word   TAND-1
00007Cr 2  46                   .byte   $46
00007Dr 2  rr rr                .word   OR-1
00007Fr 2  7D                   .byte   $7D
000080r 2  rr rr                .word   NEGOP-1
000082r 2  5A                   .byte   $5A
000083r 2  rr rr                .word   EQUOP-1
000085r 2  64                   .byte   $64
000086r 2  rr rr                .word   RELOPS-1
000088r 2               
000088r 1               .include "error.s"
000088r 2               init_error_table
000000r 2               
000000r 2               .ifdef CONFIG_SMALL_ERROR
000000r 2               define_error ERR_NOFOR, "NF"
000000r 2               define_error ERR_SYNTAX, "SN"
000000r 2               define_error ERR_NOGOSUB, "RG"
000000r 2               define_error ERR_NODATA, "OD"
000000r 2               define_error ERR_ILLQTY, "FC"
000000r 2               define_error ERR_OVERFLOW, "OV"
000000r 2               define_error ERR_MEMFULL, "OM"
000000r 2               define_error ERR_UNDEFSTAT, "US"
000000r 2               define_error ERR_BADSUBS, "BS"
000000r 2               define_error ERR_REDIMD, "DD"
000000r 2               define_error ERR_ZERODIV, "/0"
000000r 2               define_error ERR_ILLDIR, "ID"
000000r 2               define_error ERR_BADTYPE, "TM"
000000r 2               define_error ERR_STRLONG, "LS"
000000r 2               define_error ERR_FRMCPX, "ST"
000000r 2               define_error ERR_CANTCONT, "CN"
000000r 2               define_error ERR_UNDEFFN, "UF"
000000r 2               .else
000000r 2  4E 45 58 54  define_error ERR_NOFOR, "NEXT WITHOUT FOR"
000004r 2  20 57 49 54  
000008r 2  48 4F 55 54  
000010r 2  53 59 4E 54  define_error ERR_SYNTAX, "SYNTAX"
000014r 2  41 D8        
000016r 2  52 45 54 55  define_error ERR_NOGOSUB, "RETURN WITHOUT GOSUB"
00001Ar 2  52 4E 20 57  
00001Er 2  49 54 48 4F  
00002Ar 2  4F 55 54 20  define_error ERR_NODATA, "OUT OF DATA"
00002Er 2  4F 46 20 44  
000032r 2  41 54 C1     
000035r 2  49 4C 4C 45  define_error ERR_ILLQTY, "ILLEGAL QUANTITY"
000039r 2  47 41 4C 20  
00003Dr 2  51 55 41 4E  
000045r 2               .ifdef CBM1
000045r 2               	.byte 0,0,0,0,0
000045r 2               .endif
000045r 2  4F 56 45 52  define_error ERR_OVERFLOW, "OVERFLOW"
000049r 2  46 4C 4F D7  
00004Dr 2  4F 55 54 20  define_error ERR_MEMFULL, "OUT OF MEMORY"
000051r 2  4F 46 20 4D  
000055r 2  45 4D 4F 52  
00005Ar 2  55 4E 44 45  define_error ERR_UNDEFSTAT, "UNDEF'D STATEMENT"
00005Er 2  46 27 44 20  
000062r 2  53 54 41 54  
00006Br 2  42 41 44 20  define_error ERR_BADSUBS, "BAD SUBSCRIPT"
00006Fr 2  53 55 42 53  
000073r 2  43 52 49 50  
000078r 2  52 45 44 49  define_error ERR_REDIMD, "REDIM'D ARRAY"
00007Cr 2  4D 27 44 20  
000080r 2  41 52 52 41  
000085r 2  44 49 56 49  define_error ERR_ZERODIV, "DIVISION BY ZERO"
000089r 2  53 49 4F 4E  
00008Dr 2  20 42 59 20  
000095r 2  49 4C 4C 45  define_error ERR_ILLDIR, "ILLEGAL DIRECT"
000099r 2  47 41 4C 20  
00009Dr 2  44 49 52 45  
0000A3r 2  54 59 50 45  define_error ERR_BADTYPE, "TYPE MISMATCH"
0000A7r 2  20 4D 49 53  
0000ABr 2  4D 41 54 43  
0000B0r 2  53 54 52 49  define_error ERR_STRLONG, "STRING TOO LONG"
0000B4r 2  4E 47 20 54  
0000B8r 2  4F 4F 20 4C  
0000BFr 2               .ifdef CONFIG_FILE
0000BFr 2                 .ifdef CBM1
0000BFr 2               define_error ERR_BADDATA, "BAD DATA"
0000BFr 2                 .else
0000BFr 2               define_error ERR_BADDATA, "FILE DATA"
0000BFr 2                 .endif
0000BFr 2               .endif
0000BFr 2  46 4F 52 4D  define_error ERR_FRMCPX, "FORMULA TOO COMPLEX"
0000C3r 2  55 4C 41 20  
0000C7r 2  54 4F 4F 20  
0000D2r 2  43 41 4E 27  define_error ERR_CANTCONT, "CAN'T CONTINUE"
0000D6r 2  54 20 43 4F  
0000DAr 2  4E 54 49 4E  
0000E0r 2  55 4E 44 45  define_error ERR_UNDEFFN, "UNDEF'D FUNCTION"
0000E4r 2  46 27 44 20  
0000E8r 2  46 55 4E 43  
0000F0r 2               .endif
0000F0r 2               
0000F0r 1               .include "message.s"
0000F0r 2               ; global messages: "error", "in", "ready", "break"
0000F0r 2               
0000F0r 2               .segment "CODE"
000000r 2               
000000r 2               QT_ERROR:
000000r 2               .ifdef KBD
000000r 2                       .byte   " err"
000000r 2               .else
000000r 2                 .ifdef APPLE
000000r 2                       .byte   " ERR"
000000r 2               		.byte	$07,$07
000000r 2                 .else
000000r 2  20 45 52 52          .byte   " ERROR"
000004r 2  4F 52        
000006r 2                 .endif
000006r 2               .endif
000006r 2  00                   .byte   0
000007r 2               
000007r 2               .ifndef KBD
000007r 2               QT_IN:
000007r 2  20 49 4E 20          .byte   " IN "
00000Br 2  00                   .byte   $00
00000Cr 2               .endif
00000Cr 2               
00000Cr 2               .ifdef KBD
00000Cr 2               		.byte	$54,$D2 ; ???
00000Cr 2               OKPRT:
00000Cr 2               		jsr     PRIMM
00000Cr 2                       .byte   CR,CR,">>",CR,LF
00000Cr 2               		.byte	0
00000Cr 2                       rts
00000Cr 2                       nop
00000Cr 2               .else
00000Cr 2                .ifndef AIM65
00000Cr 2               QT_OK:
00000Cr 2                 .ifdef CONFIG_CBM_ALL
00000Cr 2               		.byte   CR,LF,"READY.",CR,LF
00000Cr 2                 .else
00000Cr 2                   .ifdef APPLE
00000Cr 2               		; binary patch!
00000Cr 2                       .byte   CR,0,0,"K",CR,LF
00000Cr 2                   .else
00000Cr 2  0D 0A 4F 4B  		.byte   CR,LF,"OK",CR,LF
000010r 2  0D 0A        
000012r 2                   .endif
000012r 2                 .endif
000012r 2  00           		.byte	0
000013r 2                .endif
000013r 2               .endif
000013r 2               QT_BREAK:
000013r 2               
000013r 2               .ifdef KBD
000013r 2               		.byte	CR,LF," Brk"
000013r 2                       .byte   0
000013r 2                       .byte   $54,$D0 ; ???
000013r 2               .elseif .def(MICROTAN) || .def(AIM65)
000013r 2               		.byte CR,LF," BREAK"
000013r 2                       .byte   0
000013r 2               .else
000013r 2  0D 0A 42 52  		.byte CR,LF,"BREAK"
000017r 2  45 41 4B     
00001Ar 2  00                   .byte   0
00001Br 2               .endif
00001Br 2               
00001Br 1               .include "memory.s"
00001Br 2               ; generic stack and memory management code
00001Br 2               ; this code is identical across all versions of
00001Br 2               ; BASIC
00001Br 2               
00001Br 2               .segment "CODE"
00001Br 2               
00001Br 2               ; ----------------------------------------------------------------------------
00001Br 2               ; CALLED BY "NEXT" AND "FOR" TO SCAN THROUGH
00001Br 2               ; THE STACK FOR A FRAME WITH THE SAME VARIABLE.
00001Br 2               ;
00001Br 2               ; (FORPNT) = ADDRESS OF VARIABLE IF "FOR" OR "NEXT"
00001Br 2               ; 	= $XXFF IF CALLED FROM "RETURN"
00001Br 2               ; 	<<< BUG: SHOULD BE $FFXX >>>
00001Br 2               ;
00001Br 2               ;	RETURNS .NE. IF VARIABLE NOT FOUND,
00001Br 2               ;	(X) = STACK PNTR AFTER SKIPPING ALL FRAMES
00001Br 2               ;
00001Br 2               ;	.EQ. IF FOUND
00001Br 2               ;	(X) = STACK PNTR OF FRAME FOUND
00001Br 2               ; ----------------------------------------------------------------------------
00001Br 2               GTFORPNT:
00001Br 2  BA                   tsx
00001Cr 2  E8                   inx
00001Dr 2  E8                   inx
00001Er 2  E8                   inx
00001Fr 2  E8                   inx
000020r 2               L2279:
000020r 2  BD 01 01             lda     STACK+1,x
000023r 2  C9 81                cmp     #$81
000025r 2  D0 21                bne     L22A1
000027r 2  A5 A1                lda     FORPNT+1
000029r 2  D0 0A                bne     L228E
00002Br 2  BD 02 01             lda     STACK+2,x
00002Er 2  85 A0                sta     FORPNT
000030r 2  BD 03 01             lda     STACK+3,x
000033r 2  85 A1                sta     FORPNT+1
000035r 2               L228E:
000035r 2  DD 03 01             cmp     STACK+3,x
000038r 2  D0 07                bne     L229A
00003Ar 2  A5 A0                lda     FORPNT
00003Cr 2  DD 02 01             cmp     STACK+2,x
00003Fr 2  F0 07                beq     L22A1
000041r 2               L229A:
000041r 2  8A                   txa
000042r 2  18                   clc
000043r 2  69 12                adc     #BYTES_PER_FRAME
000045r 2  AA                   tax
000046r 2  D0 D8                bne     L2279
000048r 2               L22A1:
000048r 2  60                   rts
000049r 2               
000049r 2               ; ----------------------------------------------------------------------------
000049r 2               ; MOVE BLOCK OF MEMORY UP
000049r 2               ;
000049r 2               ; ON ENTRY:
000049r 2               ;	(Y,A) = (HIGHDS) = DESTINATION END+1
000049r 2               ;	(LOWTR) = LOWEST ADDRESS OF SOURCE
000049r 2               ;	(HIGHTR) = HIGHEST SOURCE ADDRESS+1
000049r 2               ; ----------------------------------------------------------------------------
000049r 2               BLTU:
000049r 2  20 rr rr             jsr     REASON
00004Cr 2  85 88                sta     STREND
00004Er 2  84 89                sty     STREND+1
000050r 2               BLTU2:
000050r 2  38                   sec
000051r 2  A5 B1                lda     HIGHTR
000053r 2  E5 B6                sbc     LOWTR
000055r 2  85 79                sta     INDEX
000057r 2  A8                   tay
000058r 2  A5 B2                lda     HIGHTR+1
00005Ar 2  E5 B7                sbc     LOWTR+1
00005Cr 2  AA                   tax
00005Dr 2  E8                   inx
00005Er 2  98                   tya
00005Fr 2  F0 23                beq     L22DD
000061r 2  A5 B1                lda     HIGHTR
000063r 2  38                   sec
000064r 2  E5 79                sbc     INDEX
000066r 2  85 B1                sta     HIGHTR
000068r 2  B0 03                bcs     L22C6
00006Ar 2  C6 B2                dec     HIGHTR+1
00006Cr 2  38                   sec
00006Dr 2               L22C6:
00006Dr 2  A5 AF                lda     HIGHDS
00006Fr 2  E5 79                sbc     INDEX
000071r 2  85 AF                sta     HIGHDS
000073r 2  B0 08                bcs     L22D6
000075r 2  C6 B0                dec     HIGHDS+1
000077r 2  90 04                bcc     L22D6
000079r 2               L22D2:
000079r 2  B1 B1                lda     (HIGHTR),y
00007Br 2  91 AF                sta     (HIGHDS),y
00007Dr 2               L22D6:
00007Dr 2  88                   dey
00007Er 2  D0 F9                bne     L22D2
000080r 2  B1 B1                lda     (HIGHTR),y
000082r 2  91 AF                sta     (HIGHDS),y
000084r 2               L22DD:
000084r 2  C6 B2                dec     HIGHTR+1
000086r 2  C6 B0                dec     HIGHDS+1
000088r 2  CA                   dex
000089r 2  D0 F2                bne     L22D6
00008Br 2  60                   rts
00008Cr 2               
00008Cr 2               ; ----------------------------------------------------------------------------
00008Cr 2               ; CHECK IF ENOUGH ROOM LEFT ON STACK
00008Cr 2               ; FOR "FOR", "GOSUB", OR EXPRESSION EVALUATION
00008Cr 2               ; ----------------------------------------------------------------------------
00008Cr 2               CHKMEM:
00008Cr 2  0A                   asl     a
00008Dr 2  69 3E                adc     #SPACE_FOR_GOSUB
00008Fr 2  B0 35                bcs     MEMERR
000091r 2  85 79                sta     INDEX
000093r 2  BA                   tsx
000094r 2  E4 79                cpx     INDEX
000096r 2  90 2E                bcc     MEMERR
000098r 2  60                   rts
000099r 2               
000099r 2               ; ----------------------------------------------------------------------------
000099r 2               ; CHECK IF ENOUGH ROOM BETWEEN ARRAYS AND STRINGS
000099r 2               ; (Y,A) = ADDR ARRAYS NEED TO GROW TO
000099r 2               ; ----------------------------------------------------------------------------
000099r 2               REASON:
000099r 2  C4 8B                cpy     FRETOP+1
00009Br 2  90 28                bcc     L231E
00009Dr 2  D0 04                bne     L22FC
00009Fr 2  C5 8A                cmp     FRETOP
0000A1r 2  90 22                bcc     L231E
0000A3r 2               L22FC:
0000A3r 2  48                   pha
0000A4r 2  A2 09                ldx     #FAC-TEMP1-1
0000A6r 2  98                   tya
0000A7r 2               L2300:
0000A7r 2  48                   pha
0000A8r 2  B5 AE                lda     TEMP1,x
0000AAr 2  CA                   dex
0000ABr 2  10 FA                bpl     L2300
0000ADr 2  20 rr rr             jsr     GARBAG
0000B0r 2  A2 F7                ldx     #TEMP1-FAC+1
0000B2r 2               L230B:
0000B2r 2  68                   pla
0000B3r 2  95 B8                sta     FAC,x
0000B5r 2  E8                   inx
0000B6r 2  30 FA                bmi     L230B
0000B8r 2  68                   pla
0000B9r 2  A8                   tay
0000BAr 2  68                   pla
0000BBr 2  C4 8B                cpy     FRETOP+1
0000BDr 2  90 06                bcc     L231E
0000BFr 2  D0 05                bne     MEMERR
0000C1r 2  C5 8A                cmp     FRETOP
0000C3r 2  B0 01                bcs     MEMERR
0000C5r 2               L231E:
0000C5r 2  60                   rts
0000C6r 2               
0000C6r 1               .include "program.s"
0000C6r 2               ; error
0000C6r 2               ; line input, line editing
0000C6r 2               ; tokenize
0000C6r 2               ; detokenize
0000C6r 2               ; BASIC program memory management
0000C6r 2               
0000C6r 2               ; MICROTAN has some nonstandard extension to LIST here
0000C6r 2               
0000C6r 2               .segment "CODE"
0000C6r 2               
0000C6r 2               MEMERR:
0000C6r 2  A2 4D                ldx     #ERR_MEMFULL
0000C8r 2               
0000C8r 2               ; ----------------------------------------------------------------------------
0000C8r 2               ; HANDLE AN ERROR
0000C8r 2               ;
0000C8r 2               ; (X)=OFFSET IN ERROR MESSAGE TABLE
0000C8r 2               ; (ERRFLG) > 128 IF "ON ERR" TURNED ON
0000C8r 2               ; (CURLIN+1) = $FF IF IN DIRECT MODE
0000C8r 2               ; ----------------------------------------------------------------------------
0000C8r 2               ERROR:
0000C8r 2  46 6C                lsr     Z14
0000CAr 2               .ifdef CONFIG_FILE
0000CAr 2                       lda     CURDVC    ; output
0000CAr 2                       beq     LC366     ; is screen
0000CAr 2                       jsr     CLRCH     ; otherwise redirect output back to screen
0000CAr 2                       lda     #$00
0000CAr 2                       sta     CURDVC
0000CAr 2               LC366:
0000CAr 2               .endif
0000CAr 2  20 rr rr             jsr     CRDO
0000CDr 2  20 rr rr             jsr     OUTQUES
0000D0r 2               L2329:
0000D0r 2  BD rr rr             lda     ERROR_MESSAGES,x
0000D3r 2               .ifndef CONFIG_SMALL_ERROR
0000D3r 2  48                   pha
0000D4r 2  29 7F                and     #$7F
0000D6r 2               .endif
0000D6r 2  20 rr rr             jsr     OUTDO
0000D9r 2               .ifdef CONFIG_SMALL_ERROR
0000D9r 2                       lda     ERROR_MESSAGES+1,x
0000D9r 2                 .ifdef KBD
0000D9r 2                       and     #$7F
0000D9r 2                 .endif
0000D9r 2                       jsr     OUTDO
0000D9r 2               .else
0000D9r 2  E8                   inx
0000DAr 2  68                   pla
0000DBr 2  10 F3                bpl     L2329
0000DDr 2               .endif
0000DDr 2  20 rr rr             jsr     STKINI
0000E0r 2  A9 rr                lda     #<QT_ERROR
0000E2r 2  A0 rr                ldy     #>QT_ERROR
0000E4r 2               
0000E4r 2               ; ----------------------------------------------------------------------------
0000E4r 2               ; PRINT STRING AT (Y,A)
0000E4r 2               ; PRINT CURRENT LINE # UNLESS IN DIRECT MODE
0000E4r 2               ; FALL INTO WARM RESTART
0000E4r 2               ; ----------------------------------------------------------------------------
0000E4r 2               PRINT_ERROR_LINNUM:
0000E4r 2  20 rr rr             jsr     STROUT
0000E7r 2  A4 91                ldy     CURLIN+1
0000E9r 2  C8                   iny
0000EAr 2  F0 03                beq     RESTART
0000ECr 2  20 rr rr             jsr     INPRT
0000EFr 2               
0000EFr 2               ; ----------------------------------------------------------------------------
0000EFr 2               ; WARM RESTART ENTRY
0000EFr 2               ; ----------------------------------------------------------------------------
0000EFr 2               RESTART:
0000EFr 2               .ifdef KBD
0000EFr 2                       jsr     CRDO
0000EFr 2                       nop
0000EFr 2               L2351X:
0000EFr 2                       jsr     OKPRT
0000EFr 2               L2351:
0000EFr 2                       jsr     INLIN
0000EFr 2               LE28E:
0000EFr 2                       bpl     RESTART
0000EFr 2               .else
0000EFr 2  46 6C                lsr     Z14
0000F1r 2                .ifndef AIM65
0000F1r 2  A9 rr                lda     #<QT_OK
0000F3r 2  A0 rr                ldy     #>QT_OK
0000F5r 2                 .ifdef CONFIG_CBM_ALL
0000F5r 2                       jsr     STROUT
0000F5r 2                 .else
0000F5r 2  20 05 00             jsr     GOSTROUT
0000F8r 2                 .endif
0000F8r 2                .else
0000F8r 2                       jsr     GORESTART
0000F8r 2                .endif
0000F8r 2               L2351:
0000F8r 2  20 rr rr             jsr     INLIN
0000FBr 2               .endif
0000FBr 2  86 D1                stx     TXTPTR
0000FDr 2  84 D2                sty     TXTPTR+1
0000FFr 2  20 CA 00             jsr     CHRGET
000102r 2               .ifdef CONFIG_11
000102r 2               ; bug in pre-1.1: CHRGET sets Z on '\0'
000102r 2               ; and ':' - a line starting with ':' in
000102r 2               ; direct mode gets ignored
000102r 2  AA                   tax
000103r 2               .endif
000103r 2               .ifdef KBD
000103r 2                       beq     L2351X
000103r 2               .else
000103r 2  F0 F3                beq     L2351
000105r 2               .endif
000105r 2  A2 FF                ldx     #$FF
000107r 2  86 91                stx     CURLIN+1
000109r 2  90 06                bcc     NUMBERED_LINE
00010Br 2  20 rr rr             jsr     PARSE_INPUT_LINE
00010Er 2  4C rr rr             jmp     NEWSTT2
000111r 2               
000111r 2               ; ----------------------------------------------------------------------------
000111r 2               ; HANDLE NUMBERED LINE
000111r 2               ; ----------------------------------------------------------------------------
000111r 2               NUMBERED_LINE:
000111r 2  20 rr rr             jsr     LINGET
000114r 2  20 rr rr             jsr     PARSE_INPUT_LINE
000117r 2  84 64                sty     EOLPNTR
000119r 2               .ifdef KBD
000119r 2                       jsr     FNDLIN2
000119r 2                       lda     JMPADRS+1
000119r 2                       sta     LOWTR
000119r 2                       sta     Z96
000119r 2                       lda     JMPADRS+2
000119r 2                       sta     LOWTR+1
000119r 2                       sta     Z96+1
000119r 2                       lda     LINNUM
000119r 2                       sta     L06FE
000119r 2                       lda     LINNUM+1
000119r 2                       sta     L06FE+1
000119r 2                       inc     LINNUM
000119r 2                       bne     LE2D2
000119r 2                       inc     LINNUM+1
000119r 2                       bne     LE2D2
000119r 2                       jmp     SYNERR
000119r 2               LE2D2:
000119r 2                       jsr     LF457
000119r 2                       ldx     #Z96
000119r 2                       jsr     CMPJMPADRS
000119r 2                       bcs     LE2FD
000119r 2               LE2DC:
000119r 2                       ldx     #$00
000119r 2                       lda     (JMPADRS+1,x)
000119r 2                       sta     (Z96,x)
000119r 2                       inc     JMPADRS+1
000119r 2                       bne     LE2E8
000119r 2                       inc     JMPADRS+2
000119r 2               LE2E8:
000119r 2                       inc     Z96
000119r 2                       bne     LE2EE
000119r 2                       inc     Z96+1
000119r 2               LE2EE:
000119r 2                       ldx     #VARTAB
000119r 2                       jsr     CMPJMPADRS
000119r 2                       bne     LE2DC
000119r 2                       lda     Z96
000119r 2                       sta     VARTAB
000119r 2                       lda     Z96+1
000119r 2                       sta     VARTAB+1
000119r 2               LE2FD:
000119r 2                       jsr     SETPTRS
000119r 2                       jsr     LE33D
000119r 2                       lda     INPUTBUFFER
000119r 2               LE306:
000119r 2                       beq     LE28E
000119r 2                       cmp     #$A5
000119r 2                       beq     LE306
000119r 2                       clc
000119r 2               .else
000119r 2  20 rr rr             jsr     FNDLIN
00011Cr 2  90 44                bcc     PUT_NEW_LINE
00011Er 2  A0 01                ldy     #$01
000120r 2  B1 B6                lda     (LOWTR),y
000122r 2  85 7A                sta     INDEX+1
000124r 2  A5 84                lda     VARTAB
000126r 2  85 79                sta     INDEX
000128r 2  A5 B7                lda     LOWTR+1
00012Ar 2  85 7C                sta     DEST+1
00012Cr 2  A5 B6                lda     LOWTR
00012Er 2  88                   dey
00012Fr 2  F1 B6                sbc     (LOWTR),y
000131r 2  18                   clc
000132r 2  65 84                adc     VARTAB
000134r 2  85 84                sta     VARTAB
000136r 2  85 7B                sta     DEST
000138r 2  A5 85                lda     VARTAB+1
00013Ar 2  69 FF                adc     #$FF
00013Cr 2  85 85                sta     VARTAB+1
00013Er 2  E5 B7                sbc     LOWTR+1
000140r 2  AA                   tax
000141r 2  38                   sec
000142r 2  A5 B6                lda     LOWTR
000144r 2  E5 84                sbc     VARTAB
000146r 2  A8                   tay
000147r 2  B0 03                bcs     L23A5
000149r 2  E8                   inx
00014Ar 2  C6 7C                dec     DEST+1
00014Cr 2               L23A5:
00014Cr 2  18                   clc
00014Dr 2  65 79                adc     INDEX
00014Fr 2  90 03                bcc     L23AD
000151r 2  C6 7A                dec     INDEX+1
000153r 2  18                   clc
000154r 2               L23AD:
000154r 2  B1 79                lda     (INDEX),y
000156r 2  91 7B                sta     (DEST),y
000158r 2  C8                   iny
000159r 2  D0 F9                bne     L23AD
00015Br 2  E6 7A                inc     INDEX+1
00015Dr 2  E6 7C                inc     DEST+1
00015Fr 2  CA                   dex
000160r 2  D0 F2                bne     L23AD
000162r 2               .endif
000162r 2               ; ----------------------------------------------------------------------------
000162r 2               PUT_NEW_LINE:
000162r 2               .ifndef KBD
000162r 2                 .ifdef CONFIG_2
000162r 2  20 rr rr             jsr     SETPTRS
000165r 2  20 rr rr             jsr     LE33D
000168r 2  A5 12                lda     INPUTBUFFER
00016Ar 2  F0 8C                beq     L2351
00016Cr 2  18                   clc
00016Dr 2                 .else
00016Dr 2                       lda     INPUTBUFFER
00016Dr 2                       beq     FIX_LINKS
00016Dr 2                       lda     MEMSIZ
00016Dr 2                       ldy     MEMSIZ+1
00016Dr 2                       sta     FRETOP
00016Dr 2                       sty     FRETOP+1
00016Dr 2                 .endif
00016Dr 2               .endif
00016Dr 2  A5 84                lda     VARTAB
00016Fr 2  85 B1                sta     HIGHTR
000171r 2  65 64                adc     EOLPNTR
000173r 2  85 AF                sta     HIGHDS
000175r 2  A4 85                ldy     VARTAB+1
000177r 2  84 B2                sty     HIGHTR+1
000179r 2  90 01                bcc     L23D6
00017Br 2  C8                   iny
00017Cr 2               L23D6:
00017Cr 2  84 B0                sty     HIGHDS+1
00017Er 2  20 rr rr             jsr     BLTU
000181r 2               .ifdef CONFIG_INPUTBUFFER_0200
000181r 2                       lda     LINNUM
000181r 2                       ldy     LINNUM+1
000181r 2                       sta     INPUTBUFFER-2
000181r 2                       sty     INPUTBUFFER-1
000181r 2               .endif
000181r 2  A5 88                lda     STREND
000183r 2  A4 89                ldy     STREND+1
000185r 2  85 84                sta     VARTAB
000187r 2  84 85                sty     VARTAB+1
000189r 2  A4 64                ldy     EOLPNTR
00018Br 2  88                   dey
00018Cr 2               ; ---COPY LINE INTO PROGRAM-------
00018Cr 2               L23E6:
00018Cr 2  B9 0E 00             lda     INPUTBUFFER-4,y
00018Fr 2  91 B6                sta     (LOWTR),y
000191r 2  88                   dey
000192r 2  10 F8                bpl     L23E6
000194r 2               
000194r 2               ; ----------------------------------------------------------------------------
000194r 2               ; CLEAR ALL VARIABLES
000194r 2               ; RE-ESTABLISH ALL FORWARD LINKS
000194r 2               ; ----------------------------------------------------------------------------
000194r 2               FIX_LINKS:
000194r 2  20 rr rr             jsr     SETPTRS
000197r 2               .ifdef CONFIG_2
000197r 2  20 rr rr             jsr     LE33D
00019Ar 2  4C rr rr             jmp     L2351
00019Dr 2               LE33D:
00019Dr 2               .endif
00019Dr 2  A5 82                lda     TXTTAB
00019Fr 2  A4 83                ldy     TXTTAB+1
0001A1r 2  85 79                sta     INDEX
0001A3r 2  84 7A                sty     INDEX+1
0001A5r 2  18                   clc
0001A6r 2               L23FA:
0001A6r 2  A0 01                ldy     #$01
0001A8r 2  B1 79                lda     (INDEX),y
0001AAr 2               .ifdef CONFIG_2
0001AAr 2  F0 1D                beq     RET3
0001ACr 2               .else
0001ACr 2                       jeq     L2351
0001ACr 2               .endif
0001ACr 2  A0 04                ldy     #$04
0001AEr 2               L2405:
0001AEr 2  C8                   iny
0001AFr 2  B1 79                lda     (INDEX),y
0001B1r 2  D0 FB                bne     L2405
0001B3r 2  C8                   iny
0001B4r 2  98                   tya
0001B5r 2  65 79                adc     INDEX
0001B7r 2  AA                   tax
0001B8r 2  A0 00                ldy     #$00
0001BAr 2  91 79                sta     (INDEX),y
0001BCr 2  A5 7A                lda     INDEX+1
0001BEr 2  69 00                adc     #$00
0001C0r 2  C8                   iny
0001C1r 2  91 79                sta     (INDEX),y
0001C3r 2  86 79                stx     INDEX
0001C5r 2  85 7A                sta     INDEX+1
0001C7r 2  90 DD                bcc     L23FA	; always
0001C9r 2               
0001C9r 2               ; ----------------------------------------------------------------------------
0001C9r 2               .ifdef KBD
0001C9r 2               .include "kbd_loadsave.s"
0001C9r 2               .endif
0001C9r 2               
0001C9r 2               .ifdef CONFIG_2
0001C9r 2               ; !!! kbd_loadsave.s requires an RTS here!
0001C9r 2               RET3:
0001C9r 2  60           		rts
0001CAr 2               .endif
0001CAr 2               
0001CAr 2               .include "inline.s"
0001CAr 3               .segment "CODE"
0001CAr 3               
0001CAr 3               .ifndef CONFIG_NO_INPUTBUFFER_ZP
0001CAr 3               L2420:
0001CAr 3                 .ifdef OSI
0001CAr 3                       jsr     OUTDO
0001CAr 3                 .endif
0001CAr 3  CA                   dex
0001CBr 3                 .ifdef AIM65
0001CBr 3                       bmi     L2423
0001CBr 3                       jsr     PSLS
0001CBr 3                       jmp     INLIN2
0001CBr 3               LB35F:
0001CBr 3                       jsr     OUTDO
0001CBr 3                 .else
0001CBr 3  10 05                bpl     INLIN2
0001CDr 3                 .endif
0001CDr 3               L2423:
0001CDr 3                 .ifdef OSI
0001CDr 3                       jsr     OUTDO
0001CDr 3                 .endif
0001CDr 3  20 rr rr             jsr     CRDO
0001D0r 3               .endif
0001D0r 3               
0001D0r 3               ; ----------------------------------------------------------------------------
0001D0r 3               ; READ A LINE, AND STRIP OFF SIGN BITS
0001D0r 3               ; ----------------------------------------------------------------------------
0001D0r 3               .ifndef KBD
0001D0r 3               INLIN:
0001D0r 3                 .ifdef APPLE
0001D0r 3                       ldx     #$DD
0001D0r 3               INLIN1:
0001D0r 3                       stx     $33
0001D0r 3                       jsr     L2900
0001D0r 3                       cpx     #$EF
0001D0r 3                       bcs     L0C32
0001D0r 3                       ldx     #$EF
0001D0r 3               L0C32:
0001D0r 3                       lda     #$00
0001D0r 3                       sta     INPUTBUFFER,x
0001D0r 3                       ldx     #<INPUTBUFFER-1
0001D0r 3                       ldy     #>INPUTBUFFER-1
0001D0r 3                       rts
0001D0r 3                 .endif
0001D0r 3               
0001D0r 3                 .ifndef APPLE
0001D0r 3  A2 00                ldx     #$00
0001D2r 3               INLIN2:
0001D2r 3  20 rr rr             jsr     GETLN
0001D5r 3                   .ifdef AIM65
0001D5r 3                       cmp     #$1A
0001D5r 3                       bne     INLINAIM
0001D5r 3                       jsr     DU13
0001D5r 3                       jmp     INLIN
0001D5r 3               INLINAIM:
0001D5r 3                   .endif
0001D5r 3                   .ifndef CONFIG_NO_LINE_EDITING
0001D5r 3  C9 07                cmp     #$07
0001D7r 3  F0 14                beq     L2443
0001D9r 3                   .endif
0001D9r 3  C9 0D                cmp     #$0D
0001DBr 3  F0 20                beq     L2453
0001DDr 3                   .ifndef CONFIG_NO_LINE_EDITING
0001DDr 3  C9 20                cmp     #$20
0001DFr 3                     .ifdef AIM65
0001DFr 3                       bcc     L244E
0001DFr 3                     .else
0001DFr 3  90 F1                bcc     INLIN2
0001E1r 3                     .endif
0001E1r 3                     .ifdef MICROTAN
0001E1r 3                       cmp     #$80
0001E1r 3                     .else
0001E1r 3                       .ifdef AIM65
0001E1r 3                       cmp     #$7F
0001E1r 3                       beq     L2420
0001E1r 3                       .endif
0001E1r 3  C9 7D                cmp     #$7D
0001E3r 3                     .endif
0001E3r 3  B0 ED                bcs     INLIN2
0001E5r 3  C9 40                cmp     #$40 ; @
0001E7r 3                     .ifdef AIM65
0001E7r 3                       beq     LB35F
0001E7r 3                     .else
0001E7r 3  F0 E4                beq     L2423
0001E9r 3                     .ifdef MICROTAN
0001E9r 3                       cmp     #$7F ; DEL
0001E9r 3                     .else
0001E9r 3  C9 5F                cmp     #$5F ; _
0001EBr 3                     .endif
0001EBr 3  F0 DD                beq     L2420
0001EDr 3                     .endif
0001EDr 3               L2443:
0001EDr 3                     .ifdef MICROTAN
0001EDr 3                       cpx     #$4F
0001EDr 3                     .else
0001EDr 3  E0 47                cpx     #$47
0001EFr 3                     .endif
0001EFr 3  B0 05                bcs     L244C
0001F1r 3                   .endif
0001F1r 3  95 12                sta     INPUTBUFFER,x
0001F3r 3  E8                   inx
0001F4r 3                   .if .def(OSI) || .def(AIM65)
0001F4r 3                       .byte   $2C
0001F4r 3                   .else
0001F4r 3  D0 DC                bne     INLIN2
0001F6r 3                   .endif
0001F6r 3               L244C:
0001F6r 3                   .ifndef CONFIG_NO_LINE_EDITING
0001F6r 3  A9 07                lda     #$07 ; BEL
0001F8r 3               L244E:
0001F8r 3  20 rr rr             jsr     OUTDO
0001FBr 3  D0 D5                bne     INLIN2
0001FDr 3                   .endif
0001FDr 3               L2453:
0001FDr 3  4C rr rr             jmp     L29B9
000200r 3                 .endif
000200r 3               .endif
000200r 3               
000200r 3               .ifndef KBD
000200r 3                 .ifndef APPLE
000200r 3               GETLN:
000200r 3                   .ifdef CONFIG_FILE
000200r 3                       jsr     CHRIN
000200r 3                       ldy     CURDVC
000200r 3                       bne     L2465
000200r 3                   .else
000200r 3  20 rr rr             jsr     MONRDKEY
000203r 3                   .endif
000203r 3                   .ifdef OSI
000203r 3                       nop
000203r 3                       nop
000203r 3                       nop
000203r 3                       nop
000203r 3                       nop
000203r 3                       nop
000203r 3                       nop
000203r 3                       nop
000203r 3                       nop
000203r 3                       nop
000203r 3                       nop
000203r 3                       nop
000203r 3                       nop
000203r 3                       nop
000203r 3                       and     #$7F
000203r 3                   .endif
000203r 3                 .endif
000203r 3                 .ifdef APPLE
000203r 3               RDKEY:
000203r 3                       jsr     LFD0C
000203r 3                       and     #$7F
000203r 3                 .endif
000203r 3                   .ifdef SYM1
000203r 3                       cmp     #$14
000203r 3                   .else
000203r 3  C9 0F                cmp     #$0F
000205r 3                   .endif
000205r 3  D0 08                bne     L2465
000207r 3  48                   pha
000208r 3  A5 6C                lda     Z14
00020Ar 3  49 FF                eor     #$FF
00020Cr 3  85 6C                sta     Z14
00020Er 3  68                   pla
00020Fr 3               L2465:
00020Fr 3  60                   rts
000210r 3               .endif
000210r 3               
000210r 2               
000210r 2               ; ----------------------------------------------------------------------------
000210r 2               ; TOKENIZE THE INPUT LINE
000210r 2               ; ----------------------------------------------------------------------------
000210r 2               PARSE_INPUT_LINE:
000210r 2  A6 D1                ldx     TXTPTR
000212r 2  A0 04                ldy     #$04
000214r 2  84 68                sty     DATAFLG
000216r 2               L246C:
000216r 2  BD 00 00             lda     INPUTBUFFERX,x
000219r 2               .ifdef CONFIG_CBM_ALL
000219r 2                       bpl     LC49E
000219r 2                       cmp     #$FF
000219r 2                       beq     L24AC
000219r 2                       inx
000219r 2                       bne     L246C
000219r 2               LC49E:
000219r 2               .endif
000219r 2  C9 20                cmp     #$20
00021Br 2  F0 37                beq     L24AC
00021Dr 2  85 63                sta     ENDCHR
00021Fr 2  C9 22                cmp     #$22
000221r 2  F0 56                beq     L24D0
000223r 2  24 68                bit     DATAFLG
000225r 2  70 2D                bvs     L24AC
000227r 2  C9 3F                cmp     #$3F
000229r 2  D0 04                bne     L2484
00022Br 2  A9 96                lda     #TOKEN_PRINT
00022Dr 2  D0 25                bne     L24AC
00022Fr 2               L2484:
00022Fr 2  C9 30                cmp     #$30
000231r 2  90 04                bcc     L248C
000233r 2  C9 3C                cmp     #$3C
000235r 2  90 1D                bcc     L24AC
000237r 2               ; ----------------------------------------------------------------------------
000237r 2               ; SEARCH TOKEN NAME TABLE FOR MATCH STARTING
000237r 2               ; WITH CURRENT CHAR FROM INPUT LINE
000237r 2               ; ----------------------------------------------------------------------------
000237r 2               L248C:
000237r 2  84 C8                sty     STRNG2
000239r 2  A0 00                ldy     #$00
00023Br 2  84 64                sty     EOLPNTR
00023Dr 2  88                   dey
00023Er 2  86 D1                stx     TXTPTR
000240r 2  CA                   dex
000241r 2               L2496:
000241r 2  C8                   iny
000242r 2               L2497:
000242r 2  E8                   inx
000243r 2               L2498:
000243r 2               .ifdef KBD
000243r 2                       jsr     GET_UPPER
000243r 2               .else
000243r 2  BD 00 00             lda     INPUTBUFFERX,x
000246r 2                 .ifndef CONFIG_2
000246r 2                       cmp     #$20
000246r 2                       beq     L2497
000246r 2                 .endif
000246r 2               .endif
000246r 2  38                   sec
000247r 2  F9 rr rr             sbc     TOKEN_NAME_TABLE,y
00024Ar 2  F0 F5                beq     L2496
00024Cr 2  C9 80                cmp     #$80
00024Er 2  D0 30                bne     L24D7
000250r 2  05 64                ora     EOLPNTR
000252r 2               ; ----------------------------------------------------------------------------
000252r 2               ; STORE CHARACTER OR TOKEN IN OUTPUT LINE
000252r 2               ; ----------------------------------------------------------------------------
000252r 2               L24AA:
000252r 2  A4 C8                ldy     STRNG2
000254r 2               L24AC:
000254r 2  E8                   inx
000255r 2  C8                   iny
000256r 2  99 0D 00             sta     INPUTBUFFER-5,y
000259r 2  B9 0D 00             lda     INPUTBUFFER-5,y
00025Cr 2  F0 36                beq     L24EA
00025Er 2  38                   sec
00025Fr 2  E9 3A                sbc     #$3A
000261r 2  F0 04                beq     L24BF
000263r 2  C9 49                cmp     #$49
000265r 2  D0 02                bne     L24C1
000267r 2               L24BF:
000267r 2  85 68                sta     DATAFLG
000269r 2               L24C1:
000269r 2  38                   sec
00026Ar 2  E9 54                sbc     #TOKEN_REM-':'
00026Cr 2  D0 A8                bne     L246C
00026Er 2  85 63                sta     ENDCHR
000270r 2               ; ----------------------------------------------------------------------------
000270r 2               ; HANDLE LITERAL (BETWEEN QUOTES) OR REMARK,
000270r 2               ; BY COPYING CHARS UP TO ENDCHR.
000270r 2               ; ----------------------------------------------------------------------------
000270r 2               L24C8:
000270r 2  BD 00 00             lda     INPUTBUFFERX,x
000273r 2  F0 DF                beq     L24AC
000275r 2  C5 63                cmp     ENDCHR
000277r 2  F0 DB                beq     L24AC
000279r 2               L24D0:
000279r 2  C8                   iny
00027Ar 2  99 0D 00             sta     INPUTBUFFER-5,y
00027Dr 2  E8                   inx
00027Er 2  D0 F0                bne     L24C8
000280r 2               ; ----------------------------------------------------------------------------
000280r 2               ; ADVANCE POINTER TO NEXT TOKEN NAME
000280r 2               ; ----------------------------------------------------------------------------
000280r 2               L24D7:
000280r 2  A6 D1                ldx     TXTPTR
000282r 2  E6 64                inc     EOLPNTR
000284r 2               L24DB:
000284r 2  C8                   iny
000285r 2  B9 rr rr             lda     MATHTBL+28+1,y
000288r 2  10 FA                bpl     L24DB
00028Ar 2  B9 rr rr             lda     TOKEN_NAME_TABLE,y
00028Dr 2  D0 B4                bne     L2498
00028Fr 2  BD 00 00             lda     INPUTBUFFERX,x
000292r 2  10 BE                bpl     L24AA
000294r 2               ; ---END OF LINE------------------
000294r 2               L24EA:
000294r 2  99 0F 00             sta     INPUTBUFFER-3,y
000297r 2               .ifdef CONFIG_NO_INPUTBUFFER_ZP
000297r 2                       dec     TXTPTR+1
000297r 2               .endif
000297r 2  A9 11                lda     #<INPUTBUFFER-1
000299r 2  85 D1                sta     TXTPTR
00029Br 2  60                   rts
00029Cr 2               
00029Cr 2               ; ----------------------------------------------------------------------------
00029Cr 2               ; SEARCH FOR LINE
00029Cr 2               ;
00029Cr 2               ; (LINNUM) = LINE # TO FIND
00029Cr 2               ; IF NOT FOUND:  CARRY = 0
00029Cr 2               ;	LOWTR POINTS AT NEXT LINE
00029Cr 2               ; IF FOUND:      CARRY = 1
00029Cr 2               ;	LOWTR POINTS AT LINE
00029Cr 2               ; ----------------------------------------------------------------------------
00029Cr 2               FNDLIN:
00029Cr 2               .ifdef KBD
00029Cr 2                       jsr     CHRGET
00029Cr 2                       jmp     LE444
00029Cr 2               LE440:
00029Cr 2                       php
00029Cr 2                       jsr     LINGET
00029Cr 2               LE444:
00029Cr 2                       jsr     LF457
00029Cr 2                       ldx     #$FF
00029Cr 2                       plp
00029Cr 2                       beq     LE464
00029Cr 2                       jsr     CHRGOT
00029Cr 2                       beq     L2520
00029Cr 2                       cmp     #$A5
00029Cr 2                       bne     L2520
00029Cr 2                       jsr     CHRGET
00029Cr 2                       beq     LE464
00029Cr 2                       bcs     LE461
00029Cr 2                       jsr     LINGET
00029Cr 2                       beq     L2520
00029Cr 2               LE461:
00029Cr 2                       jmp     SYNERR
00029Cr 2               LE464:
00029Cr 2                       stx     LINNUM
00029Cr 2                       stx     LINNUM+1
00029Cr 2               .else
00029Cr 2  A5 82                lda     TXTTAB
00029Er 2  A6 83                ldx     TXTTAB+1
0002A0r 2               FL1:
0002A0r 2  A0 01                ldy     #$01
0002A2r 2  85 B6                sta     LOWTR
0002A4r 2  86 B7                stx     LOWTR+1
0002A6r 2  B1 B6                lda     (LOWTR),y
0002A8r 2  F0 1F                beq     L251F
0002AAr 2  C8                   iny
0002ABr 2  C8                   iny
0002ACr 2  A5 11                lda     LINNUM+1
0002AEr 2  D1 B6                cmp     (LOWTR),y
0002B0r 2  90 18                bcc     L2520
0002B2r 2  F0 03                beq     L250D
0002B4r 2  88                   dey
0002B5r 2  D0 09                bne     L2516
0002B7r 2               L250D:
0002B7r 2  A5 10                lda     LINNUM
0002B9r 2  88                   dey
0002BAr 2  D1 B6                cmp     (LOWTR),y
0002BCr 2  90 0C                bcc     L2520
0002BEr 2  F0 0A                beq     L2520
0002C0r 2               L2516:
0002C0r 2  88                   dey
0002C1r 2  B1 B6                lda     (LOWTR),y
0002C3r 2  AA                   tax
0002C4r 2  88                   dey
0002C5r 2  B1 B6                lda     (LOWTR),y
0002C7r 2  B0 D7                bcs     FL1
0002C9r 2               L251F:
0002C9r 2  18                   clc
0002CAr 2               .endif
0002CAr 2               L2520:
0002CAr 2  60                   rts
0002CBr 2               
0002CBr 2               ; ----------------------------------------------------------------------------
0002CBr 2               ; "NEW" STATEMENT
0002CBr 2               ; ----------------------------------------------------------------------------
0002CBr 2               NEW:
0002CBr 2  D0 FD                bne     L2520
0002CDr 2               SCRTCH:
0002CDr 2  A9 00                lda     #$00
0002CFr 2  A8                   tay
0002D0r 2  91 82                sta     (TXTTAB),y
0002D2r 2  C8                   iny
0002D3r 2  91 82                sta     (TXTTAB),y
0002D5r 2  A5 82                lda     TXTTAB
0002D7r 2               .ifdef CONFIG_2
0002D7r 2  18           		clc
0002D8r 2               .endif
0002D8r 2  69 02                adc     #$02
0002DAr 2  85 84                sta     VARTAB
0002DCr 2  A5 83                lda     TXTTAB+1
0002DEr 2  69 00                adc     #$00
0002E0r 2  85 85                sta     VARTAB+1
0002E2r 2               ; ----------------------------------------------------------------------------
0002E2r 2               SETPTRS:
0002E2r 2  20 rr rr             jsr     STXTPT
0002E5r 2               .ifdef CONFIG_11A
0002E5r 2  A9 00                lda     #$00
0002E7r 2               
0002E7r 2               ; ----------------------------------------------------------------------------
0002E7r 2               ; "CLEAR" STATEMENT
0002E7r 2               ; ----------------------------------------------------------------------------
0002E7r 2               CLEAR:
0002E7r 2  D0 2A                bne     L256A
0002E9r 2               .endif
0002E9r 2               CLEARC:
0002E9r 2               .ifdef KBD
0002E9r 2                       lda     #<CONST_MEMSIZ
0002E9r 2                       ldy     #>CONST_MEMSIZ
0002E9r 2               .else
0002E9r 2  A5 8E                lda     MEMSIZ
0002EBr 2  A4 8F                ldy     MEMSIZ+1
0002EDr 2               .endif
0002EDr 2  85 8A                sta     FRETOP
0002EFr 2  84 8B                sty     FRETOP+1
0002F1r 2               .ifdef CONFIG_CBM_ALL
0002F1r 2                       jsr     CLALL
0002F1r 2               .endif
0002F1r 2  A5 84                lda     VARTAB
0002F3r 2  A4 85                ldy     VARTAB+1
0002F5r 2  85 86                sta     ARYTAB
0002F7r 2  84 87                sty     ARYTAB+1
0002F9r 2  85 88                sta     STREND
0002FBr 2  84 89                sty     STREND+1
0002FDr 2  20 rr rr             jsr     RESTORE
000300r 2               ; ----------------------------------------------------------------------------
000300r 2               STKINI:
000300r 2  A2 70                ldx     #TEMPST
000302r 2  86 6D                stx     TEMPPT
000304r 2  68                   pla
000305r 2               .ifdef CONFIG_2
000305r 2  A8           		tay
000306r 2               .else
000306r 2                       sta     STACK+STACK_TOP+1
000306r 2               .endif
000306r 2  68                   pla
000307r 2               .ifndef CONFIG_2
000307r 2                       sta     STACK+STACK_TOP+2
000307r 2               .endif
000307r 2  A2 FA                ldx     #STACK_TOP
000309r 2  9A                   txs
00030Ar 2               .ifdef CONFIG_2
00030Ar 2  48                   pha
00030Br 2  98                   tya
00030Cr 2  48                   pha
00030Dr 2               .endif
00030Dr 2  A9 00                lda     #$00
00030Fr 2  85 95                sta     OLDTEXT+1
000311r 2  85 69                sta     SUBFLG
000313r 2               L256A:
000313r 2  60                   rts
000314r 2               
000314r 2               ; ----------------------------------------------------------------------------
000314r 2               ; SET TXTPTR TO BEGINNING OF PROGRAM
000314r 2               ; ----------------------------------------------------------------------------
000314r 2               STXTPT:
000314r 2  18                   clc
000315r 2  A5 82                lda     TXTTAB
000317r 2  69 FF                adc     #$FF
000319r 2  85 D1                sta     TXTPTR
00031Br 2  A5 83                lda     TXTTAB+1
00031Dr 2  69 FF                adc     #$FF
00031Fr 2  85 D2                sta     TXTPTR+1
000321r 2  60                   rts
000322r 2               
000322r 2               ; ----------------------------------------------------------------------------
000322r 2               .ifdef KBD
000322r 2               LE4C0:
000322r 2                       ldy     #<LE444
000322r 2                       ldx     #>LE444
000322r 2               LE4C4:
000322r 2                       jsr     LFFD6
000322r 2                       jsr     LFFED
000322r 2                       lda     $0504
000322r 2                       clc
000322r 2                       adc     #$08
000322r 2                       sta     $0504
000322r 2                       rts
000322r 2               
000322r 2               CMPJMPADRS:
000322r 2                       lda     1,x
000322r 2                       cmp     JMPADRS+2
000322r 2                       bne     LE4DE
000322r 2                       lda     0,x
000322r 2                       cmp     JMPADRS+1
000322r 2               LE4DE:
000322r 2                       rts
000322r 2               .endif
000322r 2               
000322r 2               ; ----------------------------------------------------------------------------
000322r 2               ; "LIST" STATEMENT
000322r 2               ; ----------------------------------------------------------------------------
000322r 2               LIST:
000322r 2               .ifdef KBD
000322r 2                       jsr     LE440
000322r 2                       bne     LE4DE
000322r 2                       pla
000322r 2                       pla
000322r 2               L25A6:
000322r 2                       jsr     CRDO
000322r 2               .else
000322r 2                   .ifdef AIM65
000322r 2                       pha
000322r 2                       lda     #$00
000322r 2               LB4BF:
000322r 2                       sta     INPUTFLG
000322r 2                       pla
000322r 2                   .endif
000322r 2                 .ifdef MICROTAN
000322r 2                       php
000322r 2                       jmp     LE21C ; patch
000322r 2               LC57E:
000322r 2                  .elseif .def(AIM65) || .def(SYM1)
000322r 2                       php
000322r 2                       jsr     LINGET
000322r 2               LC57E:
000322r 2                 .else
000322r 2  90 06                bcc     L2581
000324r 2  F0 04                beq     L2581
000326r 2  C9 A6                cmp     #TOKEN_MINUS
000328r 2  D0 E9                bne     L256A
00032Ar 2               L2581:
00032Ar 2  20 rr rr             jsr     LINGET
00032Dr 2                 .endif
00032Dr 2  20 rr rr             jsr     FNDLIN
000330r 2                 .if .def(MICROTAN) || .def(AIM65) || .def(SYM1)
000330r 2                       plp
000330r 2                       beq     L2598
000330r 2                 .endif
000330r 2  20 D0 00             jsr     CHRGOT
000333r 2                 .if .def(MICROTAN) || .def(AIM65) || .def(SYM1)
000333r 2                       beq     L25A6
000333r 2                 .else
000333r 2  F0 0C                beq     L2598
000335r 2                 .endif
000335r 2  C9 A6                cmp     #TOKEN_MINUS
000337r 2  D0 91                bne     L2520
000339r 2  20 CA 00             jsr     CHRGET
00033Cr 2                 .if .def(MICROTAN) || .def(AIM65) || .def(SYM1)
00033Cr 2                       beq     L2598
00033Cr 2                       jsr     LINGET
00033Cr 2                       beq     L25A6
00033Cr 2                       rts
00033Cr 2                 .else
00033Cr 2  20 rr rr             jsr     LINGET
00033Fr 2  D0 89                bne     L2520
000341r 2                 .endif
000341r 2               L2598:
000341r 2                 .if !(.def(MICROTAN) || .def(AIM65) || .def(SYM1))
000341r 2  68                   pla
000342r 2  68                   pla
000343r 2  A5 10                lda     LINNUM
000345r 2  05 11                ora     LINNUM+1
000347r 2  D0 06                bne     L25A6
000349r 2                 .endif
000349r 2  A9 FF                lda     #$FF
00034Br 2  85 10                sta     LINNUM
00034Dr 2  85 11                sta     LINNUM+1
00034Fr 2               L25A6:
00034Fr 2                 .if .def(MICROTAN) || .def(AIM65) || .def(SYM1)
00034Fr 2                       pla
00034Fr 2                       pla
00034Fr 2                 .endif
00034Fr 2               L25A6X:
00034Fr 2               .endif
00034Fr 2  A0 01                ldy     #$01
000351r 2               .ifdef CONFIG_DATAFLG
000351r 2                       sty     DATAFLG
000351r 2               .endif
000351r 2  B1 B6                lda     (LOWTRX),y
000353r 2  F0 39                beq     L25E5
000355r 2               .ifdef MICROTAN
000355r 2                       jmp     LE21F
000355r 2               LC5A9:
000355r 2               .else
000355r 2  20 rr rr             jsr     ISCNTC
000358r 2               .endif
000358r 2               .ifndef KBD
000358r 2  20 rr rr             jsr     CRDO
00035Br 2               .endif
00035Br 2  C8                   iny
00035Cr 2  B1 B6                lda     (LOWTRX),y
00035Er 2  AA                   tax
00035Fr 2  C8                   iny
000360r 2  B1 B6                lda     (LOWTRX),y
000362r 2  C5 11                cmp     LINNUM+1
000364r 2  D0 04                bne     L25C1
000366r 2  E4 10                cpx     LINNUM
000368r 2  F0 02                beq     L25C3
00036Ar 2               L25C1:
00036Ar 2  B0 22                bcs     L25E5
00036Cr 2               ; ---LIST ONE LINE----------------
00036Cr 2               L25C3:
00036Cr 2  84 A0                sty     FORPNT
00036Er 2  20 rr rr             jsr     LINPRT
000371r 2  A9 20                lda     #$20
000373r 2               L25CA:
000373r 2  A4 A0                ldy     FORPNT
000375r 2  29 7F                and     #$7F
000377r 2               L25CE:
000377r 2  20 rr rr             jsr     OUTDO
00037Ar 2               .ifdef CONFIG_DATAFLG
00037Ar 2                       cmp     #$22
00037Ar 2                       bne     LA519
00037Ar 2                       lda     DATAFLG
00037Ar 2                       eor     #$FF
00037Ar 2                       sta     DATAFLG
00037Ar 2               LA519:
00037Ar 2               .endif
00037Ar 2  C8                   iny
00037Br 2               .ifdef CONFIG_11
00037Br 2  F0 11                beq     L25E5
00037Dr 2               .endif
00037Dr 2  B1 B6                lda     (LOWTRX),y
00037Fr 2  D0 10                bne     L25E8
000381r 2  A8                   tay
000382r 2  B1 B6                lda     (LOWTRX),y
000384r 2  AA                   tax
000385r 2  C8                   iny
000386r 2  B1 B6                lda     (LOWTRX),y
000388r 2  86 B6                stx     LOWTRX
00038Ar 2  85 B7                sta     LOWTRX+1
00038Cr 2               .if .def(MICROTAN) || .def(AIM65) || .def(SYM1)
00038Cr 2                       bne     L25A6X
00038Cr 2               .else
00038Cr 2  D0 C1                bne     L25A6
00038Er 2               .endif
00038Er 2               L25E5:
00038Er 2               .ifdef AIM65
00038Er 2                       lda     INPUTFLG
00038Er 2                       beq     L25E5a
00038Er 2                       jsr     CRDO
00038Er 2                       jsr     CRDO
00038Er 2                       lda     #$1a
00038Er 2                       jsr     OUTDO
00038Er 2                       jsr     $e50a
00038Er 2               L25E5a:
00038Er 2               .endif
00038Er 2  4C rr rr             jmp     RESTART
000391r 2               L25E8:
000391r 2  10 E4                bpl     L25CE
000393r 2               .ifdef CONFIG_DATAFLG
000393r 2                       cmp     #$FF
000393r 2                       beq     L25CE
000393r 2                       bit     DATAFLG
000393r 2                       bmi     L25CE
000393r 2               .endif
000393r 2  38                   sec
000394r 2  E9 7F                sbc     #$7F
000396r 2  AA                   tax
000397r 2  84 A0                sty     FORPNT
000399r 2  A0 FF                ldy     #$FF
00039Br 2               L25F2:
00039Br 2  CA                   dex
00039Cr 2  F0 08                beq     L25FD
00039Er 2               L25F5:
00039Er 2  C8                   iny
00039Fr 2  B9 rr rr             lda     TOKEN_NAME_TABLE,y
0003A2r 2  10 FA                bpl     L25F5
0003A4r 2  30 F5                bmi     L25F2
0003A6r 2               L25FD:
0003A6r 2  C8                   iny
0003A7r 2  B9 rr rr             lda     TOKEN_NAME_TABLE,y
0003AAr 2  30 C7                bmi     L25CA
0003ACr 2  20 rr rr             jsr     OUTDO
0003AFr 2  D0 F5                bne     L25FD	; always
0003B1r 2               
0003B1r 2               
0003B1r 1               .include "flow1.s"
0003B1r 2               .segment "CODE"
0003B1r 2               
0003B1r 2               ; ----------------------------------------------------------------------------
0003B1r 2               ; "FOR" STATEMENT
0003B1r 2               ;
0003B1r 2               ; FOR PUSHES 18 BYTES ON THE STACK:
0003B1r 2               ; 2 -- TXTPTR
0003B1r 2               ; 2 -- LINE NUMBER
0003B1r 2               ; 5 -- INITIAL (CURRENT)  FOR VARIABLE VALUE
0003B1r 2               ; 1 -- STEP SIGN
0003B1r 2               ; 5 -- STEP VALUE
0003B1r 2               ; 2 -- ADDRESS OF FOR VARIABLE IN VARTAB
0003B1r 2               ; 1 -- FOR TOKEN ($81)
0003B1r 2               ; ----------------------------------------------------------------------------
0003B1r 2               FOR:
0003B1r 2  A9 80                lda     #$80
0003B3r 2  85 69                sta     SUBFLG
0003B5r 2  20 rr rr             jsr     LET
0003B8r 2  20 rr rr             jsr     GTFORPNT
0003BBr 2  D0 05                bne     L2619
0003BDr 2  8A                   txa
0003BEr 2  69 0F                adc     #FOR_STACK1
0003C0r 2  AA                   tax
0003C1r 2  9A                   txs
0003C2r 2               L2619:
0003C2r 2  68                   pla
0003C3r 2  68                   pla
0003C4r 2  A9 09                lda     #FOR_STACK2
0003C6r 2  20 rr rr             jsr     CHKMEM
0003C9r 2  20 rr rr             jsr     DATAN
0003CCr 2  18                   clc
0003CDr 2  98                   tya
0003CEr 2  65 D1                adc     TXTPTR
0003D0r 2  48                   pha
0003D1r 2  A5 D2                lda     TXTPTR+1
0003D3r 2  69 00                adc     #$00
0003D5r 2  48                   pha
0003D6r 2  A5 91                lda     CURLIN+1
0003D8r 2  48                   pha
0003D9r 2  A5 90                lda     CURLIN
0003DBr 2  48                   pha
0003DCr 2  A9 9F                lda     #TOKEN_TO
0003DEr 2  20 rr rr             jsr     SYNCHR
0003E1r 2  20 rr rr             jsr     CHKNUM
0003E4r 2  20 rr rr             jsr     FRMNUM
0003E7r 2  A5 BD                lda     FACSIGN
0003E9r 2  09 7F                ora     #$7F
0003EBr 2  25 B9                and     FAC+1
0003EDr 2  85 B9                sta     FAC+1
0003EFr 2  A9 rr                lda     #<STEP
0003F1r 2  A0 rr                ldy     #>STEP
0003F3r 2  85 79                sta     INDEX
0003F5r 2  84 7A                sty     INDEX+1
0003F7r 2  4C rr rr             jmp     FRM_STACK3
0003FAr 2               
0003FAr 2               ; ----------------------------------------------------------------------------
0003FAr 2               ; "STEP" PHRASE OF "FOR" STATEMENT
0003FAr 2               ; ----------------------------------------------------------------------------
0003FAr 2               STEP:
0003FAr 2  A9 rr                lda     #<CON_ONE
0003FCr 2  A0 rr                ldy     #>CON_ONE
0003FEr 2  20 rr rr             jsr     LOAD_FAC_FROM_YA
000401r 2  20 D0 00             jsr     CHRGOT
000404r 2  C9 A4                cmp     #TOKEN_STEP
000406r 2  D0 06                bne     L2665
000408r 2  20 CA 00             jsr     CHRGET
00040Br 2  20 rr rr             jsr     FRMNUM
00040Er 2               L2665:
00040Er 2  20 rr rr             jsr     SIGN
000411r 2  20 rr rr             jsr     FRM_STACK2
000414r 2  A5 A1                lda     FORPNT+1
000416r 2  48                   pha
000417r 2  A5 A0                lda     FORPNT
000419r 2  48                   pha
00041Ar 2  A9 81                lda     #$81
00041Cr 2  48                   pha
00041Dr 2               
00041Dr 2               ; ----------------------------------------------------------------------------
00041Dr 2               ; PERFORM NEXT STATEMENT
00041Dr 2               ; ----------------------------------------------------------------------------
00041Dr 2               NEWSTT:
00041Dr 2  20 rr rr             jsr     ISCNTC
000420r 2  A5 D1                lda     TXTPTR
000422r 2  A4 D2                ldy     TXTPTR+1
000424r 2               .if .def(CONFIG_NO_INPUTBUFFER_ZP) && .def(CONFIG_2)
000424r 2                       cpy     #>INPUTBUFFER
000424r 2                 .ifdef CBM2
000424r 2                       nop
000424r 2                 .endif
000424r 2                       beq     LC6D4
000424r 2               .else
000424r 2               ; BUG on AppleSoft I,
000424r 2               ; fixed differently on AppleSoft II (ldx/inx)
000424r 2  F0 06                beq     L2683
000426r 2               .endif
000426r 2  85 94                sta     OLDTEXT
000428r 2  84 95                sty     OLDTEXT+1
00042Ar 2               LC6D4:
00042Ar 2  A0 00                ldy     #$00
00042Cr 2               L2683:
00042Cr 2  B1 D1                lda     (TXTPTR),y
00042Er 2               .ifndef CONFIG_11
00042Er 2                       beq     LA5DC	; old: 1 cycle more on generic case
00042Er 2                       cmp     #$3A
00042Er 2                       beq     NEWSTT2
00042Er 2               SYNERR1:
00042Er 2                       jmp     SYNERR
00042Er 2               LA5DC:
00042Er 2               .else
00042Er 2  D0 40                bne     COLON; new: 1 cycle more on ":" case
000430r 2               .endif
000430r 2  A0 02                ldy     #$02
000432r 2  B1 D1                lda     (TXTPTR),y
000434r 2  18                   clc
000435r 2               .ifdef CONFIG_2
000435r 2  D0 03 4C rr          jeq     L2701
000439r 2  rr           
00043Ar 2               .else
00043Ar 2                       beq     L2701
00043Ar 2               .endif
00043Ar 2  C8                   iny
00043Br 2  B1 D1                lda     (TXTPTR),y
00043Dr 2  85 90                sta     CURLIN
00043Fr 2  C8                   iny
000440r 2  B1 D1                lda     (TXTPTR),y
000442r 2  85 91                sta     CURLIN+1
000444r 2  98                   tya
000445r 2  65 D1                adc     TXTPTR
000447r 2  85 D1                sta     TXTPTR
000449r 2  90 02                bcc     NEWSTT2
00044Br 2  E6 D2                inc     TXTPTR+1
00044Dr 2               NEWSTT2:
00044Dr 2  20 CA 00             jsr     CHRGET
000450r 2  20 rr rr             jsr     EXECUTE_STATEMENT
000453r 2  4C rr rr             jmp     NEWSTT
000456r 2               
000456r 2               ; ----------------------------------------------------------------------------
000456r 2               ; EXECUTE A STATEMENT
000456r 2               ;
000456r 2               ; (A) IS FIRST CHAR OF STATEMENT
000456r 2               ; CARRY IS SET
000456r 2               ; ----------------------------------------------------------------------------
000456r 2               EXECUTE_STATEMENT:
000456r 2               .ifndef CONFIG_11A
000456r 2                       beq     RET1
000456r 2               .else
000456r 2  F0 3C                beq     RET2
000458r 2               .endif
000458r 2               .ifndef CONFIG_11
000458r 2                       sec
000458r 2               .endif
000458r 2               EXECUTE_STATEMENT1:
000458r 2  E9 80                sbc     #$80
00045Ar 2               .ifndef CONFIG_11
00045Ar 2                       jcc     LET	; old: 1 cycle more on instr.
00045Ar 2               .else
00045Ar 2  90 11                bcc     LET1; new: 1 cycle more on assignment
00045Cr 2               .endif
00045Cr 2  C9 1E                cmp     #NUM_TOKENS
00045Er 2               .ifdef CONFIG_2
00045Er 2  B0 17                bcs     LC721
000460r 2               .else
000460r 2                       bcs     SYNERR1
000460r 2               .endif
000460r 2  0A                   asl     a
000461r 2  A8                   tay
000462r 2  B9 rr rr             lda     TOKEN_ADDRESS_TABLE+1,y
000465r 2  48                   pha
000466r 2  B9 rr rr             lda     TOKEN_ADDRESS_TABLE,y
000469r 2  48                   pha
00046Ar 2  4C CA 00             jmp     CHRGET
00046Dr 2               
00046Dr 2               .ifdef CONFIG_11
00046Dr 2               LET1:
00046Dr 2  4C rr rr             jmp     LET
000470r 2               
000470r 2               COLON:
000470r 2  C9 3A                cmp     #$3A
000472r 2  F0 D9                beq     NEWSTT2
000474r 2               SYNERR1:
000474r 2  4C rr rr             jmp     SYNERR
000477r 2               .endif
000477r 2               
000477r 2               .ifdef CONFIG_2; GO TO
000477r 2               LC721:
000477r 2  C9 46                cmp     #TOKEN_GO-$80
000479r 2  D0 F9                bne     SYNERR1
00047Br 2  20 CA 00             jsr     CHRGET
00047Er 2  A9 9F                lda     #TOKEN_TO
000480r 2  20 rr rr             jsr     SYNCHR
000483r 2  4C rr rr             jmp     GOTO
000486r 2               .endif
000486r 2               
000486r 2               ; ----------------------------------------------------------------------------
000486r 2               ; "RESTORE" STATEMENT
000486r 2               ; ----------------------------------------------------------------------------
000486r 2               RESTORE:
000486r 2  38                   sec
000487r 2  A5 82                lda     TXTTAB
000489r 2  E9 01                sbc     #$01
00048Br 2  A4 83                ldy     TXTTAB+1
00048Dr 2  B0 01                bcs     SETDA
00048Fr 2  88                   dey
000490r 2               SETDA:
000490r 2  85 98                sta     DATPTR
000492r 2  84 99                sty     DATPTR+1
000494r 2               RET2:
000494r 2  60                   rts
000495r 2               
000495r 2               .include "iscntc.s"
000495r 3               .segment "CODE"
000495r 3               ; ----------------------------------------------------------------------------
000495r 3               ; SEE IF CONTROL-C TYPED
000495r 3               ; ----------------------------------------------------------------------------
000495r 3               .ifndef CONFIG_CBM_ALL
000495r 3               .include "cbm_iscntc.s"
000495r 4               ; nothing - ISCNTC is a KERNAL function
000495r 4               
000495r 3               .endif
000495r 3               .ifdef KBD
000495r 3               .include "kbd_iscntc.s"
000495r 3               .endif
000495r 3               .ifdef OSI
000495r 3               .include "osi_iscntc.s"
000495r 3               .endif
000495r 3               .ifdef APPLE
000495r 3               .include "apple_iscntc.s"
000495r 3               .endif
000495r 3               .ifdef KIM
000495r 3               .include "kim_iscntc.s"
000495r 3               .endif
000495r 3               .ifdef MICROTAN
000495r 3               .include "microtan_iscntc.s"
000495r 3               .endif
000495r 3               .ifdef AIM65
000495r 3               .include "aim65_iscntc.s"
000495r 3               .endif
000495r 3               .ifdef SYM1
000495r 3               .include "sym1_iscntc.s"
000495r 3               .endif
000495r 3               .ifdef EATER
000495r 3               .include "eater_iscntc.s"
000495r 4               ISCNTC:
000495r 4  20 rr rr             jsr MONRDKEY
000498r 4  90 07                bcc not_cntc
00049Ar 4  C9 03                cmp #3
00049Cr 4  D0 03                bne not_cntc
00049Er 4  4C rr rr             jmp is_cntc
0004A1r 4               
0004A1r 4               not_cntc:
0004A1r 4  60                   rts
0004A2r 4               
0004A2r 4               is_cntc:
0004A2r 4                       ; Fall through
0004A2r 4               
0004A2r 3               .endif
0004A2r 3               ;!!! runs into "STOP"
0004A2r 3               
0004A2r 2               ;!!! runs into "STOP"
0004A2r 2               ; ----------------------------------------------------------------------------
0004A2r 2               ; "STOP" STATEMENT
0004A2r 2               ; ----------------------------------------------------------------------------
0004A2r 2               STOP:
0004A2r 2  B0 01                bcs     END2
0004A4r 2               
0004A4r 2               ; ----------------------------------------------------------------------------
0004A4r 2               ; "END" STATEMENT
0004A4r 2               ; ----------------------------------------------------------------------------
0004A4r 2               END:
0004A4r 2  18                   clc
0004A5r 2               END2:
0004A5r 2  D0 3D                bne     RET1
0004A7r 2  A5 D1                lda     TXTPTR
0004A9r 2  A4 D2                ldy     TXTPTR+1
0004ABr 2               .if .def(CONFIG_NO_INPUTBUFFER_ZP) && .def(CONFIG_2)
0004ABr 2               ; BUG on AppleSoft I
0004ABr 2               ; fix exists on AppleSoft II
0004ABr 2               ; TXTPTR+1 will always be > 0
0004ABr 2                       ldx     CURLIN+1
0004ABr 2                       inx
0004ABr 2               .endif
0004ABr 2  F0 0C                beq     END4
0004ADr 2  85 94                sta     OLDTEXT
0004AFr 2  84 95                sty     OLDTEXT+1
0004B1r 2               CONTROL_C_TYPED:
0004B1r 2  A5 90                lda     CURLIN
0004B3r 2  A4 91                ldy     CURLIN+1
0004B5r 2  85 92                sta     OLDLIN
0004B7r 2  84 93                sty     OLDLIN+1
0004B9r 2               END4:
0004B9r 2  68                   pla
0004BAr 2  68                   pla
0004BBr 2               L2701:
0004BBr 2  A9 rr                lda     #<QT_BREAK
0004BDr 2  A0 rr                ldy     #>QT_BREAK
0004BFr 2               .ifndef KBD
0004BFr 2  A2 00                ldx     #$00
0004C1r 2  86 6C                stx     Z14
0004C3r 2               .endif
0004C3r 2  90 03                bcc     L270E
0004C5r 2  4C rr rr             jmp     PRINT_ERROR_LINNUM
0004C8r 2               L270E:
0004C8r 2  4C rr rr             jmp     RESTART
0004CBr 2               .ifdef KBD
0004CBr 2               LE664:
0004CBr 2                       tay
0004CBr 2                       jmp     SNGFLT
0004CBr 2               .endif
0004CBr 2               
0004CBr 2               ; ----------------------------------------------------------------------------
0004CBr 2               ; "CONT" COMMAND
0004CBr 2               ; ----------------------------------------------------------------------------
0004CBr 2               CONT:
0004CBr 2  D0 17                bne     RET1
0004CDr 2  A2 D2                ldx     #ERR_CANTCONT
0004CFr 2  A4 95                ldy     OLDTEXT+1
0004D1r 2  D0 03                bne     L271C
0004D3r 2  4C rr rr             jmp     ERROR
0004D6r 2               L271C:
0004D6r 2  A5 94                lda     OLDTEXT
0004D8r 2  85 D1                sta     TXTPTR
0004DAr 2  84 D2                sty     TXTPTR+1
0004DCr 2  A5 92                lda     OLDLIN
0004DEr 2  A4 93                ldy     OLDLIN+1
0004E0r 2  85 90                sta     CURLIN
0004E2r 2  84 91                sty     CURLIN+1
0004E4r 2               RET1:
0004E4r 2  60                   rts
0004E5r 2               
0004E5r 2               .ifdef KBD
0004E5r 2               PRT:
0004E5r 2                       jsr     GETBYT
0004E5r 2                       txa
0004E5r 2               ; not ROR bug safe
0004E5r 2                       ror     a
0004E5r 2                       ror     a
0004E5r 2                       ror     a
0004E5r 2                       sta     $8F
0004E5r 2                       rts
0004E5r 2               
0004E5r 2               LE68C:
0004E5r 2                       ldy     #$12
0004E5r 2               LE68E:
0004E5r 2                       lda     LEA30,y
0004E5r 2                       sta     $03A2,y
0004E5r 2                       dey
0004E5r 2                       bpl     LE68E
0004E5r 2                       rts
0004E5r 2               .endif
0004E5r 2               
0004E5r 2               .ifndef AIM65
0004E5r 2               .if .def(CONFIG_NULL) || .def(CONFIG_PRINTNULLS)
0004E5r 2               ; CBM1 has the keyword removed,
0004E5r 2               ; but the code is still here
0004E5r 2               NULL:
0004E5r 2                       jsr     GETBYT
0004E5r 2                       bne     RET1
0004E5r 2                       inx
0004E5r 2                       cpx     #NULL_MAX
0004E5r 2                       bcs     L2739
0004E5r 2                       dex
0004E5r 2                       stx     Z15
0004E5r 2               L2738:
0004E5r 2                       rts
0004E5r 2               L2739:
0004E5r 2                       jmp     IQERR
0004E5r 2               .endif
0004E5r 2               .ifndef CONFIG_11A
0004E5r 2               CLEAR:
0004E5r 2                       bne     RET1
0004E5r 2                       jmp     CLEARC
0004E5r 2               .endif
0004E5r 2               .endif
0004E5r 2               
0004E5r 1               .include "loadsave.s"
0004E5r 2               .segment "CODE"
0004E5r 2               
0004E5r 2               .ifdef APPLE
0004E5r 2               .include "apple_loadsave.s"
0004E5r 2               .endif
0004E5r 2               .ifdef KIM
0004E5r 2               .include "kim_loadsave.s"
0004E5r 2               .endif
0004E5r 2               .ifdef MICROTAN
0004E5r 2               .include "microtan_loadsave.s"
0004E5r 2               .endif
0004E5r 2               .ifdef AIM65
0004E5r 2               .include "aim65_loadsave.s"
0004E5r 2               .endif
0004E5r 2               .ifdef SYM1
0004E5r 2               .include "sym1_loadsave.s"
0004E5r 2               .endif
0004E5r 2               
0004E5r 1               .include "flow2.s"
0004E5r 2               .segment "CODE"
0004E5r 2               ; ----------------------------------------------------------------------------
0004E5r 2               ; "RUN" COMMAND
0004E5r 2               ; ----------------------------------------------------------------------------
0004E5r 2               RUN:
0004E5r 2  D0 03                bne     L27CF
0004E7r 2  4C rr rr             jmp     SETPTRS
0004EAr 2               L27CF:
0004EAr 2  20 rr rr             jsr     CLEARC
0004EDr 2  4C rr rr             jmp     L27E9
0004F0r 2               
0004F0r 2               ; ----------------------------------------------------------------------------
0004F0r 2               ; "GOSUB" STATEMENT
0004F0r 2               ;
0004F0r 2               ; LEAVES 7 BYTES ON STACK:
0004F0r 2               ; 2 -- RETURN ADDRESS (NEWSTT)
0004F0r 2               ; 2 -- TXTPTR
0004F0r 2               ; 2 -- LINE #
0004F0r 2               ; 1 -- GOSUB TOKEN
0004F0r 2               ; ----------------------------------------------------------------------------
0004F0r 2               GOSUB:
0004F0r 2  A9 03                lda     #$03
0004F2r 2  20 rr rr             jsr     CHKMEM
0004F5r 2  A5 D2                lda     TXTPTR+1
0004F7r 2  48                   pha
0004F8r 2  A5 D1                lda     TXTPTR
0004FAr 2  48                   pha
0004FBr 2  A5 91                lda     CURLIN+1
0004FDr 2  48                   pha
0004FEr 2  A5 90                lda     CURLIN
000500r 2  48                   pha
000501r 2  A9 8C                lda     #TOKEN_GOSUB
000503r 2  48                   pha
000504r 2               L27E9:
000504r 2  20 D0 00             jsr     CHRGOT
000507r 2  20 rr rr             jsr     GOTO
00050Ar 2  4C rr rr             jmp     NEWSTT
00050Dr 2               
00050Dr 2               ; ----------------------------------------------------------------------------
00050Dr 2               ; "GOTO" STATEMENT
00050Dr 2               ; ALSO USED BY "RUN" AND "GOSUB"
00050Dr 2               ; ----------------------------------------------------------------------------
00050Dr 2               GOTO:
00050Dr 2  20 rr rr             jsr     LINGET
000510r 2  20 rr rr             jsr     REMN
000513r 2  A5 91                lda     CURLIN+1
000515r 2  C5 11                cmp     LINNUM+1
000517r 2  B0 0B                bcs     L2809
000519r 2  98                   tya
00051Ar 2  38                   sec
00051Br 2  65 D1                adc     TXTPTR
00051Dr 2  A6 D2                ldx     TXTPTR+1
00051Fr 2  90 07                bcc     L280D
000521r 2  E8                   inx
000522r 2  B0 04                bcs     L280D
000524r 2               L2809:
000524r 2  A5 82                lda     TXTTAB
000526r 2  A6 83                ldx     TXTTAB+1
000528r 2               L280D:
000528r 2               .ifdef KBD
000528r 2                       jsr     LF457
000528r 2                       bne     UNDERR
000528r 2               .else
000528r 2  20 rr rr             jsr     FL1
00052Br 2  90 1E                bcc     UNDERR
00052Dr 2               .endif
00052Dr 2  A5 B6                lda     LOWTRX
00052Fr 2  E9 01                sbc     #$01
000531r 2  85 D1                sta     TXTPTR
000533r 2  A5 B7                lda     LOWTRX+1
000535r 2  E9 00                sbc     #$00
000537r 2  85 D2                sta     TXTPTR+1
000539r 2               L281E:
000539r 2  60                   rts
00053Ar 2               
00053Ar 2               ; ----------------------------------------------------------------------------
00053Ar 2               ; "POP" AND "RETURN" STATEMENTS
00053Ar 2               ; ----------------------------------------------------------------------------
00053Ar 2               POP:
00053Ar 2  D0 FD                bne     L281E
00053Cr 2  A9 FF                lda     #$FF
00053Er 2               .ifdef CONFIG_2A
00053Er 2  85 A1                sta     FORPNT+1 ; bugfix, wrong in AppleSoft II
000540r 2               .else
000540r 2                       sta     FORPNT
000540r 2               .endif
000540r 2  20 rr rr             jsr     GTFORPNT
000543r 2  9A                   txs
000544r 2  C9 8C                cmp     #TOKEN_GOSUB
000546r 2  F0 0B                beq     RETURN
000548r 2  A2 16                ldx     #ERR_NOGOSUB
00054Ar 2  2C                   .byte   $2C
00054Br 2               UNDERR:
00054Br 2  A2 5A                ldx     #ERR_UNDEFSTAT
00054Dr 2  4C rr rr             jmp     ERROR
000550r 2               ; ----------------------------------------------------------------------------
000550r 2               SYNERR2:
000550r 2  4C rr rr             jmp     SYNERR
000553r 2               ; ----------------------------------------------------------------------------
000553r 2               RETURN:
000553r 2  68                   pla
000554r 2  68                   pla
000555r 2  85 90                sta     CURLIN
000557r 2  68                   pla
000558r 2  85 91                sta     CURLIN+1
00055Ar 2  68                   pla
00055Br 2  85 D1                sta     TXTPTR
00055Dr 2  68                   pla
00055Er 2  85 D2                sta     TXTPTR+1
000560r 2               
000560r 2               ; ----------------------------------------------------------------------------
000560r 2               ; "DATA" STATEMENT
000560r 2               ; EXECUTED BY SKIPPING TO NEXT COLON OR EOL
000560r 2               ; ----------------------------------------------------------------------------
000560r 2               DATA:
000560r 2  20 rr rr             jsr     DATAN
000563r 2               
000563r 2               ; ----------------------------------------------------------------------------
000563r 2               ; ADD (Y) TO TXTPTR
000563r 2               ; ----------------------------------------------------------------------------
000563r 2               ADDON:
000563r 2  98                   tya
000564r 2  18                   clc
000565r 2  65 D1                adc     TXTPTR
000567r 2  85 D1                sta     TXTPTR
000569r 2  90 02                bcc     L2852
00056Br 2  E6 D2                inc     TXTPTR+1
00056Dr 2               L2852:
00056Dr 2  60                   rts
00056Er 2               
00056Er 2               ; ----------------------------------------------------------------------------
00056Er 2               ; SCAN AHEAD TO NEXT ":" OR EOL
00056Er 2               ; ----------------------------------------------------------------------------
00056Er 2               DATAN:
00056Er 2  A2 3A                ldx     #$3A
000570r 2  2C                   .byte   $2C
000571r 2               REMN:
000571r 2  A2 00                ldx     #$00
000573r 2  86 62                stx     CHARAC
000575r 2  A0 00                ldy     #$00
000577r 2  84 63                sty     ENDCHR
000579r 2               L285E:
000579r 2  A5 63                lda     ENDCHR
00057Br 2  A6 62                ldx     CHARAC
00057Dr 2  85 62                sta     CHARAC
00057Fr 2  86 63                stx     ENDCHR
000581r 2               L2866:
000581r 2  B1 D1                lda     (TXTPTR),y
000583r 2  F0 E8                beq     L2852
000585r 2  C5 63                cmp     ENDCHR
000587r 2  F0 E4                beq     L2852
000589r 2  C8                   iny
00058Ar 2  C9 22                cmp     #$22
00058Cr 2               .ifndef CONFIG_11
00058Cr 2                       beq     L285E; old: swap & cont is faster
00058Cr 2                       bne     L2866
00058Cr 2               .else
00058Cr 2  D0 F3                bne     L2866; new: cont is faster
00058Er 2  F0 E9                beq     L285E
000590r 2               .endif
000590r 2               
000590r 2               ; ----------------------------------------------------------------------------
000590r 2               ; "IF" STATEMENT
000590r 2               ; ----------------------------------------------------------------------------
000590r 2               IF:
000590r 2  20 rr rr             jsr     FRMEVL
000593r 2  20 D0 00             jsr     CHRGOT
000596r 2  C9 88                cmp     #TOKEN_GOTO
000598r 2  F0 05                beq     L2884
00059Ar 2  A9 A2                lda     #TOKEN_THEN
00059Cr 2  20 rr rr             jsr     SYNCHR
00059Fr 2               L2884:
00059Fr 2  A5 B8                lda     FAC
0005A1r 2  D0 05                bne     L288D
0005A3r 2               
0005A3r 2               ; ----------------------------------------------------------------------------
0005A3r 2               ; "REM" STATEMENT, OR FALSE "IF" STATEMENT
0005A3r 2               ; ----------------------------------------------------------------------------
0005A3r 2               REM:
0005A3r 2  20 rr rr             jsr     REMN
0005A6r 2  F0 BB                beq     ADDON
0005A8r 2               L288D:
0005A8r 2  20 D0 00             jsr     CHRGOT
0005ABr 2  B0 03                bcs     L2895
0005ADr 2  4C rr rr             jmp     GOTO
0005B0r 2               L2895:
0005B0r 2  4C rr rr             jmp     EXECUTE_STATEMENT
0005B3r 2               
0005B3r 2               ; ----------------------------------------------------------------------------
0005B3r 2               ; "ON" STATEMENT
0005B3r 2               ;
0005B3r 2               ; ON <EXP> GOTO <LIST>
0005B3r 2               ; ON <EXP> GOSUB <LIST>
0005B3r 2               ; ----------------------------------------------------------------------------
0005B3r 2               ON:
0005B3r 2  20 rr rr             jsr     GETBYT
0005B6r 2  48                   pha
0005B7r 2  C9 8C                cmp     #TOKEN_GOSUB
0005B9r 2  F0 04                beq     L28A4
0005BBr 2               L28A0:
0005BBr 2  C9 88                cmp     #TOKEN_GOTO
0005BDr 2  D0 91                bne     SYNERR2
0005BFr 2               L28A4:
0005BFr 2  C6 BC                dec     FAC_LAST
0005C1r 2  D0 04                bne     L28AC
0005C3r 2  68                   pla
0005C4r 2  4C rr rr             jmp     EXECUTE_STATEMENT1
0005C7r 2               L28AC:
0005C7r 2  20 CA 00             jsr     CHRGET
0005CAr 2  20 rr rr             jsr     LINGET
0005CDr 2  C9 2C                cmp     #$2C
0005CFr 2  F0 EE                beq     L28A4
0005D1r 2  68                   pla
0005D2r 2               L28B7:
0005D2r 2  60                   rts
0005D3r 2               
0005D3r 1               .include "misc1.s"
0005D3r 2               .segment "CODE"
0005D3r 2               
0005D3r 2               ; ----------------------------------------------------------------------------
0005D3r 2               ; CONVERT LINE NUMBER
0005D3r 2               ; ----------------------------------------------------------------------------
0005D3r 2               LINGET:
0005D3r 2  A2 00                ldx     #$00
0005D5r 2  86 10                stx     LINNUM
0005D7r 2  86 11                stx     LINNUM+1
0005D9r 2               L28BE:
0005D9r 2  B0 F7                bcs     L28B7
0005DBr 2  E9 2F                sbc     #$2F
0005DDr 2  85 62                sta     CHARAC
0005DFr 2  A5 11                lda     LINNUM+1
0005E1r 2  85 79                sta     INDEX
0005E3r 2  C9 19                cmp     #$19
0005E5r 2  B0 D4                bcs     L28A0
0005E7r 2               ; <<<<<DANGEROUS CODE>>>>>
0005E7r 2               ; NOTE THAT IF (A) = $AB ON THE LINE ABOVE,
0005E7r 2               ; ON.1 WILL COMPARE = AND CAUSE A CATASTROPHIC
0005E7r 2               ; JUMP TO $22D9 (FOR GOTO), OR OTHER LOCATIONS
0005E7r 2               ; FOR OTHER CALLS TO LINGET.
0005E7r 2               ;
0005E7r 2               ; YOU CAN SEE THIS IS YOU FIRST PUT "BRK" IN $22D9,
0005E7r 2               ; THEN TYPE "GO TO 437761".
0005E7r 2               ;
0005E7r 2               ; ANY VALUE FROM 437760 THROUGH 440319 WILL CAUSE
0005E7r 2               ; THE PROBLEM.  ($AB00 - $ABFF)
0005E7r 2               ; <<<<<DANGEROUS CODE>>>>>
0005E7r 2  A5 10                lda     LINNUM
0005E9r 2  0A                   asl     a
0005EAr 2  26 79                rol     INDEX
0005ECr 2  0A                   asl     a
0005EDr 2  26 79                rol     INDEX
0005EFr 2  65 10                adc     LINNUM
0005F1r 2  85 10                sta     LINNUM
0005F3r 2  A5 79                lda     INDEX
0005F5r 2  65 11                adc     LINNUM+1
0005F7r 2  85 11                sta     LINNUM+1
0005F9r 2  06 10                asl     LINNUM
0005FBr 2  26 11                rol     LINNUM+1
0005FDr 2  A5 10                lda     LINNUM
0005FFr 2  65 62                adc     CHARAC
000601r 2  85 10                sta     LINNUM
000603r 2  90 02                bcc     L28EC
000605r 2  E6 11                inc     LINNUM+1
000607r 2               L28EC:
000607r 2  20 CA 00             jsr     CHRGET
00060Ar 2  4C rr rr             jmp     L28BE
00060Dr 2               
00060Dr 2               ; ----------------------------------------------------------------------------
00060Dr 2               ; "LET" STATEMENT
00060Dr 2               ;
00060Dr 2               ; LET <VAR> = <EXP>
00060Dr 2               ; <VAR> = <EXP>
00060Dr 2               ; ----------------------------------------------------------------------------
00060Dr 2               LET:
00060Dr 2  20 rr rr             jsr     PTRGET
000610r 2  85 A0                sta     FORPNT
000612r 2  84 A1                sty     FORPNT+1
000614r 2  A9 AD                lda     #TOKEN_EQUAL
000616r 2  20 rr rr             jsr     SYNCHR
000619r 2               .ifndef CONFIG_SMALL
000619r 2  A5 67                lda     VALTYP+1
00061Br 2  48                   pha
00061Cr 2               .endif
00061Cr 2  A5 66                lda     VALTYP
00061Er 2  48                   pha
00061Fr 2  20 rr rr             jsr     FRMEVL
000622r 2  68                   pla
000623r 2  2A                   rol     a
000624r 2  20 rr rr             jsr     CHKVAL
000627r 2  D0 18                bne     LETSTRING
000629r 2               .ifndef CONFIG_SMALL
000629r 2  68                   pla
00062Ar 2               LET2:
00062Ar 2  10 12                bpl     L2923
00062Cr 2  20 rr rr             jsr     ROUND_FAC
00062Fr 2  20 rr rr             jsr     AYINT
000632r 2  A0 00                ldy     #$00
000634r 2  A5 BB                lda     FAC+3
000636r 2  91 A0                sta     (FORPNT),y
000638r 2  C8                   iny
000639r 2  A5 BC                lda     FAC+4
00063Br 2  91 A0                sta     (FORPNT),y
00063Dr 2  60                   rts
00063Er 2               L2923:
00063Er 2               .endif
00063Er 2               
00063Er 2               ; ----------------------------------------------------------------------------
00063Er 2               ; REAL VARIABLE = EXPRESSION
00063Er 2               ; ----------------------------------------------------------------------------
00063Er 2  4C rr rr             jmp     SETFOR
000641r 2               LETSTRING:
000641r 2               .ifndef CONFIG_SMALL
000641r 2  68                   pla
000642r 2               .endif
000642r 2               
000642r 2               ; ----------------------------------------------------------------------------
000642r 2               ; INSTALL STRING, DESCRIPTOR ADDRESS IS AT FAC+3,4
000642r 2               ; ----------------------------------------------------------------------------
000642r 2               PUTSTR:
000642r 2               .ifdef CONFIG_CBM_ALL
000642r 2                       ldy     FORPNT+1
000642r 2                 .ifdef CBM1
000642r 2                       cpy     #$D0	; TI$
000642r 2                 .else
000642r 2                       cpy     #$DE
000642r 2                 .endif
000642r 2                       bne     LC92B
000642r 2                       jsr     FREFAC
000642r 2                       cmp     #$06
000642r 2                 .ifdef CBM2
000642r 2                       bne     IQERR1
000642r 2                 .else
000642r 2                       jne     IQERR
000642r 2                 .endif
000642r 2                       ldy     #$00
000642r 2                       sty     FAC
000642r 2                       sty     FACSIGN
000642r 2               LC8E8:
000642r 2                       sty     STRNG2
000642r 2                       jsr     LC91C
000642r 2                       jsr     MUL10
000642r 2                       inc     STRNG2
000642r 2                       ldy     STRNG2
000642r 2                       jsr     LC91C
000642r 2                       jsr     COPY_FAC_TO_ARG_ROUNDED
000642r 2                       tax
000642r 2                       beq     LC902
000642r 2                       inx
000642r 2                       txa
000642r 2                       jsr     LD9BF
000642r 2               LC902:
000642r 2                       ldy     STRNG2
000642r 2                       iny
000642r 2                       cpy     #$06
000642r 2                       bne     LC8E8
000642r 2                       jsr     MUL10
000642r 2                       jsr     QINT
000642r 2                       ldx     #$02
000642r 2                       sei
000642r 2               LC912:
000642r 2                       lda     FAC+2,x
000642r 2                       sta     TISTR,x
000642r 2                       dex
000642r 2                       bpl     LC912
000642r 2                       cli
000642r 2                       rts
000642r 2               LC91C:
000642r 2                       lda     (INDEX),y
000642r 2                       jsr     CHRGOT2
000642r 2                       bcc     LC926
000642r 2               IQERR1:
000642r 2                       jmp     IQERR
000642r 2               LC926:
000642r 2                       sbc     #$2F
000642r 2                       jmp     ADDACC
000642r 2               LC92B:
000642r 2               .endif
000642r 2  A0 02                ldy     #$02
000644r 2  B1 BB                lda     (FAC_LAST-1),y
000646r 2  C5 8B                cmp     FRETOP+1
000648r 2  90 17                bcc     L2946
00064Ar 2  D0 07                bne     L2938
00064Cr 2  88                   dey
00064Dr 2  B1 BB                lda     (FAC_LAST-1),y
00064Fr 2  C5 8A                cmp     FRETOP
000651r 2  90 0E                bcc     L2946
000653r 2               L2938:
000653r 2  A4 BC                ldy     FAC_LAST
000655r 2  C4 85                cpy     VARTAB+1
000657r 2  90 08                bcc     L2946
000659r 2  D0 0D                bne     L294D
00065Br 2  A5 BB                lda     FAC_LAST-1
00065Dr 2  C5 84                cmp     VARTAB
00065Fr 2  B0 07                bcs     L294D
000661r 2               L2946:
000661r 2  A5 BB                lda     FAC_LAST-1
000663r 2  A4 BC                ldy     FAC_LAST
000665r 2  4C rr rr             jmp     L2963
000668r 2               L294D:
000668r 2  A0 00                ldy     #$00
00066Ar 2  B1 BB                lda     (FAC_LAST-1),y
00066Cr 2  20 rr rr             jsr     STRINI
00066Fr 2  A5 A7                lda     DSCPTR
000671r 2  A4 A8                ldy     DSCPTR+1
000673r 2  85 C6                sta     STRNG1
000675r 2  84 C7                sty     STRNG1+1
000677r 2  20 rr rr             jsr     MOVINS
00067Ar 2  A9 B8                lda     #FAC
00067Cr 2  A0 00                ldy     #$00
00067Er 2               L2963:
00067Er 2  85 A7                sta     DSCPTR
000680r 2  84 A8                sty     DSCPTR+1
000682r 2  20 rr rr             jsr     FRETMS
000685r 2  A0 00                ldy     #$00
000687r 2  B1 A7                lda     (DSCPTR),y
000689r 2  91 A0                sta     (FORPNT),y
00068Br 2  C8                   iny
00068Cr 2  B1 A7                lda     (DSCPTR),y
00068Er 2  91 A0                sta     (FORPNT),y
000690r 2  C8                   iny
000691r 2  B1 A7                lda     (DSCPTR),y
000693r 2  91 A0                sta     (FORPNT),y
000695r 2               RET5:
000695r 2  60                   rts
000696r 2               .ifdef AIM65
000696r 2               LB89D:
000696r 2                       cmp     #$21
000696r 2                       bne     RET5
000696r 2                       lda     #$80
000696r 2                       sta     PRIFLG
000696r 2                       jmp     CHRGET
000696r 2               .endif
000696r 2               
000696r 2               .ifdef CONFIG_FILE
000696r 2               PRINTH:
000696r 2                       jsr     CMD
000696r 2                       jmp     LCAD6
000696r 2               CMD:
000696r 2                       jsr     GETBYT
000696r 2                       beq     LC98F
000696r 2                       lda     #$2C
000696r 2                       jsr     SYNCHR
000696r 2               LC98F:
000696r 2                       php
000696r 2                       jsr     CHKOUT
000696r 2                       stx     CURDVC
000696r 2                       plp
000696r 2                       jmp     PRINT
000696r 2               .endif
000696r 2               
000696r 2               
000696r 1               .include "print.s"
000696r 2               .segment "CODE"
000696r 2               
000696r 2               .ifdef AIM65
000696r 2               PRINT:
000696r 2                       lda     PRIFLG
000696r 2                       sta     ZBE
000696r 2                       jsr     L297E
000696r 2               LB8B1:
000696r 2                       lda     ZBE
000696r 2                       sta     PRIFLG
000696r 2                       rts
000696r 2               .endif
000696r 2               
000696r 2               PRSTRING:
000696r 2  20 rr rr             jsr     STRPRT
000699r 2               L297E:
000699r 2  20 D0 00             jsr     CHRGOT
00069Cr 2               
00069Cr 2               ; ----------------------------------------------------------------------------
00069Cr 2               ; "PRINT" STATEMENT
00069Cr 2               ; ----------------------------------------------------------------------------
00069Cr 2               .ifndef AIM65
00069Cr 2               PRINT:
00069Cr 2               .endif
00069Cr 2  F0 3C                beq     CRDO
00069Er 2               PRINT2:
00069Er 2  F0 48                beq     L29DD
0006A0r 2               .ifdef AIM65
0006A0r 2                       jsr     LB89D
0006A0r 2                       beq     L29DD
0006A0r 2               .endif
0006A0r 2  C9 9E                cmp     #TOKEN_TAB
0006A2r 2  F0 5C                beq     L29F5
0006A4r 2  C9 A1                cmp     #TOKEN_SPC
0006A6r 2               .ifdef CONFIG_2
0006A6r 2  18                   clc	; also AppleSoft II
0006A7r 2               .endif
0006A7r 2  F0 57                beq     L29F5
0006A9r 2  C9 2C                cmp     #','
0006ABr 2               ; Pre-KIM had no CLC. KIM added the CLC
0006ABr 2               ; here. Post-KIM moved the CLC up...
0006ABr 2               ; (makes no sense on KIM, liveness = 0)
0006ABr 2               .if .def(CONFIG_11A) && (!.def(CONFIG_2))
0006ABr 2                       clc
0006ABr 2               .endif
0006ABr 2  F0 3C                beq     L29DE
0006ADr 2  C9 3B                cmp     #$3B
0006AFr 2  F0 64                beq     L2A0D
0006B1r 2  20 rr rr             jsr     FRMEVL
0006B4r 2  24 66                bit     VALTYP
0006B6r 2  30 DE                bmi     PRSTRING
0006B8r 2  20 rr rr             jsr     FOUT
0006BBr 2  20 rr rr             jsr     STRLIT
0006BEr 2               .ifndef CONFIG_NO_CR
0006BEr 2  A0 00                ldy     #$00
0006C0r 2  B1 BB                lda     (FAC_LAST-1),y
0006C2r 2  18                   clc
0006C3r 2  65 0D                adc     POSX
0006C5r 2                 .ifdef KBD
0006C5r 2                       cmp     #$28
0006C5r 2                 .else
0006C5r 2  C5 0E                cmp     Z17
0006C7r 2                 .endif
0006C7r 2  90 03                bcc     L29B1
0006C9r 2  20 rr rr             jsr     CRDO
0006CCr 2               L29B1:
0006CCr 2               .endif
0006CCr 2  20 rr rr             jsr     STRPRT
0006CFr 2               .ifdef KBD
0006CFr 2                       jmp     L297E
0006CFr 2               .else
0006CFr 2  20 rr rr             jsr     OUTSP
0006D2r 2  D0 C5                bne     L297E ; branch always
0006D4r 2               .endif
0006D4r 2               
0006D4r 2               .ifdef KBD
0006D4r 2               ; PATCHES
0006D4r 2               LE86C:
0006D4r 2                       pla
0006D4r 2                       jmp     CONTROL_C_TYPED
0006D4r 2               LE870:
0006D4r 2                       jsr     GETBYT
0006D4r 2                       txa
0006D4r 2               LE874:
0006D4r 2                       beq     LE878
0006D4r 2                       bpl     LE8F2
0006D4r 2               LE878:
0006D4r 2                       jmp     IQERR
0006D4r 2               ; PATCHES
0006D4r 2               .endif
0006D4r 2               
0006D4r 2               
0006D4r 2               
0006D4r 2               .ifndef KBD
0006D4r 2               L29B9:
0006D4r 2                 .ifdef CBM2
0006D4r 2                       lda     #$00
0006D4r 2                       sta     INPUTBUFFER,x
0006D4r 2                       ldx     #<(INPUTBUFFER-1)
0006D4r 2                       ldy     #>(INPUTBUFFER-1)
0006D4r 2                 .else
0006D4r 2                   .ifndef APPLE
0006D4r 2  A0 00                ldy     #$00
0006D6r 2  94 12                sty     INPUTBUFFER,x
0006D8r 2  A2 11                ldx     #LINNUM+1
0006DAr 2                   .endif
0006DAr 2                   .if .def(MICROTAN) || .def(SYM1)
0006DAr 2                       bne     CRDO2
0006DAr 2               	.endif
0006DAr 2                 .endif
0006DAr 2                 .ifdef CONFIG_FILE
0006DAr 2                       lda     CURDVC
0006DAr 2                       bne     L29DD
0006DAr 2                 .endif
0006DAr 2               .endif
0006DAr 2               
0006DAr 2               
0006DAr 2               CRDO:
0006DAr 2               .if .def(CONFIG_PRINTNULLS) && .def(CONFIG_FILE)
0006DAr 2                       lda     CURDVC
0006DAr 2                       bne     LC9D8
0006DAr 2                       sta     POSX
0006DAr 2               LC9D8:
0006DAr 2               .endif
0006DAr 2  A9 0D                lda     #CRLF_1
0006DCr 2               .ifndef CONFIG_CBM_ALL
0006DCr 2  85 0D                sta     POSX
0006DEr 2               .endif
0006DEr 2  20 rr rr             jsr     OUTDO
0006E1r 2               CRDO2:
0006E1r 2  A9 0A                lda     #CRLF_2
0006E3r 2  20 rr rr             jsr     OUTDO
0006E6r 2               
0006E6r 2               PRINTNULLS:
0006E6r 2               .if .def(KBD) || .def(AIM65)
0006E6r 2                       lda     #$00
0006E6r 2                       sta     POSX
0006E6r 2                       eor     #$FF
0006E6r 2               .else
0006E6r 2                 .if .def(CONFIG_NULL) || .def(CONFIG_PRINTNULLS)
0006E6r 2                   .ifdef CONFIG_FILE
0006E6r 2                   ; Although there is no statement for it,
0006E6r 2                   ; CBM1 had NULL support and ignores
0006E6r 2                   ; it when not targeting the screen,
0006E6r 2                   ; CBM2 dropped it completely.
0006E6r 2                       lda     CURDVC
0006E6r 2                       bne     L29DD
0006E6r 2                   .endif
0006E6r 2                       txa
0006E6r 2                       pha
0006E6r 2                       ldx     Z15
0006E6r 2                       beq     L29D9
0006E6r 2                     .ifdef SYM1
0006E6r 2                       lda     #$FF
0006E6r 2                     .else
0006E6r 2                       lda     #$00
0006E6r 2                     .endif
0006E6r 2               L29D3:
0006E6r 2                       jsr     OUTDO
0006E6r 2                       dex
0006E6r 2                       bne     L29D3
0006E6r 2               L29D9:
0006E6r 2                       stx     POSX
0006E6r 2                       pla
0006E6r 2                       tax
0006E6r 2                 .else
0006E6r 2                   .ifndef CONFIG_2
0006E6r 2                       lda     #$00
0006E6r 2                       sta     POSX
0006E6r 2                   .endif
0006E6r 2  49 FF                eor     #$FF
0006E8r 2                 .endif
0006E8r 2               .endif
0006E8r 2               L29DD:
0006E8r 2  60                   rts
0006E9r 2               L29DE:
0006E9r 2  A5 0D                lda     POSX
0006EBr 2               .ifndef CONFIG_NO_CR
0006EBr 2                 .ifdef KBD
0006EBr 2                       cmp     #$1A
0006EBr 2                 .else
0006EBr 2  C5 0F                cmp     Z18
0006EDr 2                 .endif
0006EDr 2  90 06                bcc     L29EA
0006EFr 2  20 rr rr             jsr     CRDO
0006F2r 2  4C rr rr             jmp     L2A0D
0006F5r 2               L29EA:
0006F5r 2               .endif
0006F5r 2  38                   sec
0006F6r 2               L29EB:
0006F6r 2               .if .def(CONFIG_CBM_ALL) || .def(AIM65)
0006F6r 2                       sbc     #$0A
0006F6r 2               .else
0006F6r 2                 .ifdef KBD
0006F6r 2                       sbc     #$0D
0006F6r 2                 .else
0006F6r 2  E9 0E                sbc     #$0E
0006F8r 2                 .endif
0006F8r 2               .endif
0006F8r 2  B0 FC                bcs     L29EB
0006FAr 2  49 FF                eor     #$FF
0006FCr 2  69 01                adc     #$01
0006FEr 2  D0 10                bne     L2A08
000700r 2               L29F5:
000700r 2               .ifdef CONFIG_11A
000700r 2  08                   php
000701r 2               .else
000701r 2                       pha
000701r 2               .endif
000701r 2  20 rr rr             jsr     GTBYTC
000704r 2  C9 29                cmp     #')'
000706r 2               .ifdef CONFIG_11A
000706r 2                 .ifdef CONFIG_2
000706r 2  D0 5C                bne     SYNERR4
000708r 2                 .else
000708r 2                       jne     SYNERR
000708r 2                 .endif
000708r 2  28                   plp
000709r 2  90 06                bcc     L2A09
00070Br 2               .else
00070Br 2                 .ifdef CONFIG_11
00070Br 2                       jne     SYNERR
00070Br 2                 .else
00070Br 2                       bne     SYNERR4
00070Br 2                 .endif
00070Br 2                       pla
00070Br 2                       cmp     #TOKEN_TAB
00070Br 2                 .ifdef CONFIG_11
00070Br 2                       bne     L2A09
00070Br 2                 .else
00070Br 2                       bne     L2A0A
00070Br 2                 .endif
00070Br 2               .endif
00070Br 2  8A                   txa
00070Cr 2  E5 0D                sbc     POSX
00070Er 2  90 05                bcc     L2A0D
000710r 2               .ifndef CONFIG_11
000710r 2                       beq     L2A0D
000710r 2               .endif
000710r 2               L2A08:
000710r 2  AA                   tax
000711r 2               .ifdef CONFIG_11
000711r 2               L2A09:
000711r 2  E8                   inx
000712r 2               .endif
000712r 2               L2A0A:
000712r 2               .ifndef CONFIG_11
000712r 2                       jsr     OUTSP
000712r 2               .endif
000712r 2  CA                   dex
000713r 2               .ifndef CONFIG_11
000713r 2                       bne     L2A0A
000713r 2               .else
000713r 2  D0 06                bne     L2A13
000715r 2               .endif
000715r 2               L2A0D:
000715r 2  20 CA 00             jsr     CHRGET
000718r 2  4C rr rr             jmp     PRINT2
00071Br 2               .ifdef CONFIG_11
00071Br 2               L2A13:
00071Br 2  20 rr rr             jsr     OUTSP
00071Er 2  D0 F2                bne     L2A0A
000720r 2               .endif
000720r 2               
000720r 2               ; ----------------------------------------------------------------------------
000720r 2               ; PRINT STRING AT (Y,A)
000720r 2               ; ----------------------------------------------------------------------------
000720r 2               STROUT:
000720r 2  20 rr rr             jsr     STRLIT
000723r 2               
000723r 2               ; ----------------------------------------------------------------------------
000723r 2               ; PRINT STRING AT (FACMO,FACLO)
000723r 2               ; ----------------------------------------------------------------------------
000723r 2               STRPRT:
000723r 2  20 rr rr             jsr     FREFAC
000726r 2  AA                   tax
000727r 2  A0 00                ldy     #$00
000729r 2  E8                   inx
00072Ar 2               L2A22:
00072Ar 2  CA                   dex
00072Br 2  F0 BB                beq     L29DD
00072Dr 2  B1 79                lda     (INDEX),y
00072Fr 2  20 rr rr             jsr     OUTDO
000732r 2  C8                   iny
000733r 2  C9 0D                cmp     #$0D
000735r 2  D0 F3                bne     L2A22
000737r 2  20 rr rr             jsr     PRINTNULLS
00073Ar 2  4C rr rr             jmp     L2A22
00073Dr 2               ; ----------------------------------------------------------------------------
00073Dr 2               OUTSP:
00073Dr 2               .ifdef CONFIG_FILE
00073Dr 2                 .ifndef CBM1
00073Dr 2               ; on non-screen devices, print SPACE
00073Dr 2               ; instead of CRSR RIGHT
00073Dr 2                       lda     CURDVC
00073Dr 2                       beq     LCA40
00073Dr 2                       lda     #$20
00073Dr 2                       .byte   $2C
00073Dr 2               LCA40:
00073Dr 2                 .endif
00073Dr 2                       lda     #$1D ; CRSR RIGHT
00073Dr 2               .else
00073Dr 2  A9 20                lda     #$20
00073Fr 2               .endif
00073Fr 2  2C                   .byte   $2C
000740r 2               OUTQUES:
000740r 2  A9 3F                lda     #$3F
000742r 2               
000742r 2               ; ----------------------------------------------------------------------------
000742r 2               ; PRINT CHAR FROM (A)
000742r 2               ; ----------------------------------------------------------------------------
000742r 2               OUTDO:
000742r 2               .ifndef KBD
000742r 2  24 6C                bit     Z14
000744r 2  30 09                bmi     L2A56
000746r 2               .endif
000746r 2               .if .def(CONFIG_PRINT_CR) || .def(CBM1)
000746r 2               ; Commodore forgot to remove this in CBM1
000746r 2                       pha
000746r 2               .endif
000746r 2               .ifdef CBM1
000746r 2                       cmp     #$1D ; CRSR RIGHT
000746r 2                       beq     LCA6A
000746r 2                       cmp     #$9D ; CRSR LEFT
000746r 2                       beq     LCA5A
000746r 2                       cmp     #$14 ; DEL
000746r 2                       bne     LCA64
000746r 2               LCA5A:
000746r 2                       lda     POSX
000746r 2                       beq     L2A4E
000746r 2                       lda     CURDVC
000746r 2                       bne     L2A4E
000746r 2                       dec     POSX
000746r 2               LCA64:
000746r 2                       and     #$7F
000746r 2               .endif
000746r 2               .ifndef CBM2
000746r 2  C9 20                cmp     #$20
000748r 2  90 02                bcc     L2A4E
00074Ar 2               .endif
00074Ar 2               LCA6A:
00074Ar 2               .ifdef CONFIG_CBM1_PATCHES
00074Ar 2                       lda     CURDVC
00074Ar 2                       jsr     PATCH6
00074Ar 2                       nop
00074Ar 2               .endif
00074Ar 2               .ifdef CONFIG_PRINT_CR
00074Ar 2                       lda     POSX
00074Ar 2                       cmp     Z17
00074Ar 2                       bne     L2A4C
00074Ar 2                 .ifdef AIM65
00074Ar 2                       lda #$00
00074Ar 2                       sta POSX
00074Ar 2                 .elseif .def(APPLE)
00074Ar 2                       nop ; PATCH!
00074Ar 2                       nop ; don't print CR
00074Ar 2                       nop
00074Ar 2                 .else
00074Ar 2                       jsr     CRDO
00074Ar 2                 .endif
00074Ar 2               L2A4C:
00074Ar 2               .endif
00074Ar 2               .ifndef CONFIG_CBM_ALL
00074Ar 2  E6 0D                inc     POSX
00074Cr 2               .endif
00074Cr 2               L2A4E:
00074Cr 2               .if .def(CONFIG_PRINT_CR) || .def(CBM1)
00074Cr 2               ; Commodore forgot to remove this in CBM1
00074Cr 2                       pla
00074Cr 2               .endif
00074Cr 2               .ifdef CONFIG_MONCOUT_DESTROYS_Y
00074Cr 2                       sty     DIMFLG
00074Cr 2               .endif
00074Cr 2               .ifdef CONFIG_IO_MSB
00074Cr 2                       ora     #$80
00074Cr 2               .endif
00074Cr 2  20 rr rr             jsr     MONCOUT
00074Fr 2               .ifdef CONFIG_IO_MSB
00074Fr 2                       and     #$7F
00074Fr 2               .endif
00074Fr 2               .ifdef CONFIG_MONCOUT_DESTROYS_Y
00074Fr 2                       ldy     DIMFLG
00074Fr 2               .endif
00074Fr 2               .ifdef OSI
00074Fr 2                       nop
00074Fr 2                       nop
00074Fr 2                       nop
00074Fr 2                       nop
00074Fr 2               .endif
00074Fr 2               L2A56:
00074Fr 2  29 FF                and     #$FF
000751r 2               LE8F2:
000751r 2  60                   rts
000752r 2               
000752r 2               ; ----------------------------------------------------------------------------
000752r 2               ; ???
000752r 2               ; ----------------------------------------------------------------------------
000752r 2               .ifdef KBD
000752r 2               LE8F3:
000752r 2                       pha
000752r 2                       lda     $047F
000752r 2                       clc
000752r 2                       beq     LE900
000752r 2                       lda     #$00
000752r 2                       sta     $047F
000752r 2                       sec
000752r 2               LE900:
000752r 2                       pla
000752r 2                       rts
000752r 2               .endif
000752r 2               
000752r 1               .include "input.s"
000752r 2               .segment "CODE"
000752r 2               
000752r 2               ; ----------------------------------------------------------------------------
000752r 2               ; INPUT CONVERSION ERROR:  ILLEGAL CHARACTER
000752r 2               ; IN NUMERIC FIELD.  MUST DISTINGUISH
000752r 2               ; BETWEEN INPUT, READ, AND GET
000752r 2               ; ----------------------------------------------------------------------------
000752r 2               INPUTERR:
000752r 2  A5 6A                lda     INPUTFLG
000754r 2  F0 11                beq     RESPERR	; INPUT
000756r 2               .ifndef SYM1
000756r 2               .ifndef CONFIG_SMALL
000756r 2               .ifdef CONFIG_10A
000756r 2               ; without this, it treats GET errors
000756r 2               ; like READ errors
000756r 2  30 04                bmi     L2A63	; READ
000758r 2  A0 FF                ldy     #$FF	; GET
00075Ar 2  D0 04                bne     L2A67
00075Cr 2               L2A63:
00075Cr 2               .endif
00075Cr 2               .endif
00075Cr 2               .endif
00075Cr 2               .ifdef CONFIG_CBM1_PATCHES
00075Cr 2                       jsr     PATCH5
00075Cr 2               		nop
00075Cr 2               .else
00075Cr 2  A5 96                lda     Z8C
00075Er 2  A4 97                ldy     Z8C+1
000760r 2               .endif
000760r 2               L2A67:
000760r 2  85 90                sta     CURLIN
000762r 2  84 91                sty     CURLIN+1
000764r 2               SYNERR4:
000764r 2  4C rr rr             jmp     SYNERR
000767r 2               RESPERR:
000767r 2               .ifdef CONFIG_FILE
000767r 2                       lda     CURDVC
000767r 2                       beq     LCA8F
000767r 2                       ldx     #ERR_BADDATA
000767r 2                       jmp     ERROR
000767r 2               LCA8F:
000767r 2               .endif
000767r 2  A9 rr                lda     #<ERRREENTRY
000769r 2  A0 rr                ldy     #>ERRREENTRY
00076Br 2  20 rr rr             jsr     STROUT
00076Er 2  A5 94                lda     OLDTEXT
000770r 2  A4 95                ldy     OLDTEXT+1
000772r 2  85 D1                sta     TXTPTR
000774r 2  84 D2                sty     TXTPTR+1
000776r 2               RTS20:
000776r 2  60                   rts
000777r 2               
000777r 2               ; ----------------------------------------------------------------------------
000777r 2               ; "GET" STATEMENT
000777r 2               ; ----------------------------------------------------------------------------
000777r 2               .ifndef CONFIG_SMALL
000777r 2               .ifndef SYM1
000777r 2               GET:
000777r 2  20 rr rr             jsr     ERRDIR
00077Ar 2               ; CBM: if GET#, then switch input
00077Ar 2               .ifdef CONFIG_FILE
00077Ar 2                       cmp     #'#'
00077Ar 2                       bne     LCAB6
00077Ar 2                       jsr     CHRGET
00077Ar 2                       jsr     GETBYT
00077Ar 2                       lda     #','
00077Ar 2                       jsr     SYNCHR
00077Ar 2                       jsr     CHKIN
00077Ar 2                       stx     CURDVC
00077Ar 2               LCAB6:
00077Ar 2               .endif
00077Ar 2  A2 13                ldx     #<(INPUTBUFFER+1)
00077Cr 2  A0 00                ldy     #>(INPUTBUFFER+1)
00077Er 2               .ifdef CONFIG_NO_INPUTBUFFER_ZP
00077Er 2                       lda     #$00
00077Er 2                       sta     INPUTBUFFER+1
00077Er 2               .else
00077Er 2  84 13                sty     INPUTBUFFER+1
000780r 2               .endif
000780r 2  A9 40                lda     #$40
000782r 2  20 rr rr             jsr     PROCESS_INPUT_LIST
000785r 2               ; CBM: if GET#, then switch input back
000785r 2               .ifdef CONFIG_FILE
000785r 2                       ldx     CURDVC
000785r 2                       bne     LCAD8
000785r 2               .endif
000785r 2  60                   rts
000786r 2               .endif
000786r 2               .endif
000786r 2               
000786r 2               ; ----------------------------------------------------------------------------
000786r 2               ; "INPUT#" STATEMENT
000786r 2               ; ----------------------------------------------------------------------------
000786r 2               .ifdef CONFIG_FILE
000786r 2               INPUTH:
000786r 2                       jsr     GETBYT
000786r 2                       lda     #$2C
000786r 2                       jsr     SYNCHR
000786r 2                       jsr     CHKIN
000786r 2                       stx     CURDVC
000786r 2                       jsr     L2A9E
000786r 2               LCAD6:
000786r 2                       lda     CURDVC
000786r 2               LCAD8:
000786r 2                       jsr     CLRCH
000786r 2                       ldx     #$00
000786r 2                       stx     CURDVC
000786r 2                       rts
000786r 2               LCAE0:
000786r 2               .endif
000786r 2               
000786r 2               .ifdef SYM1
000786r 2               LC9B0:
000786r 2                       jsr     OUTQUES	; '?'
000786r 2                       jsr     OUTSP
000786r 2                       jmp     L2A9E
000786r 2               .endif
000786r 2               ; ----------------------------------------------------------------------------
000786r 2               ; "INPUT" STATEMENT
000786r 2               ; ----------------------------------------------------------------------------
000786r 2               INPUT:
000786r 2               .ifndef KBD
000786r 2  46 6C                lsr     Z14
000788r 2               .endif
000788r 2               .ifdef AIM65
000788r 2                       lda     PRIFLG
000788r 2                       sta     ZBE
000788r 2                       jsr     LCFFA
000788r 2               .endif
000788r 2  C9 22                cmp     #$22
00078Ar 2               .ifdef SYM1
00078Ar 2                       bne     LC9B0
00078Ar 2               .else
00078Ar 2  D0 0B                bne     L2A9E
00078Cr 2               .endif
00078Cr 2  20 rr rr             jsr     STRTXT
00078Fr 2  A9 3B                lda     #$3B
000791r 2  20 rr rr             jsr     SYNCHR
000794r 2  20 rr rr             jsr     STRPRT
000797r 2               L2A9E:
000797r 2  20 rr rr             jsr     ERRDIR
00079Ar 2  A9 2C                lda     #$2C
00079Cr 2  85 11                sta     INPUTBUFFER-1
00079Er 2               LCAF8:
00079Er 2               .ifdef APPLE
00079Er 2                       jsr     INLINX
00079Er 2               .elseif .def(SYM1)
00079Er 2                       jsr     INLIN
00079Er 2               .else
00079Er 2  20 rr rr             jsr     NXIN
0007A1r 2               .endif
0007A1r 2               .ifdef KBD
0007A1r 2                       bmi     L2ABE
0007A1r 2               .else
0007A1r 2                 .ifdef CONFIG_FILE
0007A1r 2                       lda     CURDVC
0007A1r 2                       beq     LCB0C
0007A1r 2                       lda     Z96
0007A1r 2                       and     #$02
0007A1r 2                       beq     LCB0C
0007A1r 2                       jsr     LCAD6
0007A1r 2                       jmp     DATA
0007A1r 2               LCB0C:
0007A1r 2                 .endif
0007A1r 2  A5 12                lda     INPUTBUFFER
0007A3r 2  D0 12                bne     L2ABE
0007A5r 2                 .ifdef CONFIG_FILE
0007A5r 2                       lda     CURDVC
0007A5r 2                       bne     LCAF8
0007A5r 2                 .endif
0007A5r 2                 .ifdef CONFIG_CBM1_PATCHES
0007A5r 2                       jmp     PATCH1
0007A5r 2                 .else
0007A5r 2  18                   clc
0007A6r 2  4C rr rr             jmp     CONTROL_C_TYPED
0007A9r 2                 .endif
0007A9r 2               .endif
0007A9r 2               
0007A9r 2               NXIN:
0007A9r 2               .ifdef KBD
0007A9r 2                       jsr     INLIN
0007A9r 2                       bmi     RTS20
0007A9r 2                       pla
0007A9r 2                       jmp     LE86C
0007A9r 2               .else
0007A9r 2                 .ifdef CONFIG_FILE
0007A9r 2                       lda     CURDVC
0007A9r 2                       bne     LCB21
0007A9r 2                 .endif
0007A9r 2  20 rr rr             jsr     OUTQUES	; '?'
0007ACr 2  20 rr rr             jsr     OUTSP
0007AFr 2               LCB21:
0007AFr 2  4C rr rr             jmp     INLIN
0007B2r 2               .endif
0007B2r 2               
0007B2r 2               ; ----------------------------------------------------------------------------
0007B2r 2               ; "GETC" STATEMENT
0007B2r 2               ; ----------------------------------------------------------------------------
0007B2r 2               .ifdef KBD
0007B2r 2               GETC:
0007B2r 2                       jsr     CONINT
0007B2r 2                       jsr     LF43D
0007B2r 2                       jmp     LE664
0007B2r 2               .endif
0007B2r 2               
0007B2r 2               ; ----------------------------------------------------------------------------
0007B2r 2               ; "READ" STATEMENT
0007B2r 2               ; ----------------------------------------------------------------------------
0007B2r 2               READ:
0007B2r 2  A6 98                ldx     DATPTR
0007B4r 2  A4 99                ldy     DATPTR+1
0007B6r 2               .ifdef CONFIG_NO_READ_Y_IS_ZERO_HACK
0007B6r 2               ; AppleSoft II, too
0007B6r 2                       lda     #$98	; READ
0007B6r 2                       .byte   $2C
0007B6r 2               L2ABE:
0007B6r 2                       lda     #$00	; INPUT
0007B6r 2               .else
0007B6r 2  A9                   .byte   $A9	; LDA #$98
0007B7r 2               L2ABE:
0007B7r 2  98                   tya
0007B8r 2               .endif
0007B8r 2               
0007B8r 2               ; ----------------------------------------------------------------------------
0007B8r 2               ; PROCESS INPUT LIST
0007B8r 2               ;
0007B8r 2               ; (Y,X) IS ADDRESS OF INPUT DATA STRING
0007B8r 2               ; (A) = VALUE FOR INPUTFLG:  $00 FOR INPUT
0007B8r 2               ; 				$40 FOR GET
0007B8r 2               ;				$98 FOR READ
0007B8r 2               ; ----------------------------------------------------------------------------
0007B8r 2               PROCESS_INPUT_LIST:
0007B8r 2  85 6A                sta     INPUTFLG
0007BAr 2  86 9A                stx     INPTR
0007BCr 2  84 9B                sty     INPTR+1
0007BEr 2               PROCESS_INPUT_ITEM:
0007BEr 2  20 rr rr             jsr     PTRGET
0007C1r 2  85 A0                sta     FORPNT
0007C3r 2  84 A1                sty     FORPNT+1
0007C5r 2  A5 D1                lda     TXTPTR
0007C7r 2  A4 D2                ldy     TXTPTR+1
0007C9r 2  85 10                sta     TXPSV
0007CBr 2  84 11                sty     TXPSV+1
0007CDr 2  A6 9A                ldx     INPTR
0007CFr 2  A4 9B                ldy     INPTR+1
0007D1r 2  86 D1                stx     TXTPTR
0007D3r 2  84 D2                sty     TXTPTR+1
0007D5r 2  20 D0 00             jsr     CHRGOT
0007D8r 2  D0 1B                bne     INSTART
0007DAr 2  24 6A                bit     INPUTFLG
0007DCr 2               .ifndef CONFIG_SMALL ; GET
0007DCr 2                .ifndef SYM1
0007DCr 2  50 0B                bvc     L2AF0
0007DEr 2                 .ifdef MICROTAN
0007DEr 2                       jsr     MONRDKEY2
0007DEr 2                 .elseif .def(AIM65)
0007DEr 2                       jsr     MONRDKEY2
0007DEr 2                 .else
0007DEr 2  20 rr rr             jsr     MONRDKEY
0007E1r 2                 .endif
0007E1r 2                 .ifdef CONFIG_IO_MSB
0007E1r 2                       and     #$7F
0007E1r 2                 .endif
0007E1r 2  85 12                sta     INPUTBUFFER
0007E3r 2               ; BUG: The beq/bne L2AF8 below is supposed
0007E3r 2               ; to be always taken. For this to happen,
0007E3r 2               ; the last load must be a 0 for beq
0007E3r 2               ; and != 0 for bne. The original Microsoft
0007E3r 2               ; code had ldx/ldy/bne here, which was only
0007E3r 2               ; correct for a non-ZP INPUTBUFFER. Commodore
0007E3r 2               ; fixed it in CBMBASIC V1 by swapping the
0007E3r 2               ; ldx and the ldy. It was broken on KIM,
0007E3r 2               ; but okay on APPLE and CBM2, because
0007E3r 2               ; these used a non-ZP INPUTBUFFER.
0007E3r 2               ; Microsoft fixed this somewhere after KIM
0007E3r 2               ; and before MICROTAN, by using beq instead
0007E3r 2               ; of bne in the ZP case.
0007E3r 2                 .ifdef CBM1
0007E3r 2                       ldy     #>(INPUTBUFFER-1)
0007E3r 2                       ldx     #<(INPUTBUFFER-1)
0007E3r 2                 .else
0007E3r 2  A2 11                ldx     #<(INPUTBUFFER-1)
0007E5r 2  A0 00                ldy     #>(INPUTBUFFER-1)
0007E7r 2                 .endif
0007E7r 2                 .if .def(CONFIG_2) && (!.def(CONFIG_NO_INPUTBUFFER_ZP))
0007E7r 2  F0 08                beq     L2AF8	; always
0007E9r 2                 .else
0007E9r 2                       bne     L2AF8	; always
0007E9r 2                 .endif
0007E9r 2               L2AF0:
0007E9r 2                .endif
0007E9r 2               .endif
0007E9r 2  30 71                bmi     FINDATA
0007EBr 2               .ifdef CONFIG_FILE
0007EBr 2                       lda     CURDVC
0007EBr 2                       bne     LCB64
0007EBr 2               .endif
0007EBr 2               .ifdef KBD
0007EBr 2                       jsr     OUTQUESSP
0007EBr 2               .else
0007EBr 2  20 rr rr             jsr     OUTQUES
0007EEr 2               .endif
0007EEr 2               LCB64:
0007EEr 2  20 rr rr             jsr     NXIN
0007F1r 2               L2AF8:
0007F1r 2  86 D1                stx     TXTPTR
0007F3r 2  84 D2                sty     TXTPTR+1
0007F5r 2               
0007F5r 2               ; ----------------------------------------------------------------------------
0007F5r 2               INSTART:
0007F5r 2  20 CA 00             jsr     CHRGET
0007F8r 2  24 66                bit     VALTYP
0007FAr 2  10 31                bpl     L2B34
0007FCr 2               .ifndef CONFIG_SMALL ; GET
0007FCr 2                .ifndef SYM1
0007FCr 2  24 6A                bit     INPUTFLG
0007FEr 2  50 09                bvc     L2B10
000800r 2                 .ifdef CONFIG_CBM1_PATCHES
000800r 2                       lda     #$00
000800r 2                       jsr     PATCH4
000800r 2                       nop
000800r 2                 .else
000800r 2  E8                   inx
000801r 2  86 D1                stx     TXTPTR
000803r 2  A9 00                lda     #$00
000805r 2  85 62                sta     CHARAC
000807r 2  F0 0C                beq     L2B1C
000809r 2                 .endif
000809r 2               L2B10:
000809r 2                .endif
000809r 2               .endif
000809r 2  85 62                sta     CHARAC
00080Br 2  C9 22                cmp     #$22
00080Dr 2  F0 07                beq     L2B1D
00080Fr 2  A9 3A                lda     #$3A
000811r 2  85 62                sta     CHARAC
000813r 2  A9 2C                lda     #$2C
000815r 2               L2B1C:
000815r 2  18                   clc
000816r 2               L2B1D:
000816r 2  85 63                sta     ENDCHR
000818r 2  A5 D1                lda     TXTPTR
00081Ar 2  A4 D2                ldy     TXTPTR+1
00081Cr 2  69 00                adc     #$00
00081Er 2  90 01                bcc     L2B28
000820r 2  C8                   iny
000821r 2               L2B28:
000821r 2  20 rr rr             jsr     STRLT2
000824r 2  20 rr rr             jsr     POINT
000827r 2               .ifdef CONFIG_SMALL
000827r 2                       jsr     LETSTRING
000827r 2               .else
000827r 2  20 rr rr             jsr     PUTSTR
00082Ar 2               .endif
00082Ar 2  4C rr rr             jmp     INPUT_MORE
00082Dr 2               ; ----------------------------------------------------------------------------
00082Dr 2               L2B34:
00082Dr 2  20 rr rr             jsr     FIN
000830r 2               .ifdef CONFIG_SMALL
000830r 2                       jsr     SETFOR
000830r 2               .else
000830r 2  A5 67                lda     VALTYP+1
000832r 2  20 rr rr             jsr     LET2
000835r 2               .endif
000835r 2               ; ----------------------------------------------------------------------------
000835r 2               INPUT_MORE:
000835r 2  20 D0 00             jsr     CHRGOT
000838r 2  F0 07                beq     L2B48
00083Ar 2  C9 2C                cmp     #$2C
00083Cr 2  F0 03                beq     L2B48
00083Er 2  4C rr rr             jmp     INPUTERR
000841r 2               L2B48:
000841r 2  A5 D1                lda     TXTPTR
000843r 2  A4 D2                ldy     TXTPTR+1
000845r 2  85 9A                sta     INPTR
000847r 2  84 9B                sty     INPTR+1
000849r 2  A5 10                lda     TXPSV
00084Br 2  A4 11                ldy     TXPSV+1
00084Dr 2  85 D1                sta     TXTPTR
00084Fr 2  84 D2                sty     TXTPTR+1
000851r 2  20 D0 00             jsr     CHRGOT
000854r 2  F0 2C                beq     INPDONE
000856r 2  20 rr rr             jsr     CHKCOM
000859r 2  4C rr rr             jmp     PROCESS_INPUT_ITEM
00085Cr 2               ; ----------------------------------------------------------------------------
00085Cr 2               FINDATA:
00085Cr 2  20 rr rr             jsr     DATAN
00085Fr 2  C8                   iny
000860r 2  AA                   tax
000861r 2  D0 12                bne     L2B7C
000863r 2  A2 2A                ldx     #ERR_NODATA
000865r 2  C8                   iny
000866r 2  B1 D1                lda     (TXTPTR),y
000868r 2  F0 69                beq     GERR
00086Ar 2  C8                   iny
00086Br 2  B1 D1                lda     (TXTPTR),y
00086Dr 2  85 96                sta     Z8C
00086Fr 2  C8                   iny
000870r 2  B1 D1                lda     (TXTPTR),y
000872r 2  C8                   iny
000873r 2  85 97                sta     Z8C+1
000875r 2               L2B7C:
000875r 2  B1 D1                lda     (TXTPTR),y
000877r 2  AA                   tax
000878r 2  20 rr rr             jsr     ADDON
00087Br 2  E0 83                cpx     #$83
00087Dr 2  D0 DD                bne     FINDATA
00087Fr 2  4C rr rr             jmp     INSTART
000882r 2               ; ---NO MORE INPUT REQUESTED------
000882r 2               INPDONE:
000882r 2  A5 9A                lda     INPTR
000884r 2  A4 9B                ldy     INPTR+1
000886r 2  A6 6A                ldx     INPUTFLG
000888r 2               .if .def(CONFIG_SMALL) && (!.def(CONFIG_11))
000888r 2                       beq     L2B94 ; INPUT
000888r 2               .else
000888r 2  10 03                bpl     L2B94; INPUT or GET
00088Ar 2               .endif
00088Ar 2  4C rr rr             jmp     SETDA
00088Dr 2               L2B94:
00088Dr 2  A0 00                ldy     #$00
00088Fr 2               .ifdef AIM65
00088Fr 2                       jsr     LB8B1
00088Fr 2               .endif
00088Fr 2  B1 9A                lda     (INPTR),y
000891r 2  F0 07                beq     L2BA1
000893r 2               .ifdef CONFIG_FILE
000893r 2                       lda     CURDVC
000893r 2                       bne     L2BA1
000893r 2               .endif
000893r 2  A9 rr                lda     #<ERREXTRA
000895r 2  A0 rr                ldy     #>ERREXTRA
000897r 2  4C rr rr             jmp     STROUT
00089Ar 2               L2BA1:
00089Ar 2  60                   rts
00089Br 2               
00089Br 2               ; ----------------------------------------------------------------------------
00089Br 2               ERREXTRA:
00089Br 2               .ifdef KBD
00089Br 2                       .byte   "?Extra"
00089Br 2               .else
00089Br 2  3F 45 58 54          .byte   "?EXTRA IGNORED"
00089Fr 2  52 41 20 49  
0008A3r 2  47 4E 4F 52  
0008A9r 2               .endif
0008A9r 2  0D 0A 00             .byte   $0D,$0A,$00
0008ACr 2               ERRREENTRY:
0008ACr 2               .ifdef KBD
0008ACr 2                       .byte   "What?"
0008ACr 2               .else
0008ACr 2  3F 52 45 44          .byte   "?REDO FROM START"
0008B0r 2  4F 20 46 52  
0008B4r 2  4F 4D 20 53  
0008BCr 2               .endif
0008BCr 2  0D 0A 00             .byte   $0D,$0A,$00
0008BFr 2               .ifdef KBD
0008BFr 2               LEA30:
0008BFr 2                       .byte   "B"
0008BFr 2                       .byte   $FD
0008BFr 2                       .byte   "GsBASIC"
0008BFr 2                       .byte   $00,$1B,$0D,$13
0008BFr 2                       .byte   " BASIC"
0008BFr 2               .endif
0008BFr 2               
0008BFr 1               .include "eval.s"
0008BFr 2               .segment "CODE"
0008BFr 2               
0008BFr 2               ; ----------------------------------------------------------------------------
0008BFr 2               ; "NEXT" STATEMENT
0008BFr 2               ; ----------------------------------------------------------------------------
0008BFr 2               NEXT:
0008BFr 2  D0 04                bne     NEXT1
0008C1r 2  A0 00                ldy     #$00
0008C3r 2  F0 03                beq     NEXT2
0008C5r 2               NEXT1:
0008C5r 2  20 rr rr             jsr     PTRGET
0008C8r 2               NEXT2:
0008C8r 2  85 A0                sta     FORPNT
0008CAr 2  84 A1                sty     FORPNT+1
0008CCr 2  20 rr rr             jsr     GTFORPNT
0008CFr 2  F0 04                beq     NEXT3
0008D1r 2  A2 00                ldx     #$00
0008D3r 2               GERR:
0008D3r 2  F0 66                beq     JERROR
0008D5r 2               NEXT3:
0008D5r 2  9A                   txs
0008D6r 2               .ifndef CONFIG_2
0008D6r 2                       inx
0008D6r 2                       inx
0008D6r 2                       inx
0008D6r 2                       inx
0008D6r 2               .endif
0008D6r 2  8A                   txa
0008D7r 2               .ifdef CONFIG_2
0008D7r 2  18                   clc
0008D8r 2  69 04                adc     #$04
0008DAr 2  48                   pha
0008DBr 2  69 06                adc     #BYTES_FP+1
0008DDr 2  85 7B                sta     DEST
0008DFr 2  68                   pla
0008E0r 2               .else
0008E0r 2                       inx
0008E0r 2                       inx
0008E0r 2                       inx
0008E0r 2                       inx
0008E0r 2                       inx
0008E0r 2               .ifndef CONFIG_SMALL
0008E0r 2                       inx
0008E0r 2               .endif
0008E0r 2                       stx     DEST
0008E0r 2               .endif
0008E0r 2  A0 01                ldy     #>STACK
0008E2r 2  20 rr rr             jsr     LOAD_FAC_FROM_YA
0008E5r 2  BA                   tsx
0008E6r 2  BD 09 01             lda     STACK+BYTES_FP+4,x
0008E9r 2  85 BD                sta     FACSIGN
0008EBr 2  A5 A0                lda     FORPNT
0008EDr 2  A4 A1                ldy     FORPNT+1
0008EFr 2  20 rr rr             jsr     FADD
0008F2r 2  20 rr rr             jsr     SETFOR
0008F5r 2  A0 01                ldy     #>STACK
0008F7r 2  20 rr rr             jsr     FCOMP2
0008FAr 2  BA                   tsx
0008FBr 2  38                   sec
0008FCr 2  FD 09 01             sbc     STACK+BYTES_FP+4,x
0008FFr 2  F0 17                beq     L2C22
000901r 2  BD 0F 01             lda     STACK+2*BYTES_FP+5,x
000904r 2  85 90                sta     CURLIN
000906r 2  BD 10 01             lda     STACK+2*BYTES_FP+6,x
000909r 2  85 91                sta     CURLIN+1
00090Br 2  BD 12 01             lda     STACK+2*BYTES_FP+8,x
00090Er 2  85 D1                sta     TXTPTR
000910r 2  BD 11 01             lda     STACK+2*BYTES_FP+7,x
000913r 2  85 D2                sta     TXTPTR+1
000915r 2               L2C1F:
000915r 2  4C rr rr             jmp     NEWSTT
000918r 2               L2C22:
000918r 2  8A                   txa
000919r 2  69 11                adc     #2*BYTES_FP+7
00091Br 2  AA                   tax
00091Cr 2  9A                   txs
00091Dr 2  20 D0 00             jsr     CHRGOT
000920r 2  C9 2C                cmp     #$2C
000922r 2  D0 F1                bne     L2C1F
000924r 2  20 CA 00             jsr     CHRGET
000927r 2  20 rr rr             jsr     NEXT1
00092Ar 2               
00092Ar 2               ; ----------------------------------------------------------------------------
00092Ar 2               ; EVALUATE EXPRESSION, MAKE SURE IT IS NUMERIC
00092Ar 2               ; ----------------------------------------------------------------------------
00092Ar 2               FRMNUM:
00092Ar 2  20 rr rr             jsr     FRMEVL
00092Dr 2               
00092Dr 2               ; ----------------------------------------------------------------------------
00092Dr 2               ; MAKE SURE (FAC) IS NUMERIC
00092Dr 2               ; ----------------------------------------------------------------------------
00092Dr 2               CHKNUM:
00092Dr 2  18                   clc
00092Er 2  24                   .byte   $24
00092Fr 2               
00092Fr 2               ; ----------------------------------------------------------------------------
00092Fr 2               ; MAKE SURE (FAC) IS STRING
00092Fr 2               ; ----------------------------------------------------------------------------
00092Fr 2               CHKSTR:
00092Fr 2  38                   sec
000930r 2               
000930r 2               ; ----------------------------------------------------------------------------
000930r 2               ; MAKE SURE (FAC) IS CORRECT TYPE
000930r 2               ; IF C=0, TYPE MUST BE NUMERIC
000930r 2               ; IF C=1, TYPE MUST BE STRING
000930r 2               ; ----------------------------------------------------------------------------
000930r 2               CHKVAL:
000930r 2  24 66                bit     VALTYP
000932r 2  30 03                bmi     L2C41
000934r 2  B0 03                bcs     L2C43
000936r 2               L2C40:
000936r 2  60                   rts
000937r 2               L2C41:
000937r 2  B0 FD                bcs     L2C40
000939r 2               L2C43:
000939r 2  A2 A3                ldx     #ERR_BADTYPE
00093Br 2               JERROR:
00093Br 2  4C rr rr             jmp     ERROR
00093Er 2               
00093Er 2               ; ----------------------------------------------------------------------------
00093Er 2               ; EVALUATE THE EXPRESSION AT TXTPTR, LEAVING THE
00093Er 2               ; RESULT IN FAC.  WORKS FOR BOTH STRING AND NUMERIC
00093Er 2               ; EXPRESSIONS.
00093Er 2               ; ----------------------------------------------------------------------------
00093Er 2               FRMEVL:
00093Er 2  A6 D1                ldx     TXTPTR
000940r 2  D0 02                bne     L2C4E
000942r 2  C6 D2                dec     TXTPTR+1
000944r 2               L2C4E:
000944r 2  C6 D1                dec     TXTPTR
000946r 2  A2 00                ldx     #$00
000948r 2  24                   .byte   $24
000949r 2               FRMEVL1:
000949r 2  48                   pha
00094Ar 2  8A                   txa
00094Br 2  48                   pha
00094Cr 2  A9 01                lda     #$01
00094Er 2  20 rr rr             jsr     CHKMEM
000951r 2  20 rr rr             jsr     FRM_ELEMENT
000954r 2  A9 00                lda     #$00
000956r 2  85 A4                sta     CPRTYP
000958r 2               FRMEVL2:
000958r 2  20 D0 00             jsr     CHRGOT
00095Br 2               L2C65:
00095Br 2  38                   sec
00095Cr 2  E9 AC                sbc     #TOKEN_GREATER
00095Er 2  90 17                bcc     L2C81
000960r 2  C9 03                cmp     #$03
000962r 2  B0 13                bcs     L2C81
000964r 2  C9 01                cmp     #$01
000966r 2  2A                   rol     a
000967r 2  49 01                eor     #$01
000969r 2  45 A4                eor     CPRTYP
00096Br 2  C5 A4                cmp     CPRTYP
00096Dr 2  90 61                bcc     SNTXERR
00096Fr 2  85 A4                sta     CPRTYP
000971r 2  20 CA 00             jsr     CHRGET
000974r 2  4C rr rr             jmp     L2C65
000977r 2               L2C81:
000977r 2  A6 A4                ldx     CPRTYP
000979r 2  D0 2C                bne     FRM_RELATIONAL
00097Br 2  B0 7B                bcs     L2D02
00097Dr 2  69 07                adc     #$07
00097Fr 2  90 77                bcc     L2D02
000981r 2  65 66                adc     VALTYP
000983r 2  D0 03                bne     L2C92
000985r 2  4C rr rr             jmp     CAT
000988r 2               L2C92:
000988r 2  69 FF                adc     #$FF
00098Ar 2  85 79                sta     INDEX
00098Cr 2  0A                   asl     a
00098Dr 2  65 79                adc     INDEX
00098Fr 2  A8                   tay
000990r 2               FRM_PRECEDENCE_TEST:
000990r 2  68                   pla
000991r 2  D9 rr rr             cmp     MATHTBL,y
000994r 2  B0 67                bcs     FRM_PERFORM1
000996r 2  20 rr rr             jsr     CHKNUM
000999r 2               L2CA3:
000999r 2  48                   pha
00099Ar 2               L2CA4:
00099Ar 2  20 rr rr             jsr     FRM_RECURSE
00099Dr 2  68                   pla
00099Er 2  A4 A2                ldy     LASTOP
0009A0r 2  10 17                bpl     PREFNC
0009A2r 2  AA                   tax
0009A3r 2  F0 56                beq     GOEX
0009A5r 2  D0 5F                bne     FRM_PERFORM2
0009A7r 2               
0009A7r 2               ; ----------------------------------------------------------------------------
0009A7r 2               ; FOUND ONE OR MORE RELATIONAL OPERATORS <,=,>
0009A7r 2               ; ----------------------------------------------------------------------------
0009A7r 2               FRM_RELATIONAL:
0009A7r 2  46 66                lsr     VALTYP
0009A9r 2  8A                   txa
0009AAr 2  2A                   rol     a
0009ABr 2  A6 D1                ldx     TXTPTR
0009ADr 2  D0 02                bne     L2CBB
0009AFr 2  C6 D2                dec     TXTPTR+1
0009B1r 2               L2CBB:
0009B1r 2  C6 D1                dec     TXTPTR
0009B3r 2  A0 1B                ldy     #$1B
0009B5r 2  85 A4                sta     CPRTYP
0009B7r 2  D0 D7                bne     FRM_PRECEDENCE_TEST
0009B9r 2               PREFNC:
0009B9r 2  D9 rr rr             cmp     MATHTBL,y
0009BCr 2  B0 48                bcs     FRM_PERFORM2
0009BEr 2  90 D9                bcc     L2CA3
0009C0r 2               
0009C0r 2               ; ----------------------------------------------------------------------------
0009C0r 2               ; STACK THIS OPERATION AND CALL FRMEVL FOR
0009C0r 2               ; ANOTHER ONE
0009C0r 2               ; ----------------------------------------------------------------------------
0009C0r 2               FRM_RECURSE:
0009C0r 2  B9 rr rr             lda     MATHTBL+2,y
0009C3r 2  48                   pha
0009C4r 2  B9 rr rr             lda     MATHTBL+1,y
0009C7r 2  48                   pha
0009C8r 2  20 rr rr             jsr     FRM_STACK1
0009CBr 2  A5 A4                lda     CPRTYP
0009CDr 2  4C rr rr             jmp     FRMEVL1
0009D0r 2               SNTXERR:
0009D0r 2  4C rr rr             jmp     SYNERR
0009D3r 2               
0009D3r 2               ; ----------------------------------------------------------------------------
0009D3r 2               ; STACK (FAC)
0009D3r 2               ; THREE ENTRY POINTS:
0009D3r 2               ; 	1, FROM FRMEVL
0009D3r 2               ;	2, FROM "STEP"
0009D3r 2               ;	3, FROM "FOR"
0009D3r 2               ; ----------------------------------------------------------------------------
0009D3r 2               FRM_STACK1:
0009D3r 2  A5 BD                lda     FACSIGN
0009D5r 2  BE rr rr             ldx     MATHTBL,y
0009D8r 2               
0009D8r 2               ; ----------------------------------------------------------------------------
0009D8r 2               ; ENTER HERE FROM "STEP", TO PUSH STEP SIGN AND VALUE
0009D8r 2               ; ----------------------------------------------------------------------------
0009D8r 2               FRM_STACK2:
0009D8r 2  A8                   tay
0009D9r 2  68                   pla
0009DAr 2  85 79                sta     INDEX
0009DCr 2               .ifndef CONFIG_2B
0009DCr 2  E6 79                inc     INDEX ; bug: assumes not on page boundary
0009DEr 2               ; bug exists on AppleSoft II
0009DEr 2               .endif
0009DEr 2  68                   pla
0009DFr 2  85 7A                sta     INDEX+1
0009E1r 2               .ifdef CONFIG_2B
0009E1r 2                       inc     INDEX
0009E1r 2                       bne     LEB69
0009E1r 2                       inc     INDEX+1
0009E1r 2               LEB69:
0009E1r 2               .endif
0009E1r 2  98                   tya
0009E2r 2  48                   pha
0009E3r 2               
0009E3r 2               ; ----------------------------------------------------------------------------
0009E3r 2               ; ENTER HERE FROM "FOR", WITH (INDEX) = STEP,
0009E3r 2               ; TO PUSH INITIAL VALUE OF "FOR" VARIABLE
0009E3r 2               ; ----------------------------------------------------------------------------
0009E3r 2               FRM_STACK3:
0009E3r 2  20 rr rr             jsr     ROUND_FAC
0009E6r 2               .ifndef CONFIG_SMALL
0009E6r 2  A5 BC                lda     FAC+4
0009E8r 2  48                   pha
0009E9r 2               .endif
0009E9r 2  A5 BB                lda     FAC+3
0009EBr 2  48                   pha
0009ECr 2  A5 BA                lda     FAC+2
0009EEr 2  48                   pha
0009EFr 2  A5 B9                lda     FAC+1
0009F1r 2  48                   pha
0009F2r 2  A5 B8                lda     FAC
0009F4r 2  48                   pha
0009F5r 2  6C 79 00             jmp     (INDEX)
0009F8r 2               L2D02:
0009F8r 2  A0 FF                ldy     #$FF
0009FAr 2  68                   pla
0009FBr 2               GOEX:
0009FBr 2  F0 23                beq     EXIT
0009FDr 2               
0009FDr 2               ; ----------------------------------------------------------------------------
0009FDr 2               ; PERFORM STACKED OPERATION
0009FDr 2               ;
0009FDr 2               ; (A) = PRECEDENCE BYTE
0009FDr 2               ; STACK:  1 -- CPRMASK
0009FDr 2               ;	5 -- (ARG)
0009FDr 2               ;	2 -- ADDR OF PERFORMER
0009FDr 2               ; ----------------------------------------------------------------------------
0009FDr 2               FRM_PERFORM1:
0009FDr 2  C9 64                cmp     #$64
0009FFr 2  F0 03                beq     L2D0E
000A01r 2  20 rr rr             jsr     CHKNUM
000A04r 2               L2D0E:
000A04r 2  84 A2                sty     LASTOP
000A06r 2               FRM_PERFORM2:
000A06r 2  68                   pla
000A07r 2  4A                   lsr     a
000A08r 2  85 6B                sta     CPRMASK
000A0Ar 2  68                   pla
000A0Br 2  85 C0                sta     ARG
000A0Dr 2  68                   pla
000A0Er 2  85 C1                sta     ARG+1
000A10r 2  68                   pla
000A11r 2  85 C2                sta     ARG+2
000A13r 2  68                   pla
000A14r 2  85 C3                sta     ARG+3
000A16r 2  68                   pla
000A17r 2               .ifndef CONFIG_SMALL
000A17r 2  85 C4                sta     ARG+4
000A19r 2  68                   pla
000A1Ar 2               .endif
000A1Ar 2  85 C5                sta     ARGSIGN
000A1Cr 2  45 BD                eor     FACSIGN
000A1Er 2  85 C6                sta     SGNCPR
000A20r 2               EXIT:
000A20r 2  A5 B8                lda     FAC
000A22r 2  60                   rts
000A23r 2               
000A23r 2               ; ----------------------------------------------------------------------------
000A23r 2               ; GET ELEMENT IN EXPRESSION
000A23r 2               ;
000A23r 2               ; GET VALUE OF VARIABLE OR NUMBER AT TXTPNT, OR POINT
000A23r 2               ; TO STRING DESCRIPTOR IF A STRING, AND PUT IN FAC.
000A23r 2               ; ----------------------------------------------------------------------------
000A23r 2               FRM_ELEMENT:
000A23r 2  A9 00                lda     #$00
000A25r 2  85 66                sta     VALTYP
000A27r 2               L2D31:
000A27r 2  20 CA 00             jsr     CHRGET
000A2Ar 2  B0 03                bcs     L2D39
000A2Cr 2               L2D36:
000A2Cr 2  4C rr rr             jmp     FIN
000A2Fr 2               L2D39:
000A2Fr 2  20 rr rr             jsr     ISLETC
000A32r 2  B0 67                bcs     FRM_VARIABLE
000A34r 2               .ifdef CONFIG_CBM_ALL
000A34r 2                       cmp     #$FF
000A34r 2                       bne     LCDC1
000A34r 2                       lda     #<CON_PI
000A34r 2                       ldy     #>CON_PI
000A34r 2                       jsr     LOAD_FAC_FROM_YA
000A34r 2                       jmp     CHRGET
000A34r 2               CON_PI:
000A34r 2                       .byte   $82,$49,$0f,$DA,$A1
000A34r 2               LCDC1:
000A34r 2               .endif
000A34r 2  C9 2E                cmp     #$2E
000A36r 2  F0 F4                beq     L2D36
000A38r 2  C9 A6                cmp     #TOKEN_MINUS
000A3Ar 2  F0 58                beq     MIN
000A3Cr 2  C9 A5                cmp     #TOKEN_PLUS
000A3Er 2  F0 E7                beq     L2D31
000A40r 2  C9 22                cmp     #$22
000A42r 2  D0 0F                bne     NOT_
000A44r 2               
000A44r 2               ; ----------------------------------------------------------------------------
000A44r 2               ; STRING CONSTANT ELEMENT
000A44r 2               ;
000A44r 2               ; SET Y,A = (TXTPTR)+CARRY
000A44r 2               ; ----------------------------------------------------------------------------
000A44r 2               STRTXT:
000A44r 2  A5 D1                lda     TXTPTR
000A46r 2  A4 D2                ldy     TXTPTR+1
000A48r 2  69 00                adc     #$00
000A4Ar 2  90 01                bcc     L2D57
000A4Cr 2  C8                   iny
000A4Dr 2               L2D57:
000A4Dr 2  20 rr rr             jsr     STRLIT
000A50r 2  4C rr rr             jmp     POINT
000A53r 2               
000A53r 2               ; ----------------------------------------------------------------------------
000A53r 2               ; "NOT" FUNCTION
000A53r 2               ; IF FAC=0, RETURN FAC=1
000A53r 2               ; IF FAC<>0, RETURN FAC=0
000A53r 2               ; ----------------------------------------------------------------------------
000A53r 2               NOT_:
000A53r 2  C9 A3                cmp     #TOKEN_NOT
000A55r 2  D0 13                bne     L2D74
000A57r 2  A0 18                ldy     #$18
000A59r 2  D0 3B                bne     EQUL
000A5Br 2               
000A5Br 2               ; ----------------------------------------------------------------------------
000A5Br 2               ; COMPARISON FOR EQUALITY (= OPERATOR)
000A5Br 2               ; ALSO USED TO EVALUATE "NOT" FUNCTION
000A5Br 2               ; ----------------------------------------------------------------------------
000A5Br 2               EQUOP:
000A5Br 2  20 rr rr             jsr     AYINT
000A5Er 2  A5 BC                lda     FAC_LAST
000A60r 2  49 FF                eor     #$FF
000A62r 2  A8                   tay
000A63r 2  A5 BB                lda     FAC_LAST-1
000A65r 2  49 FF                eor     #$FF
000A67r 2  4C rr rr             jmp     GIVAYF
000A6Ar 2               L2D74:
000A6Ar 2               .ifdef SYM1
000A6Ar 2                       cmp     #TOKEN_USR
000A6Ar 2                       bne     LCC8A
000A6Ar 2                       jmp     LCDBD
000A6Ar 2               LCC8A:
000A6Ar 2                       cmp     #$26
000A6Ar 2                       bne     LCC91
000A6Ar 2                       jmp     LCDFE
000A6Ar 2               LCC91:
000A6Ar 2               .endif
000A6Ar 2  C9 A0                cmp     #TOKEN_FN
000A6Cr 2  D0 03                bne     L2D7B
000A6Er 2  4C rr rr             jmp     L31F3
000A71r 2               L2D7B:
000A71r 2  C9 AF                cmp     #TOKEN_SGN
000A73r 2  90 03                bcc     PARCHK
000A75r 2  4C rr rr             jmp     UNARY
000A78r 2               
000A78r 2               ; ----------------------------------------------------------------------------
000A78r 2               ; EVALUATE "(EXPRESSION)"
000A78r 2               ; ----------------------------------------------------------------------------
000A78r 2               PARCHK:
000A78r 2  20 rr rr             jsr     CHKOPN
000A7Br 2  20 rr rr             jsr     FRMEVL
000A7Er 2               CHKCLS:
000A7Er 2  A9 29                lda     #$29
000A80r 2  2C                   .byte   $2C
000A81r 2               CHKOPN:
000A81r 2  A9 28                lda     #$28
000A83r 2  2C                   .byte   $2C
000A84r 2               CHKCOM:
000A84r 2  A9 2C                lda     #$2C
000A86r 2               
000A86r 2               ; ----------------------------------------------------------------------------
000A86r 2               ; UNLESS CHAR AT TXTPTR = (A), SYNTAX ERROR
000A86r 2               ; ----------------------------------------------------------------------------
000A86r 2               SYNCHR:	; XXX all CBM code calls SYNCHR instead of CHKCOM
000A86r 2  A0 00                ldy     #$00
000A88r 2  D1 D1                cmp     (TXTPTR),y
000A8Ar 2  D0 03                bne     SYNERR
000A8Cr 2  4C CA 00             jmp     CHRGET
000A8Fr 2               ; ----------------------------------------------------------------------------
000A8Fr 2               SYNERR:
000A8Fr 2  A2 10                ldx     #ERR_SYNTAX
000A91r 2  4C rr rr             jmp     ERROR
000A94r 2               ; ----------------------------------------------------------------------------
000A94r 2               MIN:
000A94r 2  A0 15                ldy     #$15
000A96r 2               EQUL:
000A96r 2  68                   pla
000A97r 2  68                   pla
000A98r 2  4C rr rr             jmp     L2CA4
000A9Br 2               ; ----------------------------------------------------------------------------
000A9Br 2               FRM_VARIABLE:
000A9Br 2  20 rr rr             jsr     PTRGET
000A9Er 2               FRM_VARIABLE_CALL	= *-1
000A9Er 2  85 BB                sta     FAC_LAST-1
000AA0r 2  84 BC                sty     FAC_LAST
000AA2r 2               .ifdef CONFIG_CBM_ALL
000AA2r 2                       lda     VARNAM
000AA2r 2                       ldy     VARNAM+1
000AA2r 2               .endif
000AA2r 2  A6 66                ldx     VALTYP
000AA4r 2  F0 05                beq     L2DB1
000AA6r 2               .ifdef CONFIG_CBM_ALL
000AA6r 2                 .ifdef CONFIG_CBM1_PATCHES
000AA6r 2                       jmp     PATCH2
000AA6r 2                       clc
000AA6r 2               LCE3B:
000AA6r 2                 .else
000AA6r 2                       ldx     #$00
000AA6r 2                       stx     STRNG1+1
000AA6r 2                       bit     FAC+4
000AA6r 2                       bpl     LCE53
000AA6r 2                       cmp     #$54	; T
000AA6r 2                       bne     LCE53
000AA6r 2                 .endif
000AA6r 2                       cpy     #$C9	; I$
000AA6r 2                       bne     LCE53
000AA6r 2                       jsr     LCE76
000AA6r 2                       sty     EXPON
000AA6r 2                       dey
000AA6r 2                       sty     STRNG2
000AA6r 2                       ldy     #$06
000AA6r 2                       sty     INDX
000AA6r 2                       ldy     #$24
000AA6r 2                       jsr     LDD3A
000AA6r 2                       jmp     LD353
000AA6r 2               LCE53:
000AA6r 2               .endif
000AA6r 2               .ifdef CONFIG_2
000AA6r 2                 .ifndef CBM2
000AA6r 2               ; bugfix?
000AA6r 2               ; fixed on AppleSoft II, not on any CBM
000AA6r 2  A2 00                ldx     #$00
000AA8r 2  86 C7                stx     STRNG1+1
000AAAr 2                 .endif
000AAAr 2               .endif
000AAAr 2  60                   rts
000AABr 2               L2DB1:
000AABr 2               .ifndef CONFIG_SMALL
000AABr 2  A6 67                ldx     VALTYP+1
000AADr 2  10 0D                bpl     L2DC2
000AAFr 2  A0 00                ldy     #$00
000AB1r 2  B1 BB                lda     (FAC+3),y
000AB3r 2  AA                   tax
000AB4r 2  C8                   iny
000AB5r 2  B1 BB                lda     (FAC+3),y
000AB7r 2  A8                   tay
000AB8r 2  8A                   txa
000AB9r 2  4C rr rr             jmp     GIVAYF
000ABCr 2               L2DC2:
000ABCr 2               .endif
000ABCr 2               .ifdef CONFIG_CBM1_PATCHES
000ABCr 2                       jmp     PATCH3
000ABCr 2                       .byte   $19
000ABCr 2               .endif
000ABCr 2               .ifdef CBM2
000ABCr 2                       bit     FAC+4
000ABCr 2                       bpl     LCE90
000ABCr 2                       cmp     #$54
000ABCr 2                       bne     LCE82
000ABCr 2               .endif
000ABCr 2               .ifndef CONFIG_CBM_ALL
000ABCr 2  4C rr rr             jmp     LOAD_FAC_FROM_YA
000ABFr 2               .endif
000ABFr 2               .ifdef CONFIG_CBM_ALL
000ABFr 2               LCE69:
000ABFr 2                       cpy     #$49
000ABFr 2               .ifdef CBM1
000ABFr 2                       bne     LCE82
000ABFr 2               .else
000ABFr 2                       bne     LCE90
000ABFr 2               .endif
000ABFr 2                       jsr     LCE76
000ABFr 2                       tya
000ABFr 2                       ldx     #$A0
000ABFr 2                       jmp     LDB21
000ABFr 2               LCE76:
000ABFr 2               .ifdef CBM1
000ABFr 2                       lda     #$FE
000ABFr 2                       ldy     #$01
000ABFr 2               .else
000ABFr 2                       lda     #$8B
000ABFr 2                       ldy     #$00
000ABFr 2               .endif
000ABFr 2                       sei
000ABFr 2                       jsr     LOAD_FAC_FROM_YA
000ABFr 2                       cli
000ABFr 2                       sty     FAC+1
000ABFr 2                       rts
000ABFr 2               LCE82:
000ABFr 2                       cmp     #$53
000ABFr 2                       bne     LCE90
000ABFr 2                       cpy     #$54
000ABFr 2                       bne     LCE90
000ABFr 2                       lda     Z96
000ABFr 2                       jmp     FLOAT
000ABFr 2               LCE90:
000ABFr 2                       lda     FAC+3
000ABFr 2                       ldy     FAC+4
000ABFr 2                       jmp     LOAD_FAC_FROM_YA
000ABFr 2               .endif
000ABFr 2               
000ABFr 2               ; ----------------------------------------------------------------------------
000ABFr 2               UNARY:
000ABFr 2  0A                   asl     a
000AC0r 2  48                   pha
000AC1r 2  AA                   tax
000AC2r 2  20 CA 00             jsr     CHRGET
000AC5r 2  E0 85                cpx     #<(TOKEN_LEFTSTR*2-1)
000AC7r 2  90 20                bcc     L2DEF
000AC9r 2  20 rr rr             jsr     CHKOPN
000ACCr 2  20 rr rr             jsr     FRMEVL
000ACFr 2  20 rr rr             jsr     CHKCOM
000AD2r 2  20 rr rr             jsr     CHKSTR
000AD5r 2  68                   pla
000AD6r 2  AA                   tax
000AD7r 2  A5 BC                lda     FAC_LAST
000AD9r 2  48                   pha
000ADAr 2  A5 BB                lda     FAC_LAST-1
000ADCr 2  48                   pha
000ADDr 2  8A                   txa
000ADEr 2  48                   pha
000ADFr 2  20 rr rr             jsr     GETBYT
000AE2r 2  68                   pla
000AE3r 2  A8                   tay
000AE4r 2  8A                   txa
000AE5r 2  48                   pha
000AE6r 2  4C rr rr             jmp     L2DF4
000AE9r 2               L2DEF:
000AE9r 2  20 rr rr             jsr     PARCHK
000AECr 2  68                   pla
000AEDr 2  A8                   tay
000AEEr 2               L2DF4:
000AEEr 2  B9 rr rr             lda     UNFNC-TOKEN_SGN-TOKEN_SGN+$100,y
000AF1r 2  85 AC                sta     JMPADRS+1
000AF3r 2  B9 rr rr             lda     UNFNC-TOKEN_SGN-TOKEN_SGN+$101,y
000AF6r 2  85 AD                sta     JMPADRS+2
000AF8r 2               .ifdef KBD
000AF8r 2                       jsr     LF47D
000AF8r 2               .else
000AF8r 2  20 AB 00             jsr     JMPADRS
000AFBr 2               .endif
000AFBr 2  4C rr rr             jmp     CHKNUM
000AFEr 2               
000AFEr 2               ; ----------------------------------------------------------------------------
000AFEr 2               OR:
000AFEr 2  A0 FF                ldy     #$FF
000B00r 2  2C                   .byte   $2C
000B01r 2               ; ----------------------------------------------------------------------------
000B01r 2               TAND:
000B01r 2  A0 00                ldy     #$00
000B03r 2  84 64                sty     EOLPNTR
000B05r 2  20 rr rr             jsr     AYINT
000B08r 2  A5 BB                lda     FAC_LAST-1
000B0Ar 2  45 64                eor     EOLPNTR
000B0Cr 2  85 62                sta     CHARAC
000B0Er 2  A5 BC                lda     FAC_LAST
000B10r 2  45 64                eor     EOLPNTR
000B12r 2  85 63                sta     ENDCHR
000B14r 2  20 rr rr             jsr     COPY_ARG_TO_FAC
000B17r 2  20 rr rr             jsr     AYINT
000B1Ar 2  A5 BC                lda     FAC_LAST
000B1Cr 2  45 64                eor     EOLPNTR
000B1Er 2  25 63                and     ENDCHR
000B20r 2  45 64                eor     EOLPNTR
000B22r 2  A8                   tay
000B23r 2  A5 BB                lda     FAC_LAST-1
000B25r 2  45 64                eor     EOLPNTR
000B27r 2  25 62                and     CHARAC
000B29r 2  45 64                eor     EOLPNTR
000B2Br 2  4C rr rr             jmp     GIVAYF
000B2Er 2               
000B2Er 2               ; ----------------------------------------------------------------------------
000B2Er 2               ; PERFORM RELATIONAL OPERATIONS
000B2Er 2               ; ----------------------------------------------------------------------------
000B2Er 2               RELOPS:
000B2Er 2  20 rr rr             jsr     CHKVAL
000B31r 2  B0 13                bcs     STRCMP
000B33r 2  A5 C5                lda     ARGSIGN
000B35r 2  09 7F                ora     #$7F
000B37r 2  25 C1                and     ARG+1
000B39r 2  85 C1                sta     ARG+1
000B3Br 2  A9 C0                lda     #<ARG
000B3Dr 2  A0 00                ldy     #$00
000B3Fr 2  20 rr rr             jsr     FCOMP
000B42r 2  AA                   tax
000B43r 2  4C rr rr             jmp     NUMCMP
000B46r 2               
000B46r 2               ; ----------------------------------------------------------------------------
000B46r 2               ; STRING COMPARISON
000B46r 2               ; ----------------------------------------------------------------------------
000B46r 2               STRCMP:
000B46r 2  A9 00                lda     #$00
000B48r 2  85 66                sta     VALTYP
000B4Ar 2  C6 A4                dec     CPRTYP
000B4Cr 2  20 rr rr             jsr     FREFAC
000B4Fr 2  85 B8                sta     FAC
000B51r 2  86 B9                stx     FAC+1
000B53r 2  84 BA                sty     FAC+2
000B55r 2  A5 C3                lda     ARG_LAST-1
000B57r 2  A4 C4                ldy     ARG_LAST
000B59r 2  20 rr rr             jsr     FRETMP
000B5Cr 2  86 C3                stx     ARG_LAST-1
000B5Er 2  84 C4                sty     ARG_LAST
000B60r 2  AA                   tax
000B61r 2  38                   sec
000B62r 2  E5 B8                sbc     FAC
000B64r 2  F0 08                beq     L2E74
000B66r 2  A9 01                lda     #$01
000B68r 2  90 04                bcc     L2E74
000B6Ar 2  A6 B8                ldx     FAC
000B6Cr 2  A9 FF                lda     #$FF
000B6Er 2               L2E74:
000B6Er 2  85 BD                sta     FACSIGN
000B70r 2  A0 FF                ldy     #$FF
000B72r 2  E8                   inx
000B73r 2               STRCMP1:
000B73r 2  C8                   iny
000B74r 2  CA                   dex
000B75r 2  D0 07                bne     L2E84
000B77r 2  A6 BD                ldx     FACSIGN
000B79r 2               NUMCMP:
000B79r 2  30 0F                bmi     CMPDONE
000B7Br 2  18                   clc
000B7Cr 2  90 0C                bcc     CMPDONE
000B7Er 2               L2E84:
000B7Er 2  B1 C3                lda     (ARG_LAST-1),y
000B80r 2  D1 B9                cmp     (FAC+1),y
000B82r 2  F0 EF                beq     STRCMP1
000B84r 2  A2 FF                ldx     #$FF
000B86r 2  B0 02                bcs     CMPDONE
000B88r 2  A2 01                ldx     #$01
000B8Ar 2               CMPDONE:
000B8Ar 2  E8                   inx
000B8Br 2  8A                   txa
000B8Cr 2  2A                   rol     a
000B8Dr 2  25 6B                and     CPRMASK
000B8Fr 2  F0 02                beq     L2E99
000B91r 2  A9 FF                lda     #$FF
000B93r 2               L2E99:
000B93r 2  4C rr rr             jmp     FLOAT
000B96r 2               
000B96r 2               .ifdef SYM1
000B96r 2               LCDBD:
000B96r 2                       jsr     CHRGET
000B96r 2                       jsr     CHKOPN
000B96r 2                       jsr     FRMEVL
000B96r 2                       jsr     CHRGOT
000B96r 2                       cmp     #$29
000B96r 2                       beq     LCDF1
000B96r 2                       jsr     AYINT
000B96r 2                       lda     FAC+4
000B96r 2                       ldy     FAC+3
000B96r 2                       sta     USR+1
000B96r 2                       sty     USR+2
000B96r 2               LCDD8:
000B96r 2                       jsr     CHKCOM
000B96r 2                       jsr     FRMEVL
000B96r 2                       jsr     CHRGOT
000B96r 2                       cmp     #$29
000B96r 2                       beq     LCDF1
000B96r 2                       jsr     AYINT
000B96r 2                       lda     FAC+3
000B96r 2                       pha
000B96r 2                       lda     FAC+4
000B96r 2                       pha
000B96r 2                       jmp     LCDD8
000B96r 2               
000B96r 2               LCDF1:
000B96r 2                       jsr     CHRGET
000B96r 2                       jsr     AYINT
000B96r 2                       lda     FAC+3
000B96r 2                       ldy     FAC+4
000B96r 2                       jmp     USR
000B96r 2               
000B96r 2               LCDFE:
000B96r 2                       lda     ZD4
000B96r 2                       pha
000B96r 2                       lda     ZD3
000B96r 2                       pha
000B96r 2                       jsr     CHRGET
000B96r 2                       cmp     #$22
000B96r 2                       bne     LCE49
000B96r 2                       jsr     CHRGET
000B96r 2                       jsr     LCE2B
000B96r 2                       tax
000B96r 2                       jsr     CHRGOT
000B96r 2                       jsr     LCE2B
000B96r 2                       pha
000B96r 2                       jsr     CHRGOT
000B96r 2                       cmp     #$22
000B96r 2                       bne     LCE48
000B96r 2                       jsr     CHRGET
000B96r 2                       pla
000B96r 2                       tay
000B96r 2                       pla
000B96r 2                       pla
000B96r 2                       txa
000B96r 2                       jmp     GIVAYF
000B96r 2               
000B96r 2               LCE2B:
000B96r 2                       jsr     ASCNIB
000B96r 2                       bcs     LCE47
000B96r 2                       pha
000B96r 2                       jsr     CHRGET
000B96r 2                       jsr     ASCNIB
000B96r 2                       sta     FAC+4
000B96r 2                       bcs     LCE46
000B96r 2                       jsr     CHRGET
000B96r 2                       pla
000B96r 2                       asl     a
000B96r 2                       asl     a
000B96r 2                       asl     a
000B96r 2                       asl     a
000B96r 2                       ora     FAC+4
000B96r 2                       rts
000B96r 2               
000B96r 2               LCE46:
000B96r 2                       pla
000B96r 2               LCE47:
000B96r 2                       pla
000B96r 2               LCE48:
000B96r 2                       pla
000B96r 2               LCE49:
000B96r 2                       pla
000B96r 2                       sta     ZD3
000B96r 2                       pla
000B96r 2                       sta     ZD4
000B96r 2                       jmp     ZERO_FAC
000B96r 2               .endif
000B96r 2               
000B96r 1               .include "var.s"
000B96r 2               .segment "CODE"
000B96r 2               
000B96r 2               ; ----------------------------------------------------------------------------
000B96r 2               ; "DIM" STATEMENT
000B96r 2               ; ----------------------------------------------------------------------------
000B96r 2               NXDIM:
000B96r 2  20 rr rr             jsr     CHKCOM
000B99r 2               DIM:
000B99r 2  AA                   tax
000B9Ar 2  20 rr rr             jsr     PTRGET2
000B9Dr 2  20 D0 00             jsr     CHRGOT
000BA0r 2  D0 F4                bne     NXDIM
000BA2r 2  60                   rts
000BA3r 2               
000BA3r 2               ; ----------------------------------------------------------------------------
000BA3r 2               ; PTRGET -- GENERAL VARIABLE SCAN
000BA3r 2               ;
000BA3r 2               ; SCANS VARIABLE NAME AT TXTPTR, AND SEARCHES THE
000BA3r 2               ; VARTAB AND ARYTAB FOR THE NAME.
000BA3r 2               ; IF NOT FOUND, CREATE VARIABLE OF APPROPRIATE TYPE.
000BA3r 2               ; RETURN WITH ADDRESS IN VARPNT AND Y,A
000BA3r 2               ;
000BA3r 2               ; ACTUAL ACTIVITY CONTROLLED SOMEWHAT BY TWO FLAGS:
000BA3r 2               ;	DIMFLG -- NONZERO IF CALLED FROM "DIM"
000BA3r 2               ;		ELSE = 0
000BA3r 2               ;
000BA3r 2               ;	SUBFLG -- = $00
000BA3r 2               ;		= $40 IF CALLED FROM "GETARYPT"
000BA3r 2               ; ----------------------------------------------------------------------------
000BA3r 2               PTRGET:
000BA3r 2  A2 00                ldx     #$00
000BA5r 2  20 D0 00             jsr     CHRGOT
000BA8r 2               PTRGET2:
000BA8r 2  86 65                stx     DIMFLG
000BAAr 2               PTRGET3:
000BAAr 2  85 9C                sta     VARNAM
000BACr 2  20 D0 00             jsr     CHRGOT
000BAFr 2  20 rr rr             jsr     ISLETC
000BB2r 2  B0 03                bcs     NAMOK
000BB4r 2               SYNERR3:
000BB4r 2  4C rr rr             jmp     SYNERR
000BB7r 2               NAMOK:
000BB7r 2  A2 00                ldx     #$00
000BB9r 2  86 66                stx     VALTYP
000BBBr 2               .ifndef CONFIG_SMALL
000BBBr 2  86 67                stx     VALTYP+1
000BBDr 2               .endif
000BBDr 2  20 CA 00             jsr     CHRGET
000BC0r 2  90 05                bcc     L2ECD
000BC2r 2  20 rr rr             jsr     ISLETC
000BC5r 2  90 0B                bcc     L2ED8
000BC7r 2               L2ECD:
000BC7r 2  AA                   tax
000BC8r 2               L2ECE:
000BC8r 2  20 CA 00             jsr     CHRGET
000BCBr 2  90 FB                bcc     L2ECE
000BCDr 2  20 rr rr             jsr     ISLETC
000BD0r 2  B0 F6                bcs     L2ECE
000BD2r 2               L2ED8:
000BD2r 2  C9 24                cmp     #$24
000BD4r 2               .ifdef CONFIG_SMALL
000BD4r 2                       bne     L2EF9
000BD4r 2               .else
000BD4r 2  D0 06                bne     L2EE2
000BD6r 2               .endif
000BD6r 2  A9 FF                lda     #$FF
000BD8r 2  85 66                sta     VALTYP
000BDAr 2               .ifndef CONFIG_SMALL
000BDAr 2  D0 10                bne     L2EF2
000BDCr 2               L2EE2:
000BDCr 2  C9 25                cmp     #$25
000BDEr 2  D0 13                bne     L2EF9
000BE0r 2  A5 69                lda     SUBFLG
000BE2r 2  D0 D0                bne     SYNERR3
000BE4r 2  A9 80                lda     #$80
000BE6r 2  85 67                sta     VALTYP+1
000BE8r 2  05 9C                ora     VARNAM
000BEAr 2  85 9C                sta     VARNAM
000BECr 2               L2EF2:
000BECr 2               .endif
000BECr 2  8A                   txa
000BEDr 2  09 80                ora     #$80
000BEFr 2  AA                   tax
000BF0r 2  20 CA 00             jsr     CHRGET
000BF3r 2               L2EF9:
000BF3r 2  86 9D                stx     VARNAM+1
000BF5r 2  38                   sec
000BF6r 2  05 69                ora     SUBFLG
000BF8r 2  E9 28                sbc     #$28
000BFAr 2  D0 03                bne     L2F05
000BFCr 2  4C rr rr             jmp     ARRAY
000BFFr 2               L2F05:
000BFFr 2  A9 00                lda     #$00
000C01r 2  85 69                sta     SUBFLG
000C03r 2  A5 84                lda     VARTAB
000C05r 2  A6 85                ldx     VARTAB+1
000C07r 2  A0 00                ldy     #$00
000C09r 2               L2F0F:
000C09r 2  86 B7                stx     LOWTR+1
000C0Br 2               L2F11:
000C0Br 2  85 B6                sta     LOWTR
000C0Dr 2  E4 87                cpx     ARYTAB+1
000C0Fr 2  D0 04                bne     L2F1B
000C11r 2  C5 86                cmp     ARYTAB
000C13r 2  F0 22                beq     NAMENOTFOUND
000C15r 2               L2F1B:
000C15r 2  A5 9C                lda     VARNAM
000C17r 2  D1 B6                cmp     (LOWTR),y
000C19r 2  D0 08                bne     L2F29
000C1Br 2  A5 9D                lda     VARNAM+1
000C1Dr 2  C8                   iny
000C1Er 2  D1 B6                cmp     (LOWTR),y
000C20r 2  F0 62                beq     SET_VARPNT_AND_YA
000C22r 2  88                   dey
000C23r 2               L2F29:
000C23r 2  18                   clc
000C24r 2  A5 B6                lda     LOWTR
000C26r 2  69 07                adc     #BYTES_PER_VARIABLE
000C28r 2  90 E1                bcc     L2F11
000C2Ar 2  E8                   inx
000C2Br 2  D0 DC                bne     L2F0F
000C2Dr 2               
000C2Dr 2               ; ----------------------------------------------------------------------------
000C2Dr 2               ; CHECK IF (A) IS ASCII LETTER A-Z
000C2Dr 2               ;
000C2Dr 2               ; RETURN CARRY = 1 IF A-Z
000C2Dr 2               ;	= 0 IF NOT
000C2Dr 2               ; ----------------------------------------------------------------------------
000C2Dr 2               ISLETC:
000C2Dr 2  C9 41                cmp     #$41
000C2Fr 2  90 05                bcc     L2F3C
000C31r 2  E9 5B                sbc     #$5B
000C33r 2  38                   sec
000C34r 2  E9 A5                sbc     #$A5
000C36r 2               L2F3C:
000C36r 2  60                   rts
000C37r 2               
000C37r 2               ; ----------------------------------------------------------------------------
000C37r 2               ; VARIABLE NOT FOUND, SO MAKE ONE
000C37r 2               ; ----------------------------------------------------------------------------
000C37r 2               NAMENOTFOUND:
000C37r 2  68                   pla
000C38r 2  48                   pha
000C39r 2  C9 rr                cmp     #<FRM_VARIABLE_CALL
000C3Br 2  D0 05                bne     MAKENEWVARIABLE
000C3Dr 2               .ifdef CONFIG_SAFE_NAMENOTFOUND
000C3Dr 2                       tsx
000C3Dr 2                       lda     STACK+2,x
000C3Dr 2                       cmp     #>FRM_VARIABLE_CALL
000C3Dr 2                       bne     MAKENEWVARIABLE
000C3Dr 2               .endif
000C3Dr 2               LD015:
000C3Dr 2  A9 rr                lda     #<C_ZERO
000C3Fr 2  A0 rr                ldy     #>C_ZERO
000C41r 2  60                   rts
000C42r 2               
000C42r 2               ; ----------------------------------------------------------------------------
000C42r 2               .ifndef CONFIG_2
000C42r 2               C_ZERO:
000C42r 2                       .byte   $00,$00
000C42r 2               .endif
000C42r 2               
000C42r 2               ; ----------------------------------------------------------------------------
000C42r 2               ; MAKE A NEW SIMPLE VARIABLE
000C42r 2               ;
000C42r 2               ; MOVE ARRAYS UP 7 BYTES TO MAKE ROOM FOR NEW VARIABLE
000C42r 2               ; ENTER 7-BYTE VARIABLE DATA IN THE HOLE
000C42r 2               ; ----------------------------------------------------------------------------
000C42r 2               MAKENEWVARIABLE:
000C42r 2               .ifdef CONFIG_CBM_ALL
000C42r 2                       lda     VARNAM
000C42r 2                       ldy     VARNAM+1
000C42r 2                       cmp     #$54
000C42r 2                       bne     LD02F
000C42r 2                       cpy     #$C9
000C42r 2                       beq     LD015
000C42r 2                       cpy     #$49
000C42r 2                       bne     LD02F
000C42r 2               LD02C:
000C42r 2                       jmp     SYNERR
000C42r 2               LD02F:
000C42r 2                       cmp     #$53
000C42r 2                       bne     LD037
000C42r 2                       cpy     #$54
000C42r 2                       beq     LD02C
000C42r 2               LD037:
000C42r 2               .endif
000C42r 2  A5 86                lda     ARYTAB
000C44r 2  A4 87                ldy     ARYTAB+1
000C46r 2  85 B6                sta     LOWTR
000C48r 2  84 B7                sty     LOWTR+1
000C4Ar 2  A5 88                lda     STREND
000C4Cr 2  A4 89                ldy     STREND+1
000C4Er 2  85 B1                sta     HIGHTR
000C50r 2  84 B2                sty     HIGHTR+1
000C52r 2  18                   clc
000C53r 2  69 07                adc     #BYTES_PER_VARIABLE
000C55r 2  90 01                bcc     L2F68
000C57r 2  C8                   iny
000C58r 2               L2F68:
000C58r 2  85 AF                sta     HIGHDS
000C5Ar 2  84 B0                sty     HIGHDS+1
000C5Cr 2  20 rr rr             jsr     BLTU
000C5Fr 2  A5 AF                lda     HIGHDS
000C61r 2  A4 B0                ldy     HIGHDS+1
000C63r 2  C8                   iny
000C64r 2  85 86                sta     ARYTAB
000C66r 2  84 87                sty     ARYTAB+1
000C68r 2  A0 00                ldy     #$00
000C6Ar 2  A5 9C                lda     VARNAM
000C6Cr 2  91 B6                sta     (LOWTR),y
000C6Er 2  C8                   iny
000C6Fr 2  A5 9D                lda     VARNAM+1
000C71r 2  91 B6                sta     (LOWTR),y
000C73r 2  A9 00                lda     #$00
000C75r 2  C8                   iny
000C76r 2  91 B6                sta     (LOWTR),y
000C78r 2  C8                   iny
000C79r 2  91 B6                sta     (LOWTR),y
000C7Br 2  C8                   iny
000C7Cr 2  91 B6                sta     (LOWTR),y
000C7Er 2  C8                   iny
000C7Fr 2  91 B6                sta     (LOWTR),y
000C81r 2               .ifndef CONFIG_SMALL
000C81r 2  C8                   iny
000C82r 2  91 B6                sta     (LOWTR),y
000C84r 2               .endif
000C84r 2               
000C84r 2               ; ----------------------------------------------------------------------------
000C84r 2               ; PUT ADDRESS OF VALUE OF VARIABLE IN VARPNT AND Y,A
000C84r 2               ; ----------------------------------------------------------------------------
000C84r 2               SET_VARPNT_AND_YA:
000C84r 2  A5 B6                lda     LOWTR
000C86r 2  18                   clc
000C87r 2  69 02                adc     #$02
000C89r 2  A4 B7                ldy     LOWTR+1
000C8Br 2  90 01                bcc     L2F9E
000C8Dr 2  C8                   iny
000C8Er 2               L2F9E:
000C8Er 2  85 9E                sta     VARPNT
000C90r 2  84 9F                sty     VARPNT+1
000C92r 2  60                   rts
000C93r 2               
000C93r 1               .include "array.s"
000C93r 2               .segment "CODE"
000C93r 2               
000C93r 2               ; ----------------------------------------------------------------------------
000C93r 2               ; COMPUTE ADDRESS OF FIRST VALUE IN ARRAY
000C93r 2               ; ARYPNT = (LOWTR) + #DIMS*2 + 5
000C93r 2               ; ----------------------------------------------------------------------------
000C93r 2               GETARY:
000C93r 2  A5 64                lda     EOLPNTR
000C95r 2  0A                   asl     a
000C96r 2  69 05                adc     #$05
000C98r 2  65 B6                adc     LOWTR
000C9Ar 2  A4 B7                ldy     LOWTR+1
000C9Cr 2  90 01                bcc     L2FAF
000C9Er 2  C8                   iny
000C9Fr 2               L2FAF:
000C9Fr 2  85 AF                sta     HIGHDS
000CA1r 2  84 B0                sty     HIGHDS+1
000CA3r 2  60                   rts
000CA4r 2               
000CA4r 2               ; ----------------------------------------------------------------------------
000CA4r 2               NEG32768:
000CA4r 2  90 80 00 00          .byte   $90,$80,$00,$00
000CA8r 2               
000CA8r 2               .ifdef CONFIG_2C
000CA8r 2               		.byte	$00; bugfix: short number
000CA8r 2               .endif
000CA8r 2               
000CA8r 2               ; ----------------------------------------------------------------------------
000CA8r 2               ; EVALUATE NUMERIC FORMULA AT TXTPTR
000CA8r 2               ; CONVERTING RESULT TO INTEGER 0 <= X <= 32767
000CA8r 2               ; IN FAC+3,4
000CA8r 2               ; ----------------------------------------------------------------------------
000CA8r 2               MAKINT:
000CA8r 2  20 CA 00             jsr     CHRGET
000CABr 2               .ifdef CONFIG_2
000CABr 2  20 rr rr             jsr     FRMEVL
000CAEr 2               .else
000CAEr 2                       jsr     FRMNUM
000CAEr 2               .endif
000CAEr 2               
000CAEr 2               ; ----------------------------------------------------------------------------
000CAEr 2               ; CONVERT FAC TO INTEGER
000CAEr 2               ; MUST BE POSITIVE AND LESS THAN 32768
000CAEr 2               ; ----------------------------------------------------------------------------
000CAEr 2               MKINT:
000CAEr 2               .ifdef CONFIG_2
000CAEr 2  20 rr rr             jsr     CHKNUM
000CB1r 2               .endif
000CB1r 2  A5 BD                lda     FACSIGN
000CB3r 2  30 0D                bmi     MI1
000CB5r 2               
000CB5r 2               ; ----------------------------------------------------------------------------
000CB5r 2               ; CONVERT FAC TO INTEGER
000CB5r 2               ; MUST BE -32767 <= FAC <= 32767
000CB5r 2               ; ----------------------------------------------------------------------------
000CB5r 2               AYINT:
000CB5r 2  A5 B8                lda     FAC
000CB7r 2  C9 90                cmp     #$90
000CB9r 2  90 09                bcc     MI2
000CBBr 2  A9 rr                lda     #<NEG32768
000CBDr 2  A0 rr                ldy     #>NEG32768
000CBFr 2  20 rr rr             jsr     FCOMP
000CC2r 2               MI1:
000CC2r 2  D0 7A                bne     IQERR
000CC4r 2               MI2:
000CC4r 2  4C rr rr             jmp     QINT
000CC7r 2               
000CC7r 2               ; ----------------------------------------------------------------------------
000CC7r 2               ; LOCATE ARRAY ELEMENT OR CREATE AN ARRAY
000CC7r 2               ; ----------------------------------------------------------------------------
000CC7r 2               ARRAY:
000CC7r 2  A5 65                lda     DIMFLG
000CC9r 2               .ifndef CONFIG_SMALL
000CC9r 2  05 67                ora     VALTYP+1
000CCBr 2               .endif
000CCBr 2  48                   pha
000CCCr 2  A5 66                lda     VALTYP
000CCEr 2  48                   pha
000CCFr 2  A0 00                ldy     #$00
000CD1r 2               L2FDE:
000CD1r 2  98                   tya
000CD2r 2  48                   pha
000CD3r 2  A5 9D                lda     VARNAM+1
000CD5r 2  48                   pha
000CD6r 2  A5 9C                lda     VARNAM
000CD8r 2  48                   pha
000CD9r 2  20 rr rr             jsr     MAKINT
000CDCr 2  68                   pla
000CDDr 2  85 9C                sta     VARNAM
000CDFr 2  68                   pla
000CE0r 2  85 9D                sta     VARNAM+1
000CE2r 2  68                   pla
000CE3r 2  A8                   tay
000CE4r 2  BA                   tsx
000CE5r 2  BD 02 01             lda     STACK+2,x
000CE8r 2  48                   pha
000CE9r 2  BD 01 01             lda     STACK+1,x
000CECr 2  48                   pha
000CEDr 2  A5 BB                lda     FAC_LAST-1
000CEFr 2  9D 02 01             sta     STACK+2,x
000CF2r 2  A5 BC                lda     FAC_LAST
000CF4r 2  9D 01 01             sta     STACK+1,x
000CF7r 2  C8                   iny
000CF8r 2  20 D0 00             jsr     CHRGOT
000CFBr 2  C9 2C                cmp     #$2C
000CFDr 2  F0 D2                beq     L2FDE
000CFFr 2  84 64                sty     EOLPNTR
000D01r 2  20 rr rr             jsr     CHKCLS
000D04r 2  68                   pla
000D05r 2  85 66                sta     VALTYP
000D07r 2  68                   pla
000D08r 2               .ifndef CONFIG_SMALL
000D08r 2  85 67                sta     VALTYP+1
000D0Ar 2  29 7F                and     #$7F
000D0Cr 2               .endif
000D0Cr 2  85 65                sta     DIMFLG
000D0Er 2               ; ----------------------------------------------------------------------------
000D0Er 2               ; SEARCH ARRAY TABLE FOR THIS ARRAY NAME
000D0Er 2               ; ----------------------------------------------------------------------------
000D0Er 2  A6 86                ldx     ARYTAB
000D10r 2  A5 87                lda     ARYTAB+1
000D12r 2               L301F:
000D12r 2  86 B6                stx     LOWTR
000D14r 2  85 B7                sta     LOWTR+1
000D16r 2  C5 89                cmp     STREND+1
000D18r 2  D0 04                bne     L302B
000D1Ar 2  E4 88                cpx     STREND
000D1Cr 2  F0 39                beq     MAKE_NEW_ARRAY
000D1Er 2               L302B:
000D1Er 2  A0 00                ldy     #$00
000D20r 2  B1 B6                lda     (LOWTR),y
000D22r 2  C8                   iny
000D23r 2  C5 9C                cmp     VARNAM
000D25r 2  D0 06                bne     L303A
000D27r 2  A5 9D                lda     VARNAM+1
000D29r 2  D1 B6                cmp     (LOWTR),y
000D2Br 2  F0 16                beq     USE_OLD_ARRAY
000D2Dr 2               L303A:
000D2Dr 2  C8                   iny
000D2Er 2  B1 B6                lda     (LOWTR),y
000D30r 2  18                   clc
000D31r 2  65 B6                adc     LOWTR
000D33r 2  AA                   tax
000D34r 2  C8                   iny
000D35r 2  B1 B6                lda     (LOWTR),y
000D37r 2  65 B7                adc     LOWTR+1
000D39r 2  90 D7                bcc     L301F
000D3Br 2               
000D3Br 2               ; ----------------------------------------------------------------------------
000D3Br 2               ; ERROR:  BAD SUBSCRIPTS
000D3Br 2               ; ----------------------------------------------------------------------------
000D3Br 2               SUBERR:
000D3Br 2  A2 6B                ldx     #ERR_BADSUBS
000D3Dr 2  2C                   .byte   $2C
000D3Er 2               
000D3Er 2               ; ----------------------------------------------------------------------------
000D3Er 2               ; ERROR:  ILLEGAL QUANTITY
000D3Er 2               ; ----------------------------------------------------------------------------
000D3Er 2               IQERR:
000D3Er 2  A2 35                ldx     #ERR_ILLQTY
000D40r 2               JER:
000D40r 2  4C rr rr             jmp     ERROR
000D43r 2               
000D43r 2               ; ----------------------------------------------------------------------------
000D43r 2               ; FOUND THE ARRAY
000D43r 2               ; ----------------------------------------------------------------------------
000D43r 2               USE_OLD_ARRAY:
000D43r 2  A2 78                ldx     #ERR_REDIMD
000D45r 2  A5 65                lda     DIMFLG
000D47r 2  D0 F7                bne     JER
000D49r 2  20 rr rr             jsr     GETARY
000D4Cr 2  A5 64                lda     EOLPNTR
000D4Er 2  A0 04                ldy     #$04
000D50r 2  D1 B6                cmp     (LOWTR),y
000D52r 2  D0 E7                bne     SUBERR
000D54r 2  4C rr rr             jmp     FIND_ARRAY_ELEMENT
000D57r 2               
000D57r 2               ; ----------------------------------------------------------------------------
000D57r 2               ; CREATE A NEW ARRAY, UNLESS CALLED FROM GETARYPT
000D57r 2               ; ----------------------------------------------------------------------------
000D57r 2               MAKE_NEW_ARRAY:
000D57r 2  20 rr rr             jsr     GETARY
000D5Ar 2  20 rr rr             jsr     REASON
000D5Dr 2  A9 00                lda     #$00
000D5Fr 2  A8                   tay
000D60r 2  85 C9                sta     STRNG2+1
000D62r 2  A2 05                ldx     #BYTES_PER_ELEMENT
000D64r 2               .if .def(CONFIG_SMALL) && (!.def(CONFIG_2))
000D64r 2                       stx     STRNG2
000D64r 2               .endif
000D64r 2  A5 9C                lda     VARNAM
000D66r 2  91 B6                sta     (LOWTR),y
000D68r 2               .ifndef CONFIG_SMALL
000D68r 2  10 01                bpl     L3078
000D6Ar 2  CA                   dex
000D6Br 2               L3078:
000D6Br 2               .endif
000D6Br 2  C8                   iny
000D6Cr 2  A5 9D                lda     VARNAM+1
000D6Er 2  91 B6                sta     (LOWTR),y
000D70r 2               .if (!.def(CONFIG_SMALL)) || .def(CONFIG_2)
000D70r 2  10 02                bpl     L3081
000D72r 2  CA                   dex
000D73r 2                 .if !(.def(CONFIG_SMALL) && .def(CONFIG_2))
000D73r 2  CA                   dex
000D74r 2                 .endif
000D74r 2               L3081:
000D74r 2  86 C8                stx     STRNG2
000D76r 2               .endif
000D76r 2  A5 64                lda     EOLPNTR
000D78r 2  C8                   iny
000D79r 2  C8                   iny
000D7Ar 2  C8                   iny
000D7Br 2  91 B6                sta     (LOWTR),y
000D7Dr 2               L308A:
000D7Dr 2  A2 0B                ldx     #$0B
000D7Fr 2  A9 00                lda     #$00
000D81r 2  24 65                bit     DIMFLG
000D83r 2  50 08                bvc     L309A
000D85r 2  68                   pla
000D86r 2  18                   clc
000D87r 2  69 01                adc     #$01
000D89r 2  AA                   tax
000D8Ar 2  68                   pla
000D8Br 2  69 00                adc     #$00
000D8Dr 2               L309A:
000D8Dr 2  C8                   iny
000D8Er 2  91 B6                sta     (LOWTR),y
000D90r 2  C8                   iny
000D91r 2  8A                   txa
000D92r 2  91 B6                sta     (LOWTR),y
000D94r 2  20 rr rr             jsr     MULTIPLY_SUBSCRIPT
000D97r 2  86 C8                stx     STRNG2
000D99r 2  85 C9                sta     STRNG2+1
000D9Br 2  A4 79                ldy     INDEX
000D9Dr 2  C6 64                dec     EOLPNTR
000D9Fr 2  D0 DC                bne     L308A
000DA1r 2  65 B0                adc     HIGHDS+1
000DA3r 2  B0 5D                bcs     GME
000DA5r 2  85 B0                sta     HIGHDS+1
000DA7r 2  A8                   tay
000DA8r 2  8A                   txa
000DA9r 2  65 AF                adc     HIGHDS
000DABr 2  90 03                bcc     L30BD
000DADr 2  C8                   iny
000DAEr 2  F0 52                beq     GME
000DB0r 2               L30BD:
000DB0r 2  20 rr rr             jsr     REASON
000DB3r 2  85 88                sta     STREND
000DB5r 2  84 89                sty     STREND+1
000DB7r 2  A9 00                lda     #$00
000DB9r 2  E6 C9                inc     STRNG2+1
000DBBr 2  A4 C8                ldy     STRNG2
000DBDr 2  F0 05                beq     L30D1
000DBFr 2               L30CC:
000DBFr 2  88                   dey
000DC0r 2  91 AF                sta     (HIGHDS),y
000DC2r 2  D0 FB                bne     L30CC
000DC4r 2               L30D1:
000DC4r 2  C6 B0                dec     HIGHDS+1
000DC6r 2  C6 C9                dec     STRNG2+1
000DC8r 2  D0 F5                bne     L30CC
000DCAr 2  E6 B0                inc     HIGHDS+1
000DCCr 2  38                   sec
000DCDr 2  A5 88                lda     STREND
000DCFr 2  E5 B6                sbc     LOWTR
000DD1r 2  A0 02                ldy     #$02
000DD3r 2  91 B6                sta     (LOWTR),y
000DD5r 2  A5 89                lda     STREND+1
000DD7r 2  C8                   iny
000DD8r 2  E5 B7                sbc     LOWTR+1
000DDAr 2  91 B6                sta     (LOWTR),y
000DDCr 2  A5 65                lda     DIMFLG
000DDEr 2  D0 62                bne     RTS9
000DE0r 2  C8                   iny
000DE1r 2               
000DE1r 2               ; ----------------------------------------------------------------------------
000DE1r 2               ; FIND SPECIFIED ARRAY ELEMENT
000DE1r 2               ;
000DE1r 2               ; (LOWTR),Y POINTS AT # OF DIMS IN ARRAY DESCRIPTOR
000DE1r 2               ; THE SUBSCRIPTS ARE ALL ON THE STACK AS INTEGERS
000DE1r 2               ; ----------------------------------------------------------------------------
000DE1r 2               FIND_ARRAY_ELEMENT:
000DE1r 2  B1 B6                lda     (LOWTR),y
000DE3r 2  85 64                sta     EOLPNTR
000DE5r 2  A9 00                lda     #$00
000DE7r 2  85 C8                sta     STRNG2
000DE9r 2               L30F6:
000DE9r 2  85 C9                sta     STRNG2+1
000DEBr 2  C8                   iny
000DECr 2  68                   pla
000DEDr 2  AA                   tax
000DEEr 2  85 BB                sta     FAC_LAST-1
000DF0r 2  68                   pla
000DF1r 2  85 BC                sta     FAC_LAST
000DF3r 2  D1 B6                cmp     (LOWTR),y
000DF5r 2  90 0E                bcc     FAE2
000DF7r 2  D0 06                bne     GSE
000DF9r 2  C8                   iny
000DFAr 2  8A                   txa
000DFBr 2  D1 B6                cmp     (LOWTR),y
000DFDr 2  90 07                bcc     FAE3
000DFFr 2               ; ----------------------------------------------------------------------------
000DFFr 2               GSE:
000DFFr 2  4C rr rr             jmp     SUBERR
000E02r 2               GME:
000E02r 2  4C rr rr             jmp     MEMERR
000E05r 2               ; ----------------------------------------------------------------------------
000E05r 2               FAE2:
000E05r 2  C8                   iny
000E06r 2               FAE3:
000E06r 2  A5 C9                lda     STRNG2+1
000E08r 2  05 C8                ora     STRNG2
000E0Ar 2  18                   clc
000E0Br 2  F0 0A                beq     L3124
000E0Dr 2  20 rr rr             jsr     MULTIPLY_SUBSCRIPT
000E10r 2  8A                   txa
000E11r 2  65 BB                adc     FAC_LAST-1
000E13r 2  AA                   tax
000E14r 2  98                   tya
000E15r 2  A4 79                ldy     INDEX
000E17r 2               L3124:
000E17r 2  65 BC                adc     FAC_LAST
000E19r 2  86 C8                stx     STRNG2
000E1Br 2  C6 64                dec     EOLPNTR
000E1Dr 2  D0 CA                bne     L30F6
000E1Fr 2               .if .def(CONFIG_SMALL) && (!.def(CONFIG_2))
000E1Fr 2                       asl     STRNG2
000E1Fr 2                       rol     a
000E1Fr 2                       bcs     GSE
000E1Fr 2                       asl     STRNG2
000E1Fr 2                       rol     a
000E1Fr 2                       bcs     GSE
000E1Fr 2                       tay
000E1Fr 2                       lda     STRNG2
000E1Fr 2               .else
000E1Fr 2                 .ifdef CONFIG_11A
000E1Fr 2  85 C9                sta     STRNG2+1
000E21r 2                 .endif
000E21r 2  A2 05                ldx     #BYTES_FP
000E23r 2                 .ifdef CONFIG_SMALL
000E23r 2                       lda     VARNAM+1
000E23r 2                 .else
000E23r 2  A5 9C                lda     VARNAM
000E25r 2                 .endif
000E25r 2  10 01                bpl     L3135
000E27r 2  CA                   dex
000E28r 2               L3135:
000E28r 2                 .ifdef CONFIG_SMALL
000E28r 2                       stx     RESULT+1
000E28r 2                 .else
000E28r 2  A5 9D                lda     VARNAM+1
000E2Ar 2  10 02                bpl     L313B
000E2Cr 2  CA                   dex
000E2Dr 2  CA                   dex
000E2Er 2               L313B:
000E2Er 2  86 7F                stx     RESULT+2
000E30r 2                 .endif
000E30r 2  A9 00                lda     #$00
000E32r 2  20 rr rr             jsr     MULTIPLY_SUBS1
000E35r 2  8A                   txa
000E36r 2               .endif
000E36r 2  65 AF                adc     HIGHDS
000E38r 2  85 9E                sta     VARPNT
000E3Ar 2  98                   tya
000E3Br 2  65 B0                adc     HIGHDS+1
000E3Dr 2  85 9F                sta     VARPNT+1
000E3Fr 2  A8                   tay
000E40r 2  A5 9E                lda     VARPNT
000E42r 2               RTS9:
000E42r 2  60                   rts
000E43r 2               
000E43r 2               ; ----------------------------------------------------------------------------
000E43r 2               ; MULTIPLY (STRNG2) BY ((LOWTR),Y)
000E43r 2               ; LEAVING PRODUCT IN A,X.  (HI-BYTE ALSO IN Y.)
000E43r 2               ; USED ONLY BY ARRAY SUBSCRIPT ROUTINES
000E43r 2               ; ----------------------------------------------------------------------------
000E43r 2               MULTIPLY_SUBSCRIPT:
000E43r 2  84 79                sty     INDEX
000E45r 2  B1 B6                lda     (LOWTR),y
000E47r 2  85 7F                sta     RESULT_LAST-2
000E49r 2  88                   dey
000E4Ar 2  B1 B6                lda     (LOWTR),y
000E4Cr 2               MULTIPLY_SUBS1:
000E4Cr 2  85 80                sta     RESULT_LAST-1
000E4Er 2  A9 10                lda     #$10
000E50r 2  85 B4                sta     INDX
000E52r 2  A2 00                ldx     #$00
000E54r 2  A0 00                ldy     #$00
000E56r 2               L3163:
000E56r 2  8A                   txa
000E57r 2  0A                   asl     a
000E58r 2  AA                   tax
000E59r 2  98                   tya
000E5Ar 2  2A                   rol     a
000E5Br 2  A8                   tay
000E5Cr 2  B0 A4                bcs     GME
000E5Er 2  06 C8                asl     STRNG2
000E60r 2  26 C9                rol     STRNG2+1
000E62r 2  90 0B                bcc     L317C
000E64r 2  18                   clc
000E65r 2  8A                   txa
000E66r 2  65 7F                adc     RESULT_LAST-2
000E68r 2  AA                   tax
000E69r 2  98                   tya
000E6Ar 2  65 80                adc     RESULT_LAST-1
000E6Cr 2  A8                   tay
000E6Dr 2  B0 93                bcs     GME
000E6Fr 2               L317C:
000E6Fr 2  C6 B4                dec     INDX
000E71r 2  D0 E3                bne     L3163
000E73r 2  60                   rts
000E74r 2               
000E74r 2               
000E74r 1               .include "misc2.s"
000E74r 2               .segment "CODE"
000E74r 2               
000E74r 2               ; ----------------------------------------------------------------------------
000E74r 2               ; "FRE" FUNCTION
000E74r 2               ;
000E74r 2               ; COLLECTS GARBAGE AND RETURNS # BYTES OF MEMORY LEFT
000E74r 2               ; ----------------------------------------------------------------------------
000E74r 2               FRE:
000E74r 2  A5 66                lda     VALTYP
000E76r 2  F0 03                beq     L3188
000E78r 2  20 rr rr             jsr     FREFAC
000E7Br 2               L3188:
000E7Br 2  20 rr rr             jsr     GARBAG
000E7Er 2  38                   sec
000E7Fr 2  A5 8A                lda     FRETOP
000E81r 2  E5 88                sbc     STREND
000E83r 2  A8                   tay
000E84r 2  A5 8B                lda     FRETOP+1
000E86r 2  E5 89                sbc     STREND+1
000E88r 2               ; FALL INTO GIVAYF TO FLOAT THE VALUE
000E88r 2               ; NOTE THAT VALUES OVER 32767 WILL RETURN AS NEGATIVE
000E88r 2               
000E88r 2               ; ----------------------------------------------------------------------------
000E88r 2               ; FLOAT THE SIGNED INTEGER IN A,Y
000E88r 2               ; ----------------------------------------------------------------------------
000E88r 2               GIVAYF:
000E88r 2  A2 00                ldx     #$00
000E8Ar 2  86 66                stx     VALTYP
000E8Cr 2  85 B9                sta     FAC+1
000E8Er 2  84 BA                sty     FAC+2
000E90r 2  A2 90                ldx     #$90
000E92r 2  4C rr rr             jmp     FLOAT1
000E95r 2               POS:
000E95r 2  A4 0D                ldy     POSX
000E97r 2               
000E97r 2               ; ----------------------------------------------------------------------------
000E97r 2               ; FLOAT (Y) INTO FAC, GIVING VALUE 0-255
000E97r 2               ; ----------------------------------------------------------------------------
000E97r 2               SNGFLT:
000E97r 2  A9 00                lda     #$00
000E99r 2  F0 ED                beq     GIVAYF
000E9Br 2               
000E9Br 2               ; ----------------------------------------------------------------------------
000E9Br 2               ; CHECK FOR DIRECT OR RUNNING MODE
000E9Br 2               ; GIVING ERROR IF DIRECT MODE
000E9Br 2               ; ----------------------------------------------------------------------------
000E9Br 2               ERRDIR:
000E9Br 2  A6 91                ldx     CURLIN+1
000E9Dr 2  E8                   inx
000E9Er 2  D0 A2                bne     RTS9
000EA0r 2  A2 95                ldx     #ERR_ILLDIR
000EA2r 2               .ifdef CONFIG_2
000EA2r 2  2C                   .byte   $2C
000EA3r 2               LD288:
000EA3r 2  A2 E0                ldx     #ERR_UNDEFFN
000EA5r 2               .endif
000EA5r 2               L31AF:
000EA5r 2  4C rr rr             jmp     ERROR
000EA8r 2               DEF:
000EA8r 2  20 rr rr             jsr     FNC
000EABr 2  20 rr rr             jsr     ERRDIR
000EAEr 2  20 rr rr             jsr     CHKOPN
000EB1r 2  A9 80                lda     #$80
000EB3r 2  85 69                sta     SUBFLG
000EB5r 2  20 rr rr             jsr     PTRGET
000EB8r 2  20 rr rr             jsr     CHKNUM
000EBBr 2  20 rr rr             jsr     CHKCLS
000EBEr 2  A9 AD                lda     #TOKEN_EQUAL
000EC0r 2  20 rr rr             jsr     SYNCHR
000EC3r 2               .ifndef CONFIG_SMALL
000EC3r 2  48                   pha
000EC4r 2               .endif
000EC4r 2  A5 9F                lda     VARPNT+1
000EC6r 2  48                   pha
000EC7r 2  A5 9E                lda     VARPNT
000EC9r 2  48                   pha
000ECAr 2  A5 D2                lda     TXTPTR+1
000ECCr 2  48                   pha
000ECDr 2  A5 D1                lda     TXTPTR
000ECFr 2  48                   pha
000ED0r 2  20 rr rr             jsr     DATA
000ED3r 2  4C rr rr             jmp     L3250
000ED6r 2               FNC:
000ED6r 2  A9 A0                lda     #TOKEN_FN
000ED8r 2  20 rr rr             jsr     SYNCHR
000EDBr 2  09 80                ora     #$80
000EDDr 2  85 69                sta     SUBFLG
000EDFr 2  20 rr rr             jsr     PTRGET3
000EE2r 2  85 A5                sta     FNCNAM
000EE4r 2  84 A6                sty     FNCNAM+1
000EE6r 2  4C rr rr             jmp     CHKNUM
000EE9r 2               L31F3:
000EE9r 2  20 rr rr             jsr     FNC
000EECr 2  A5 A6                lda     FNCNAM+1
000EEEr 2  48                   pha
000EEFr 2  A5 A5                lda     FNCNAM
000EF1r 2  48                   pha
000EF2r 2  20 rr rr             jsr     PARCHK
000EF5r 2  20 rr rr             jsr     CHKNUM
000EF8r 2  68                   pla
000EF9r 2  85 A5                sta     FNCNAM
000EFBr 2  68                   pla
000EFCr 2  85 A6                sta     FNCNAM+1
000EFEr 2  A0 02                ldy     #$02
000F00r 2               .ifndef CONFIG_2
000F00r 2                       ldx     #ERR_UNDEFFN
000F00r 2               .endif
000F00r 2  B1 A5                lda     (FNCNAM),y
000F02r 2               .ifndef CONFIG_2
000F02r 2                       beq     L31AF
000F02r 2               .endif
000F02r 2  85 9E                sta     VARPNT
000F04r 2  AA                   tax
000F05r 2  C8                   iny
000F06r 2  B1 A5                lda     (FNCNAM),y
000F08r 2               .ifdef CONFIG_2
000F08r 2  F0 99                beq     LD288
000F0Ar 2               .endif
000F0Ar 2  85 9F                sta     VARPNT+1
000F0Cr 2               .ifndef CONFIG_SMALL
000F0Cr 2  C8                   iny
000F0Dr 2               .endif
000F0Dr 2               L3219:
000F0Dr 2  B1 9E                lda     (VARPNT),y
000F0Fr 2  48                   pha
000F10r 2  88                   dey
000F11r 2  10 FA                bpl     L3219
000F13r 2  A4 9F                ldy     VARPNT+1
000F15r 2  20 rr rr             jsr     STORE_FAC_AT_YX_ROUNDED
000F18r 2  A5 D2                lda     TXTPTR+1
000F1Ar 2  48                   pha
000F1Br 2  A5 D1                lda     TXTPTR
000F1Dr 2  48                   pha
000F1Er 2  B1 A5                lda     (FNCNAM),y
000F20r 2  85 D1                sta     TXTPTR
000F22r 2  C8                   iny
000F23r 2  B1 A5                lda     (FNCNAM),y
000F25r 2  85 D2                sta     TXTPTR+1
000F27r 2  A5 9F                lda     VARPNT+1
000F29r 2  48                   pha
000F2Ar 2  A5 9E                lda     VARPNT
000F2Cr 2  48                   pha
000F2Dr 2  20 rr rr             jsr     FRMNUM
000F30r 2  68                   pla
000F31r 2  85 A5                sta     FNCNAM
000F33r 2  68                   pla
000F34r 2  85 A6                sta     FNCNAM+1
000F36r 2  20 D0 00             jsr     CHRGOT
000F39r 2  F0 03                beq     L324A
000F3Br 2  4C rr rr             jmp     SYNERR
000F3Er 2               L324A:
000F3Er 2  68                   pla
000F3Fr 2  85 D1                sta     TXTPTR
000F41r 2  68                   pla
000F42r 2  85 D2                sta     TXTPTR+1
000F44r 2               L3250:
000F44r 2  A0 00                ldy     #$00
000F46r 2  68                   pla
000F47r 2  91 A5                sta     (FNCNAM),y
000F49r 2  68                   pla
000F4Ar 2  C8                   iny
000F4Br 2  91 A5                sta     (FNCNAM),y
000F4Dr 2  68                   pla
000F4Er 2  C8                   iny
000F4Fr 2  91 A5                sta     (FNCNAM),y
000F51r 2  68                   pla
000F52r 2  C8                   iny
000F53r 2  91 A5                sta     (FNCNAM),y
000F55r 2               .ifndef CONFIG_SMALL
000F55r 2  68                   pla
000F56r 2  C8                   iny
000F57r 2  91 A5                sta     (FNCNAM),y
000F59r 2               .endif
000F59r 2  60                   rts
000F5Ar 2               
000F5Ar 1               .include "string.s"
000F5Ar 2               .segment "CODE"
000F5Ar 2               ; ----------------------------------------------------------------------------
000F5Ar 2               ; "STR$" FUNCTION
000F5Ar 2               ; ----------------------------------------------------------------------------
000F5Ar 2               STR:
000F5Ar 2  20 rr rr             jsr     CHKNUM
000F5Dr 2  A0 00                ldy     #$00
000F5Fr 2  20 rr rr             jsr     FOUT1
000F62r 2  68                   pla
000F63r 2  68                   pla
000F64r 2               LD353:
000F64r 2  A9 FF                lda     #<(STACK2-1)
000F66r 2  A0 00                ldy     #>(STACK2-1)
000F68r 2               .if STACK2 > $0100
000F68r 2                       bne     STRLIT
000F68r 2               .else
000F68r 2  F0 12                beq     STRLIT
000F6Ar 2               .endif
000F6Ar 2               
000F6Ar 2               ; ----------------------------------------------------------------------------
000F6Ar 2               ; GET SPACE AND MAKE DESCRIPTOR FOR STRING WHOSE
000F6Ar 2               ; ADDRESS IS IN FAC+3,4 AND WHOSE LENGTH IS IN A-REG
000F6Ar 2               ; ----------------------------------------------------------------------------
000F6Ar 2               STRINI:
000F6Ar 2  A6 BB                ldx     FAC_LAST-1
000F6Cr 2  A4 BC                ldy     FAC_LAST
000F6Er 2  86 A7                stx     DSCPTR
000F70r 2  84 A8                sty     DSCPTR+1
000F72r 2               
000F72r 2               ; ----------------------------------------------------------------------------
000F72r 2               ; GET SPACE AND MAKE DESCRIPTOR FOR STRING WHOSE
000F72r 2               ; ADDRESS IS IN Y,X AND WHOSE LENGTH IS IN A-REG
000F72r 2               ; ----------------------------------------------------------------------------
000F72r 2               STRSPA:
000F72r 2  20 rr rr             jsr     GETSPA
000F75r 2  86 B9                stx     FAC+1
000F77r 2  84 BA                sty     FAC+2
000F79r 2  85 B8                sta     FAC
000F7Br 2  60                   rts
000F7Cr 2               
000F7Cr 2               ; ----------------------------------------------------------------------------
000F7Cr 2               ; BUILD A DESCRIPTOR FOR STRING STARTING AT Y,A
000F7Cr 2               ; AND TERMINATED BY $00 OR QUOTATION MARK
000F7Cr 2               ; RETURN WITH DESCRIPTOR IN A TEMPORARY
000F7Cr 2               ; AND ADDRESS OF DESCRIPTOR IN FAC+3,4
000F7Cr 2               ; ----------------------------------------------------------------------------
000F7Cr 2               STRLIT:
000F7Cr 2  A2 22                ldx     #$22
000F7Er 2  86 62                stx     CHARAC
000F80r 2  86 63                stx     ENDCHR
000F82r 2               
000F82r 2               ; ----------------------------------------------------------------------------
000F82r 2               ; BUILD A DESCRIPTOR FOR STRING STARTING AT Y,A
000F82r 2               ; AND TERMINATED BY $00, (CHARAC), OR (ENDCHR)
000F82r 2               ;
000F82r 2               ; RETURN WITH DESCRIPTOR IN A TEMPORARY
000F82r 2               ; AND ADDRESS OF DESCRIPTOR IN FAC+3,4
000F82r 2               ; ----------------------------------------------------------------------------
000F82r 2               STRLT2:
000F82r 2  85 C6                sta     STRNG1
000F84r 2  84 C7                sty     STRNG1+1
000F86r 2  85 B9                sta     FAC+1
000F88r 2  84 BA                sty     FAC+2
000F8Ar 2  A0 FF                ldy     #$FF
000F8Cr 2               L3298:
000F8Cr 2  C8                   iny
000F8Dr 2  B1 C6                lda     (STRNG1),y
000F8Fr 2  F0 0C                beq     L32A9
000F91r 2  C5 62                cmp     CHARAC
000F93r 2  F0 04                beq     L32A5
000F95r 2  C5 63                cmp     ENDCHR
000F97r 2  D0 F3                bne     L3298
000F99r 2               L32A5:
000F99r 2  C9 22                cmp     #$22
000F9Br 2  F0 01                beq     L32AA
000F9Dr 2               L32A9:
000F9Dr 2  18                   clc
000F9Er 2               L32AA:
000F9Er 2  84 B8                sty     FAC
000FA0r 2  98                   tya
000FA1r 2  65 C6                adc     STRNG1
000FA3r 2  85 C8                sta     STRNG2
000FA5r 2  A6 C7                ldx     STRNG1+1
000FA7r 2  90 01                bcc     L32B6
000FA9r 2  E8                   inx
000FAAr 2               L32B6:
000FAAr 2  86 C9                stx     STRNG2+1
000FACr 2  A5 C7                lda     STRNG1+1
000FAEr 2               .ifdef CONFIG_NO_INPUTBUFFER_ZP
000FAEr 2                       beq     LD399
000FAEr 2                       cmp     #>INPUTBUFFER
000FAEr 2               .elseif .def(AIM65)
000FAEr 2                       beq     LD399
000FAEr 2                       cmp     #$01
000FAEr 2               .endif
000FAEr 2  D0 0B                bne     PUTNEW
000FB0r 2               LD399:
000FB0r 2  98                   tya
000FB1r 2  20 rr rr             jsr     STRINI
000FB4r 2  A6 C6                ldx     STRNG1
000FB6r 2  A4 C7                ldy     STRNG1+1
000FB8r 2  20 rr rr             jsr     MOVSTR
000FBBr 2               
000FBBr 2               ; ----------------------------------------------------------------------------
000FBBr 2               ; STORE DESCRIPTOR IN TEMPORARY DESCRIPTOR STACK
000FBBr 2               ;
000FBBr 2               ; THE DESCRIPTOR IS NOW IN FAC, FAC+1, FAC+2
000FBBr 2               ; PUT ADDRESS OF TEMP DESCRIPTOR IN FAC+3,4
000FBBr 2               ; ----------------------------------------------------------------------------
000FBBr 2               PUTNEW:
000FBBr 2  A6 6D                ldx     TEMPPT
000FBDr 2  E0 79                cpx     #TEMPST+9
000FBFr 2  D0 05                bne     PUTEMP
000FC1r 2  A2 BF                ldx     #ERR_FRMCPX
000FC3r 2               JERR:
000FC3r 2  4C rr rr             jmp     ERROR
000FC6r 2               PUTEMP:
000FC6r 2  A5 B8                lda     FAC
000FC8r 2  95 00                sta     0,x
000FCAr 2  A5 B9                lda     FAC+1
000FCCr 2  95 01                sta     1,x
000FCEr 2  A5 BA                lda     FAC+2
000FD0r 2  95 02                sta     2,x
000FD2r 2  A0 00                ldy     #$00
000FD4r 2  86 BB                stx     FAC_LAST-1
000FD6r 2  84 BC                sty     FAC_LAST
000FD8r 2               .ifdef CONFIG_2
000FD8r 2  84 C7                sty     FACEXTENSION
000FDAr 2               .endif
000FDAr 2  88                   dey
000FDBr 2  84 66                sty     VALTYP
000FDDr 2  86 6E                stx     LASTPT
000FDFr 2  E8                   inx
000FE0r 2  E8                   inx
000FE1r 2  E8                   inx
000FE2r 2  86 6D                stx     TEMPPT
000FE4r 2  60                   rts
000FE5r 2               
000FE5r 2               ; ----------------------------------------------------------------------------
000FE5r 2               ; MAKE SPACE FOR STRING AT BOTTOM OF STRING SPACE
000FE5r 2               ; (A)=# BYTES SPACE TO MAKE
000FE5r 2               ;
000FE5r 2               ; RETURN WITH (A) SAME,
000FE5r 2               ;	AND Y,X = ADDRESS OF SPACE ALLOCATED
000FE5r 2               ; ----------------------------------------------------------------------------
000FE5r 2               GETSPA:
000FE5r 2  46 68                lsr     DATAFLG
000FE7r 2               L32F1:
000FE7r 2  48                   pha
000FE8r 2  49 FF                eor     #$FF
000FEAr 2  38                   sec
000FEBr 2  65 8A                adc     FRETOP
000FEDr 2  A4 8B                ldy     FRETOP+1
000FEFr 2  B0 01                bcs     L32FC
000FF1r 2  88                   dey
000FF2r 2               L32FC:
000FF2r 2  C4 89                cpy     STREND+1
000FF4r 2  90 11                bcc     L3311
000FF6r 2  D0 04                bne     L3306
000FF8r 2  C5 88                cmp     STREND
000FFAr 2  90 0B                bcc     L3311
000FFCr 2               L3306:
000FFCr 2  85 8A                sta     FRETOP
000FFEr 2  84 8B                sty     FRETOP+1
001000r 2  85 8C                sta     FRESPC
001002r 2  84 8D                sty     FRESPC+1
001004r 2  AA                   tax
001005r 2  68                   pla
001006r 2  60                   rts
001007r 2               L3311:
001007r 2  A2 4D                ldx     #ERR_MEMFULL
001009r 2  A5 68                lda     DATAFLG
00100Br 2  30 B6                bmi     JERR
00100Dr 2  20 rr rr             jsr     GARBAG
001010r 2  A9 80                lda     #$80
001012r 2  85 68                sta     DATAFLG
001014r 2  68                   pla
001015r 2  D0 D0                bne     L32F1
001017r 2               
001017r 2               ; ----------------------------------------------------------------------------
001017r 2               ; SHOVE ALL REFERENCED STRINGS AS HIGH AS POSSIBLE
001017r 2               ; IN MEMORY (AGAINST HIMEM), FREEING UP SPACE
001017r 2               ; BELOW STRING AREA DOWN TO STREND.
001017r 2               ; ----------------------------------------------------------------------------
001017r 2               GARBAG:
001017r 2               
001017r 2               .ifdef CONST_MEMSIZ
001017r 2                       ldx     #<CONST_MEMSIZ
001017r 2                       lda     #>CONST_MEMSIZ
001017r 2               .else
001017r 2  A6 8E                ldx     MEMSIZ
001019r 2  A5 8F                lda     MEMSIZ+1
00101Br 2               .endif
00101Br 2               FINDHIGHESTSTRING:
00101Br 2  86 8A                stx     FRETOP
00101Dr 2  85 8B                sta     FRETOP+1
00101Fr 2  A0 00                ldy     #$00
001021r 2  84 A6                sty     FNCNAM+1
001023r 2               .ifdef CONFIG_2
001023r 2  84 A5                sty     FNCNAM	; GC bugfix!
001025r 2               .endif
001025r 2  A5 88                lda     STREND
001027r 2  A6 89                ldx     STREND+1
001029r 2  85 B6                sta     LOWTR
00102Br 2  86 B7                stx     LOWTR+1
00102Dr 2  A9 70                lda     #TEMPST
00102Fr 2  A2 00                ldx     #$00
001031r 2  85 79                sta     INDEX
001033r 2  86 7A                stx     INDEX+1
001035r 2               L333D:
001035r 2  C5 6D                cmp     TEMPPT
001037r 2  F0 05                beq     L3346
001039r 2  20 rr rr             jsr     CHECK_VARIABLE
00103Cr 2  F0 F7                beq     L333D
00103Er 2               L3346:
00103Er 2  A9 07                lda     #BYTES_PER_VARIABLE
001040r 2  85 AA                sta     DSCLEN
001042r 2  A5 84                lda     VARTAB
001044r 2  A6 85                ldx     VARTAB+1
001046r 2  85 79                sta     INDEX
001048r 2  86 7A                stx     INDEX+1
00104Ar 2               L3352:
00104Ar 2  E4 87                cpx     ARYTAB+1
00104Cr 2  D0 04                bne     L335A
00104Er 2  C5 86                cmp     ARYTAB
001050r 2  F0 05                beq     L335F
001052r 2               L335A:
001052r 2  20 rr rr             jsr     CHECK_SIMPLE_VARIABLE
001055r 2  F0 F3                beq     L3352
001057r 2               L335F:
001057r 2  85 AF                sta     HIGHDS
001059r 2  86 B0                stx     HIGHDS+1
00105Br 2  A9 03                lda     #$03	; OSI GC bugfix -> $04 ???
00105Dr 2  85 AA                sta     DSCLEN
00105Fr 2               L3367:
00105Fr 2  A5 AF                lda     HIGHDS
001061r 2  A6 B0                ldx     HIGHDS+1
001063r 2               L336B:
001063r 2  E4 89                cpx     STREND+1
001065r 2  D0 07                bne     L3376
001067r 2  C5 88                cmp     STREND
001069r 2  D0 03                bne     L3376
00106Br 2  4C rr rr             jmp     MOVE_HIGHEST_STRING_TO_TOP
00106Er 2               L3376:
00106Er 2  85 79                sta     INDEX
001070r 2  86 7A                stx     INDEX+1
001072r 2               .ifdef CONFIG_SMALL
001072r 2                       ldy     #$01
001072r 2               .else
001072r 2  A0 00                ldy     #$00
001074r 2  B1 79                lda     (INDEX),y
001076r 2  AA                   tax
001077r 2  C8                   iny
001078r 2               .endif
001078r 2  B1 79                lda     (INDEX),y
00107Ar 2  08                   php
00107Br 2  C8                   iny
00107Cr 2  B1 79                lda     (INDEX),y
00107Er 2  65 AF                adc     HIGHDS
001080r 2  85 AF                sta     HIGHDS
001082r 2  C8                   iny
001083r 2  B1 79                lda     (INDEX),y
001085r 2  65 B0                adc     HIGHDS+1
001087r 2  85 B0                sta     HIGHDS+1
001089r 2  28                   plp
00108Ar 2  10 D3                bpl     L3367
00108Cr 2               .ifndef CONFIG_SMALL
00108Cr 2  8A                   txa
00108Dr 2  30 D0                bmi     L3367
00108Fr 2               .endif
00108Fr 2  C8                   iny
001090r 2  B1 79                lda     (INDEX),y
001092r 2               .ifdef CONFIG_CBM1_PATCHES
001092r 2                       jsr     LE7F3 ; XXX patch, call into screen editor
001092r 2               .else
001092r 2                 .ifdef CONFIG_11
001092r 2  A0 00                ldy     #$00	; GC bugfix
001094r 2                 .endif
001094r 2  0A                   asl     a
001095r 2  69 05                adc     #$05
001097r 2               .endif
001097r 2  65 79                adc     INDEX
001099r 2  85 79                sta     INDEX
00109Br 2  90 02                bcc     L33A7
00109Dr 2  E6 7A                inc     INDEX+1
00109Fr 2               L33A7:
00109Fr 2  A6 7A                ldx     INDEX+1
0010A1r 2               L33A9:
0010A1r 2  E4 B0                cpx     HIGHDS+1
0010A3r 2  D0 04                bne     L33B1
0010A5r 2  C5 AF                cmp     HIGHDS
0010A7r 2  F0 BA                beq     L336B
0010A9r 2               L33B1:
0010A9r 2  20 rr rr             jsr     CHECK_VARIABLE
0010ACr 2  F0 F3                beq     L33A9
0010AEr 2               
0010AEr 2               ; ----------------------------------------------------------------------------
0010AEr 2               ; PROCESS A SIMPLE VARIABLE
0010AEr 2               ; ----------------------------------------------------------------------------
0010AEr 2               CHECK_SIMPLE_VARIABLE:
0010AEr 2               .ifndef CONFIG_SMALL
0010AEr 2  B1 79                lda     (INDEX),y
0010B0r 2  30 35                bmi     CHECK_BUMP
0010B2r 2               .endif
0010B2r 2  C8                   iny
0010B3r 2  B1 79                lda     (INDEX),y
0010B5r 2  10 30                bpl     CHECK_BUMP
0010B7r 2  C8                   iny
0010B8r 2               
0010B8r 2               ; ----------------------------------------------------------------------------
0010B8r 2               ; IF STRING IS NOT EMPTY, CHECK IF IT IS HIGHEST
0010B8r 2               ; ----------------------------------------------------------------------------
0010B8r 2               CHECK_VARIABLE:
0010B8r 2  B1 79                lda     (INDEX),y
0010BAr 2  F0 2B                beq     CHECK_BUMP
0010BCr 2  C8                   iny
0010BDr 2  B1 79                lda     (INDEX),y
0010BFr 2  AA                   tax
0010C0r 2  C8                   iny
0010C1r 2  B1 79                lda     (INDEX),y
0010C3r 2  C5 8B                cmp     FRETOP+1
0010C5r 2  90 06                bcc     L33D5
0010C7r 2  D0 1E                bne     CHECK_BUMP
0010C9r 2  E4 8A                cpx     FRETOP
0010CBr 2  B0 1A                bcs     CHECK_BUMP
0010CDr 2               L33D5:
0010CDr 2  C5 B7                cmp     LOWTR+1
0010CFr 2  90 16                bcc     CHECK_BUMP
0010D1r 2  D0 04                bne     L33DF
0010D3r 2  E4 B6                cpx     LOWTR
0010D5r 2  90 10                bcc     CHECK_BUMP
0010D7r 2               L33DF:
0010D7r 2  86 B6                stx     LOWTR
0010D9r 2  85 B7                sta     LOWTR+1
0010DBr 2  A5 79                lda     INDEX
0010DDr 2  A6 7A                ldx     INDEX+1
0010DFr 2  85 A5                sta     FNCNAM
0010E1r 2  86 A6                stx     FNCNAM+1
0010E3r 2  A5 AA                lda     DSCLEN
0010E5r 2  85 AC                sta     Z52
0010E7r 2               
0010E7r 2               ; ----------------------------------------------------------------------------
0010E7r 2               ; ADD (DSCLEN) TO PNTR IN INDEX
0010E7r 2               ; RETURN WITH Y=0, PNTR ALSO IN X,A
0010E7r 2               ; ----------------------------------------------------------------------------
0010E7r 2               CHECK_BUMP:
0010E7r 2  A5 AA                lda     DSCLEN
0010E9r 2  18                   clc
0010EAr 2  65 79                adc     INDEX
0010ECr 2  85 79                sta     INDEX
0010EEr 2  90 02                bcc     L33FA
0010F0r 2  E6 7A                inc     INDEX+1
0010F2r 2               L33FA:
0010F2r 2  A6 7A                ldx     INDEX+1
0010F4r 2  A0 00                ldy     #$00
0010F6r 2  60                   rts
0010F7r 2               
0010F7r 2               ; ----------------------------------------------------------------------------
0010F7r 2               ; FOUND HIGHEST NON-EMPTY STRING, SO MOVE IT
0010F7r 2               ; TO TOP AND GO BACK FOR ANOTHER
0010F7r 2               ; ----------------------------------------------------------------------------
0010F7r 2               MOVE_HIGHEST_STRING_TO_TOP:
0010F7r 2               .ifdef CONFIG_2
0010F7r 2  A5 A6                lda     FNCNAM+1	; GC bugfix
0010F9r 2  05 A5                ora     FNCNAM
0010FBr 2               .else
0010FBr 2                       ldx     FNCNAM+1
0010FBr 2               .endif
0010FBr 2  F0 F5                beq     L33FA
0010FDr 2  A5 AC                lda     Z52
0010FFr 2               .ifndef CONFIG_10A
0010FFr 2                       sbc     #$03
0010FFr 2               .else
0010FFr 2  29 04                and     #$04
001101r 2               .endif
001101r 2  4A                   lsr     a
001102r 2  A8                   tay
001103r 2  85 AC                sta     Z52
001105r 2  B1 A5                lda     (FNCNAM),y
001107r 2  65 B6                adc     LOWTR
001109r 2  85 B1                sta     HIGHTR
00110Br 2  A5 B7                lda     LOWTR+1
00110Dr 2  69 00                adc     #$00
00110Fr 2  85 B2                sta     HIGHTR+1
001111r 2  A5 8A                lda     FRETOP
001113r 2  A6 8B                ldx     FRETOP+1
001115r 2  85 AF                sta     HIGHDS
001117r 2  86 B0                stx     HIGHDS+1
001119r 2  20 rr rr             jsr     BLTU2
00111Cr 2  A4 AC                ldy     Z52
00111Er 2  C8                   iny
00111Fr 2  A5 AF                lda     HIGHDS
001121r 2  91 A5                sta     (FNCNAM),y
001123r 2  AA                   tax
001124r 2  E6 B0                inc     HIGHDS+1
001126r 2  A5 B0                lda     HIGHDS+1
001128r 2  C8                   iny
001129r 2  91 A5                sta     (FNCNAM),y
00112Br 2  4C rr rr             jmp     FINDHIGHESTSTRING
00112Er 2               
00112Er 2               ; ----------------------------------------------------------------------------
00112Er 2               ; CONCATENATE TWO STRINGS
00112Er 2               ; ----------------------------------------------------------------------------
00112Er 2               CAT:
00112Er 2  A5 BC                lda     FAC_LAST
001130r 2  48                   pha
001131r 2  A5 BB                lda     FAC_LAST-1
001133r 2  48                   pha
001134r 2  20 rr rr             jsr     FRM_ELEMENT
001137r 2  20 rr rr             jsr     CHKSTR
00113Ar 2  68                   pla
00113Br 2  85 C6                sta     STRNG1
00113Dr 2  68                   pla
00113Er 2  85 C7                sta     STRNG1+1
001140r 2  A0 00                ldy     #$00
001142r 2  B1 C6                lda     (STRNG1),y
001144r 2  18                   clc
001145r 2  71 BB                adc     (FAC_LAST-1),y
001147r 2  90 05                bcc     L3454
001149r 2  A2 B0                ldx     #ERR_STRLONG
00114Br 2  4C rr rr             jmp     ERROR
00114Er 2               L3454:
00114Er 2  20 rr rr             jsr     STRINI
001151r 2  20 rr rr             jsr     MOVINS
001154r 2  A5 A7                lda     DSCPTR
001156r 2  A4 A8                ldy     DSCPTR+1
001158r 2  20 rr rr             jsr     FRETMP
00115Br 2  20 rr rr             jsr     MOVSTR1
00115Er 2  A5 C6                lda     STRNG1
001160r 2  A4 C7                ldy     STRNG1+1
001162r 2  20 rr rr             jsr     FRETMP
001165r 2  20 rr rr             jsr     PUTNEW
001168r 2  4C rr rr             jmp     FRMEVL2
00116Br 2               
00116Br 2               ; ----------------------------------------------------------------------------
00116Br 2               ; GET STRING DESCRIPTOR POINTED AT BY (STRNG1)
00116Br 2               ; AND MOVE DESCRIBED STRING TO (FRESPC)
00116Br 2               ; ----------------------------------------------------------------------------
00116Br 2               MOVINS:
00116Br 2  A0 00                ldy     #$00
00116Dr 2  B1 C6                lda     (STRNG1),y
00116Fr 2  48                   pha
001170r 2  C8                   iny
001171r 2  B1 C6                lda     (STRNG1),y
001173r 2  AA                   tax
001174r 2  C8                   iny
001175r 2  B1 C6                lda     (STRNG1),y
001177r 2  A8                   tay
001178r 2  68                   pla
001179r 2               
001179r 2               ; ----------------------------------------------------------------------------
001179r 2               ; MOVE STRING AT (Y,X) WITH LENGTH (A)
001179r 2               ; TO DESTINATION WHOSE ADDRESS IS IN FRESPC,FRESPC+1
001179r 2               ; ----------------------------------------------------------------------------
001179r 2               MOVSTR:
001179r 2  86 79                stx     INDEX
00117Br 2  84 7A                sty     INDEX+1
00117Dr 2               MOVSTR1:
00117Dr 2  A8                   tay
00117Er 2  F0 0A                beq     L3490
001180r 2  48                   pha
001181r 2               L3487:
001181r 2  88                   dey
001182r 2  B1 79                lda     (INDEX),y
001184r 2  91 8C                sta     (FRESPC),y
001186r 2  98                   tya
001187r 2  D0 F8                bne     L3487
001189r 2  68                   pla
00118Ar 2               L3490:
00118Ar 2  18                   clc
00118Br 2  65 8C                adc     FRESPC
00118Dr 2  85 8C                sta     FRESPC
00118Fr 2  90 02                bcc     L3499
001191r 2  E6 8D                inc     FRESPC+1
001193r 2               L3499:
001193r 2  60                   rts
001194r 2               
001194r 2               ; ----------------------------------------------------------------------------
001194r 2               ; IF (FAC) IS A TEMPORARY STRING, RELEASE DESCRIPTOR
001194r 2               ; ----------------------------------------------------------------------------
001194r 2               FRESTR:
001194r 2  20 rr rr             jsr     CHKSTR
001197r 2               
001197r 2               ; ----------------------------------------------------------------------------
001197r 2               ; IF STRING DESCRIPTOR POINTED TO BY FAC+3,4 IS
001197r 2               ; A TEMPORARY STRING, RELEASE IT.
001197r 2               ; ----------------------------------------------------------------------------
001197r 2               FREFAC:
001197r 2  A5 BB                lda     FAC_LAST-1
001199r 2  A4 BC                ldy     FAC_LAST
00119Br 2               
00119Br 2               ; ----------------------------------------------------------------------------
00119Br 2               ; IF STRING DESCRIPTOR WHOSE ADDRESS IS IN Y,A IS
00119Br 2               ; A TEMPORARY STRING, RELEASE IT.
00119Br 2               ; ----------------------------------------------------------------------------
00119Br 2               FRETMP:
00119Br 2  85 79                sta     INDEX
00119Dr 2  84 7A                sty     INDEX+1
00119Fr 2  20 rr rr             jsr     FRETMS
0011A2r 2  08                   php
0011A3r 2  A0 00                ldy     #$00
0011A5r 2  B1 79                lda     (INDEX),y
0011A7r 2  48                   pha
0011A8r 2  C8                   iny
0011A9r 2  B1 79                lda     (INDEX),y
0011ABr 2  AA                   tax
0011ACr 2  C8                   iny
0011ADr 2  B1 79                lda     (INDEX),y
0011AFr 2  A8                   tay
0011B0r 2  68                   pla
0011B1r 2  28                   plp
0011B2r 2  D0 13                bne     L34CD
0011B4r 2  C4 8B                cpy     FRETOP+1
0011B6r 2  D0 0F                bne     L34CD
0011B8r 2  E4 8A                cpx     FRETOP
0011BAr 2  D0 0B                bne     L34CD
0011BCr 2  48                   pha
0011BDr 2  18                   clc
0011BEr 2  65 8A                adc     FRETOP
0011C0r 2  85 8A                sta     FRETOP
0011C2r 2  90 02                bcc     L34CC
0011C4r 2  E6 8B                inc     FRETOP+1
0011C6r 2               L34CC:
0011C6r 2  68                   pla
0011C7r 2               L34CD:
0011C7r 2  86 79                stx     INDEX
0011C9r 2  84 7A                sty     INDEX+1
0011CBr 2  60                   rts
0011CCr 2               
0011CCr 2               ; ----------------------------------------------------------------------------
0011CCr 2               ; RELEASE TEMPORARY DESCRIPTOR IF Y,A = LASTPT
0011CCr 2               ; ----------------------------------------------------------------------------
0011CCr 2               FRETMS:
0011CCr 2               .ifdef KBD
0011CCr 2                       cpy     #$00
0011CCr 2               .else
0011CCr 2  C4 6F                cpy     LASTPT+1
0011CEr 2               .endif
0011CEr 2  D0 0C                bne     L34E2
0011D0r 2  C5 6E                cmp     LASTPT
0011D2r 2  D0 08                bne     L34E2
0011D4r 2  85 6D                sta     TEMPPT
0011D6r 2  E9 03                sbc     #$03
0011D8r 2  85 6E                sta     LASTPT
0011DAr 2  A0 00                ldy     #$00
0011DCr 2               L34E2:
0011DCr 2  60                   rts
0011DDr 2               
0011DDr 2               ; ----------------------------------------------------------------------------
0011DDr 2               ; "CHR$" FUNCTION
0011DDr 2               ; ----------------------------------------------------------------------------
0011DDr 2               CHRSTR:
0011DDr 2  20 rr rr             jsr     CONINT
0011E0r 2  8A                   txa
0011E1r 2  48                   pha
0011E2r 2  A9 01                lda     #$01
0011E4r 2  20 rr rr             jsr     STRSPA
0011E7r 2  68                   pla
0011E8r 2  A0 00                ldy     #$00
0011EAr 2  91 B9                sta     (FAC+1),y
0011ECr 2  68                   pla
0011EDr 2  68                   pla
0011EEr 2  4C rr rr             jmp     PUTNEW
0011F1r 2               
0011F1r 2               ; ----------------------------------------------------------------------------
0011F1r 2               ; "LEFT$" FUNCTION
0011F1r 2               ; ----------------------------------------------------------------------------
0011F1r 2               LEFTSTR:
0011F1r 2  20 rr rr             jsr     SUBSTRING_SETUP
0011F4r 2  D1 A7                cmp     (DSCPTR),y
0011F6r 2  98                   tya
0011F7r 2               SUBSTRING1:
0011F7r 2  90 04                bcc     L3503
0011F9r 2  B1 A7                lda     (DSCPTR),y
0011FBr 2  AA                   tax
0011FCr 2  98                   tya
0011FDr 2               L3503:
0011FDr 2  48                   pha
0011FEr 2               SUBSTRING2:
0011FEr 2  8A                   txa
0011FFr 2               SUBSTRING3:
0011FFr 2  48                   pha
001200r 2  20 rr rr             jsr     STRSPA
001203r 2  A5 A7                lda     DSCPTR
001205r 2  A4 A8                ldy     DSCPTR+1
001207r 2  20 rr rr             jsr     FRETMP
00120Ar 2  68                   pla
00120Br 2  A8                   tay
00120Cr 2  68                   pla
00120Dr 2  18                   clc
00120Er 2  65 79                adc     INDEX
001210r 2  85 79                sta     INDEX
001212r 2  90 02                bcc     L351C
001214r 2  E6 7A                inc     INDEX+1
001216r 2               L351C:
001216r 2  98                   tya
001217r 2  20 rr rr             jsr     MOVSTR1
00121Ar 2  4C rr rr             jmp     PUTNEW
00121Dr 2               
00121Dr 2               ; ----------------------------------------------------------------------------
00121Dr 2               ; "RIGHT$" FUNCTION
00121Dr 2               ; ----------------------------------------------------------------------------
00121Dr 2               RIGHTSTR:
00121Dr 2  20 rr rr             jsr     SUBSTRING_SETUP
001220r 2  18                   clc
001221r 2  F1 A7                sbc     (DSCPTR),y
001223r 2  49 FF                eor     #$FF
001225r 2  4C rr rr             jmp     SUBSTRING1
001228r 2               
001228r 2               ; ----------------------------------------------------------------------------
001228r 2               ; "MID$" FUNCTION
001228r 2               ; ----------------------------------------------------------------------------
001228r 2               MIDSTR:
001228r 2  A9 FF                lda     #$FF
00122Ar 2  85 BC                sta     FAC_LAST
00122Cr 2  20 D0 00             jsr     CHRGOT
00122Fr 2  C9 29                cmp     #$29
001231r 2  F0 06                beq     L353F
001233r 2  20 rr rr             jsr     CHKCOM
001236r 2  20 rr rr             jsr     GETBYT
001239r 2               L353F:
001239r 2  20 rr rr             jsr     SUBSTRING_SETUP
00123Cr 2               .ifdef CONFIG_2
00123Cr 2  F0 4B                beq     GOIQ
00123Er 2               .endif
00123Er 2  CA                   dex
00123Fr 2  8A                   txa
001240r 2  48                   pha
001241r 2  18                   clc
001242r 2  A2 00                ldx     #$00
001244r 2  F1 A7                sbc     (DSCPTR),y
001246r 2  B0 B6                bcs     SUBSTRING2
001248r 2  49 FF                eor     #$FF
00124Ar 2  C5 BC                cmp     FAC_LAST
00124Cr 2  90 B1                bcc     SUBSTRING3
00124Er 2  A5 BC                lda     FAC_LAST
001250r 2  B0 AD                bcs     SUBSTRING3
001252r 2               
001252r 2               ; ----------------------------------------------------------------------------
001252r 2               ; COMMON SETUP ROUTINE FOR LEFT$, RIGHT$, MID$:
001252r 2               ; REQUIRE ")"; POP RETURN ADRS, GET DESCRIPTOR
001252r 2               ; ADDRESS, GET 1ST PARAMETER OF COMMAND
001252r 2               ; ----------------------------------------------------------------------------
001252r 2               SUBSTRING_SETUP:
001252r 2  20 rr rr             jsr     CHKCLS
001255r 2  68                   pla
001256r 2               .ifndef CONFIG_11
001256r 2                       sta     JMPADRS+1
001256r 2                       pla
001256r 2                       sta     JMPADRS+2
001256r 2               .else
001256r 2  A8                   tay
001257r 2  68                   pla
001258r 2  85 AC                sta     Z52
00125Ar 2               .endif
00125Ar 2  68                   pla
00125Br 2  68                   pla
00125Cr 2  68                   pla
00125Dr 2  AA                   tax
00125Er 2  68                   pla
00125Fr 2  85 A7                sta     DSCPTR
001261r 2  68                   pla
001262r 2  85 A8                sta     DSCPTR+1
001264r 2               .ifdef CONFIG_11
001264r 2  A5 AC                lda     Z52
001266r 2  48                   pha
001267r 2  98                   tya
001268r 2  48                   pha
001269r 2               .endif
001269r 2  A0 00                ldy     #$00
00126Br 2  8A                   txa
00126Cr 2               .ifndef CONFIG_2
00126Cr 2                       beq     GOIQ
00126Cr 2               .endif
00126Cr 2               .ifndef CONFIG_11
00126Cr 2                       inc     JMPADRS+1
00126Cr 2                       jmp     (JMPADRS+1)
00126Cr 2               .else
00126Cr 2  60                   rts
00126Dr 2               .endif
00126Dr 2               
00126Dr 2               ; ----------------------------------------------------------------------------
00126Dr 2               ; "LEN" FUNCTION
00126Dr 2               ; ----------------------------------------------------------------------------
00126Dr 2               LEN:
00126Dr 2  20 rr rr             jsr     GETSTR
001270r 2               SNGFLT1:
001270r 2  4C rr rr             jmp     SNGFLT
001273r 2               
001273r 2               ; ----------------------------------------------------------------------------
001273r 2               ; IF LAST RESULT IS A TEMPORARY STRING, FREE IT
001273r 2               ; MAKE VALTYP NUMERIC, RETURN LENGTH IN Y-REG
001273r 2               ; ----------------------------------------------------------------------------
001273r 2               GETSTR:
001273r 2  20 rr rr             jsr     FRESTR
001276r 2  A2 00                ldx     #$00
001278r 2  86 66                stx     VALTYP
00127Ar 2  A8                   tay
00127Br 2  60                   rts
00127Cr 2               
00127Cr 2               ; ----------------------------------------------------------------------------
00127Cr 2               ; "ASC" FUNCTION
00127Cr 2               ; ----------------------------------------------------------------------------
00127Cr 2               ASC:
00127Cr 2  20 rr rr             jsr     GETSTR
00127Fr 2  F0 08                beq     GOIQ
001281r 2  A0 00                ldy     #$00
001283r 2  B1 79                lda     (INDEX),y
001285r 2  A8                   tay
001286r 2               .ifndef CONFIG_11A
001286r 2                       jmp     SNGFLT1
001286r 2               .else
001286r 2  4C rr rr             jmp     SNGFLT
001289r 2               .endif
001289r 2               ; ----------------------------------------------------------------------------
001289r 2               GOIQ:
001289r 2  4C rr rr             jmp     IQERR
00128Cr 2               
00128Cr 2               ; ----------------------------------------------------------------------------
00128Cr 2               ; SCAN TO NEXT CHARACTER AND CONVERT EXPRESSION
00128Cr 2               ; TO SINGLE BYTE IN X-REG
00128Cr 2               ; ----------------------------------------------------------------------------
00128Cr 2               GTBYTC:
00128Cr 2  20 CA 00             jsr     CHRGET
00128Fr 2               
00128Fr 2               ; ----------------------------------------------------------------------------
00128Fr 2               ; EVALUATE EXPRESSION AT TXTPTR, AND
00128Fr 2               ; CONVERT IT TO SINGLE BYTE IN X-REG
00128Fr 2               ; ----------------------------------------------------------------------------
00128Fr 2               GETBYT:
00128Fr 2  20 rr rr             jsr     FRMNUM
001292r 2               
001292r 2               ; ----------------------------------------------------------------------------
001292r 2               ; CONVERT (FAC) TO SINGLE BYTE INTEGER IN X-REG
001292r 2               ; ----------------------------------------------------------------------------
001292r 2               CONINT:
001292r 2  20 rr rr             jsr     MKINT
001295r 2  A6 BB                ldx     FAC_LAST-1
001297r 2  D0 F0                bne     GOIQ
001299r 2  A6 BC                ldx     FAC_LAST
00129Br 2  4C D0 00             jmp     CHRGOT
00129Er 2               
00129Er 2               ; ----------------------------------------------------------------------------
00129Er 2               ; "VAL" FUNCTION
00129Er 2               ; ----------------------------------------------------------------------------
00129Er 2               VAL:
00129Er 2  20 rr rr             jsr     GETSTR
0012A1r 2  D0 03                bne     L35AC
0012A3r 2  4C rr rr             jmp     ZERO_FAC
0012A6r 2               L35AC:
0012A6r 2  A6 D1                ldx     TXTPTR
0012A8r 2  A4 D2                ldy     TXTPTR+1
0012AAr 2  86 C8                stx     STRNG2
0012ACr 2  84 C9                sty     STRNG2+1
0012AEr 2  A6 79                ldx     INDEX
0012B0r 2  86 D1                stx     TXTPTR
0012B2r 2  18                   clc
0012B3r 2  65 79                adc     INDEX
0012B5r 2  85 7B                sta     DEST
0012B7r 2  A6 7A                ldx     INDEX+1
0012B9r 2  86 D2                stx     TXTPTR+1
0012BBr 2  90 01                bcc     L35C4
0012BDr 2  E8                   inx
0012BEr 2               L35C4:
0012BEr 2  86 7C                stx     DEST+1
0012C0r 2  A0 00                ldy     #$00
0012C2r 2  B1 7B                lda     (DEST),y
0012C4r 2  48                   pha
0012C5r 2  A9 00                lda     #$00
0012C7r 2  91 7B                sta     (DEST),y
0012C9r 2  20 D0 00             jsr     CHRGOT
0012CCr 2  20 rr rr             jsr     FIN
0012CFr 2  68                   pla
0012D0r 2  A0 00                ldy     #$00
0012D2r 2  91 7B                sta     (DEST),y
0012D4r 2               
0012D4r 2               ; ----------------------------------------------------------------------------
0012D4r 2               ; COPY STRNG2 INTO TXTPTR
0012D4r 2               ; ----------------------------------------------------------------------------
0012D4r 2               POINT:
0012D4r 2  A6 C8                ldx     STRNG2
0012D6r 2  A4 C9                ldy     STRNG2+1
0012D8r 2  86 D1                stx     TXTPTR
0012DAr 2  84 D2                sty     TXTPTR+1
0012DCr 2  60                   rts
0012DDr 2               
0012DDr 2               
0012DDr 1               .include "misc3.s"
0012DDr 2               ; KBD specific patches
0012DDr 2               
0012DDr 2               .segment "CODE"
0012DDr 2               
0012DDr 2               .ifdef KBD
0012DDr 2               VARTAB_MINUS_2_TO_AY:
0012DDr 2                       lda     VARTAB
0012DDr 2                       sec
0012DDr 2                       sbc     #$02
0012DDr 2                       ldy     VARTAB+1
0012DDr 2                       bcs     LF42C
0012DDr 2                       dey
0012DDr 2               LF42C:
0012DDr 2                       rts
0012DDr 2               
0012DDr 2               ; ----------------------------------------------------------------------------
0012DDr 2               GET_UPPER:
0012DDr 2                       lda     INPUTBUFFERX,x
0012DDr 2               LF430:
0012DDr 2                       cmp     #'a'
0012DDr 2                       bcc     LF43A
0012DDr 2                       cmp     #'z'+1
0012DDr 2                       bcs     LF43A
0012DDr 2               LF438:
0012DDr 2                       sbc     #$1F
0012DDr 2               LF43A:
0012DDr 2                       rts
0012DDr 2               
0012DDr 2               ; ----------------------------------------------------------------------------
0012DDr 2               GETLN:
0012DDr 2                       ldx     #$5D
0012DDr 2               LF43D:
0012DDr 2                       txa
0012DDr 2                       and     #$7F
0012DDr 2                       cmp     $0340
0012DDr 2                       beq     LF44D
0012DDr 2                       sta     $0340
0012DDr 2                       lda     #$03
0012DDr 2                       jsr     LDE48
0012DDr 2               LF44D:
0012DDr 2                       jsr     LDE7F
0012DDr 2                       bne     RTS4
0012DDr 2                       cpx     #$80
0012DDr 2                       bcc     LF44D
0012DDr 2               RTS4:
0012DDr 2                       rts
0012DDr 2               
0012DDr 2               ; ----------------------------------------------------------------------------
0012DDr 2               LF457:
0012DDr 2                       lda     TXTTAB
0012DDr 2                       ldx     TXTTAB+1
0012DDr 2               LF45B:
0012DDr 2                       sta     JMPADRS+1
0012DDr 2                       stx     JMPADRS+2
0012DDr 2                       ldy     #$01
0012DDr 2                       lda     (JMPADRS+1),y
0012DDr 2                       beq     LF438
0012DDr 2                       iny
0012DDr 2                       iny
0012DDr 2                       lda     (JMPADRS+1),y
0012DDr 2                       dey
0012DDr 2                       cmp     LINNUM+1
0012DDr 2                       bne     LF472
0012DDr 2                       lda     (JMPADRS+1),y
0012DDr 2                       cmp     LINNUM
0012DDr 2               LF472:
0012DDr 2                       bcs     LF43A
0012DDr 2                       dey
0012DDr 2                       lda     (JMPADRS+1),y
0012DDr 2                       tax
0012DDr 2                       dey
0012DDr 2                       lda     (JMPADRS+1),y
0012DDr 2                       bcc     LF45B
0012DDr 2               LF47D:
0012DDr 2                       jmp     (JMPADRS+1)
0012DDr 2               .endif
0012DDr 2               
0012DDr 1               .include "poke.s"
0012DDr 2               .segment "CODE"
0012DDr 2               
0012DDr 2               .ifndef CONFIG_NO_POKE
0012DDr 2               ; ----------------------------------------------------------------------------
0012DDr 2               ; EVALUATE "EXP1,EXP2"
0012DDr 2               ;
0012DDr 2               ; CONVERT EXP1 TO 16-BIT NUMBER IN LINNUM
0012DDr 2               ; CONVERT EXP2 TO 8-BIT NUMBER IN X-REG
0012DDr 2               ; ----------------------------------------------------------------------------
0012DDr 2               GTNUM:
0012DDr 2  20 rr rr             jsr     FRMNUM
0012E0r 2  20 rr rr             jsr     GETADR
0012E3r 2               
0012E3r 2               ; ----------------------------------------------------------------------------
0012E3r 2               ; EVALUATE ",EXPRESSION"
0012E3r 2               ; CONVERT EXPRESSION TO SINGLE BYTE IN X-REG
0012E3r 2               ; ----------------------------------------------------------------------------
0012E3r 2               COMBYTE:
0012E3r 2  20 rr rr             jsr     CHKCOM
0012E6r 2  4C rr rr             jmp     GETBYT
0012E9r 2               
0012E9r 2               ; ----------------------------------------------------------------------------
0012E9r 2               ; CONVERT (FAC) TO A 16-BIT VALUE IN LINNUM
0012E9r 2               ; ----------------------------------------------------------------------------
0012E9r 2               GETADR:
0012E9r 2  A5 BD                lda     FACSIGN
0012EBr 2                 .ifdef APPLE
0012EBr 2                       nop ; PATCH
0012EBr 2                       nop
0012EBr 2                 .else
0012EBr 2  30 9C                bmi     GOIQ
0012EDr 2                 .endif
0012EDr 2  A5 B8                lda     FAC
0012EFr 2  C9 91                cmp     #$91
0012F1r 2  B0 96                bcs     GOIQ
0012F3r 2  20 rr rr             jsr     QINT
0012F6r 2  A5 BB                lda     FAC_LAST-1
0012F8r 2  A4 BC                ldy     FAC_LAST
0012FAr 2  84 10                sty     LINNUM
0012FCr 2  85 11                sta     LINNUM+1
0012FEr 2  60                   rts
0012FFr 2               
0012FFr 2               ; ----------------------------------------------------------------------------
0012FFr 2               ; "PEEK" FUNCTION
0012FFr 2               ; ----------------------------------------------------------------------------
0012FFr 2               PEEK:
0012FFr 2               .ifdef CONFIG_PEEK_SAVE_LINNUM
0012FFr 2                       lda     LINNUM+1
0012FFr 2                       pha
0012FFr 2                       lda     LINNUM
0012FFr 2                       pha
0012FFr 2               .endif
0012FFr 2  20 rr rr             jsr     GETADR
001302r 2  A0 00                ldy     #$00
001304r 2               .ifdef CBM1
001304r 2               ; disallow PEEK between $C000 and $DFFF
001304r 2                       cmp     #$C0
001304r 2                       bcc     LD6F3
001304r 2                       cmp     #$E1
001304r 2                       bcc     LD6F6
001304r 2               LD6F3:
001304r 2               .endif
001304r 2               .ifdef CBM2
001304r 2               		nop ; patch that disables the compares above
001304r 2               		nop
001304r 2               		nop
001304r 2               		nop
001304r 2               		nop
001304r 2               		nop
001304r 2               		nop
001304r 2               		nop
001304r 2               .endif
001304r 2  B1 10                lda     (LINNUM),y
001306r 2  A8                   tay
001307r 2               .ifdef CONFIG_PEEK_SAVE_LINNUM
001307r 2                       pla
001307r 2                       sta     LINNUM
001307r 2                       pla
001307r 2                       sta     LINNUM+1
001307r 2               .endif
001307r 2               LD6F6:
001307r 2  4C rr rr             jmp     SNGFLT
00130Ar 2               
00130Ar 2               ; ----------------------------------------------------------------------------
00130Ar 2               ; "POKE" STATEMENT
00130Ar 2               ; ----------------------------------------------------------------------------
00130Ar 2               POKE:
00130Ar 2  20 rr rr             jsr     GTNUM
00130Dr 2  8A                   txa
00130Er 2  A0 00                ldy     #$00
001310r 2  91 10                sta     (LINNUM),y
001312r 2  60                   rts
001313r 2               
001313r 2               ; ----------------------------------------------------------------------------
001313r 2               ; "WAIT" STATEMENT
001313r 2               ; ----------------------------------------------------------------------------
001313r 2               WAIT:
001313r 2  20 rr rr             jsr     GTNUM
001316r 2  86 A0                stx     FORPNT
001318r 2  A2 00                ldx     #$00
00131Ar 2  20 D0 00             jsr     CHRGOT
00131Dr 2               .ifdef CONFIG_EASTER_EGG
00131Dr 2                       beq     EASTER_EGG
00131Dr 2               .else
00131Dr 2  F0 03                beq     L3628
00131Fr 2               .endif
00131Fr 2  20 rr rr             jsr     COMBYTE
001322r 2               L3628:
001322r 2  86 A1                stx     FORPNT+1
001324r 2  A0 00                ldy     #$00
001326r 2               L362C:
001326r 2  B1 10                lda     (LINNUM),y
001328r 2  45 A1                eor     FORPNT+1
00132Ar 2  25 A0                and     FORPNT
00132Cr 2  F0 F8                beq     L362C
00132Er 2               RTS3:
00132Er 2  60                   rts
00132Fr 2               .endif
00132Fr 2               
00132Fr 1               .include "float.s"
00132Fr 2               .segment "CODE"
00132Fr 2               
00132Fr 2               TEMP1X = TEMP1+(5-BYTES_FP)
00132Fr 2               
00132Fr 2               ; ----------------------------------------------------------------------------
00132Fr 2               ; ADD 0.5 TO FAC
00132Fr 2               ; ----------------------------------------------------------------------------
00132Fr 2               FADDH:
00132Fr 2  A9 rr                lda     #<CON_HALF
001331r 2  A0 rr                ldy     #>CON_HALF
001333r 2  4C rr rr             jmp     FADD
001336r 2               
001336r 2               ; ----------------------------------------------------------------------------
001336r 2               ; FAC = (Y,A) - FAC
001336r 2               ; ----------------------------------------------------------------------------
001336r 2               FSUB:
001336r 2  20 rr rr             jsr     LOAD_ARG_FROM_YA
001339r 2               
001339r 2               ; ----------------------------------------------------------------------------
001339r 2               ; FAC = ARG - FAC
001339r 2               ; ----------------------------------------------------------------------------
001339r 2               FSUBT:
001339r 2  A5 BD                lda     FACSIGN
00133Br 2  49 FF                eor     #$FF
00133Dr 2  85 BD                sta     FACSIGN
00133Fr 2  45 C5                eor     ARGSIGN
001341r 2  85 C6                sta     SGNCPR
001343r 2  A5 B8                lda     FAC
001345r 2  4C rr rr             jmp     FADDT
001348r 2               
001348r 2               ; ----------------------------------------------------------------------------
001348r 2               ; Commodore BASIC V2 Easter Egg
001348r 2               ; ----------------------------------------------------------------------------
001348r 2               .ifdef CONFIG_EASTER_EGG
001348r 2               EASTER_EGG:
001348r 2                       lda     LINNUM
001348r 2                       cmp     #<6502
001348r 2                       bne     L3628
001348r 2                       lda     LINNUM+1
001348r 2                       sbc     #>6502
001348r 2                       bne     L3628
001348r 2                       sta     LINNUM
001348r 2                       tay
001348r 2                       lda     #$80
001348r 2                       sta     LINNUM+1
001348r 2               LD758:
001348r 2                       ldx     #$0A
001348r 2               LD75A:
001348r 2                       lda     MICROSOFT-1,x
001348r 2                       and     #$3F
001348r 2                       sta     (LINNUM),y
001348r 2                       iny
001348r 2                       bne     LD766
001348r 2                       inc     LINNUM+1
001348r 2               LD766:
001348r 2                       dex
001348r 2                       bne     LD75A
001348r 2                       dec     FORPNT
001348r 2                       bne     LD758
001348r 2                       rts
001348r 2               .endif
001348r 2               
001348r 2               ; ----------------------------------------------------------------------------
001348r 2               ; SHIFT SMALLER ARGUMENT MORE THAN 7 BITS
001348r 2               ; ----------------------------------------------------------------------------
001348r 2               FADD1:
001348r 2  20 rr rr             jsr     SHIFT_RIGHT
00134Br 2  90 3C                bcc     FADD3
00134Dr 2               
00134Dr 2               ; ----------------------------------------------------------------------------
00134Dr 2               ; FAC = (Y,A) + FAC
00134Dr 2               ; ----------------------------------------------------------------------------
00134Dr 2               FADD:
00134Dr 2  20 rr rr             jsr     LOAD_ARG_FROM_YA
001350r 2               
001350r 2               ; ----------------------------------------------------------------------------
001350r 2               ; FAC = ARG + FAC
001350r 2               ; ----------------------------------------------------------------------------
001350r 2               FADDT:
001350r 2  D0 03                bne     L365B
001352r 2  4C rr rr             jmp     COPY_ARG_TO_FAC
001355r 2               L365B:
001355r 2  A6 C7                ldx     FACEXTENSION
001357r 2  86 AD                stx     ARGEXTENSION
001359r 2  A2 C0                ldx     #ARG
00135Br 2  A5 C0                lda     ARG
00135Dr 2               FADD2:
00135Dr 2  A8                   tay
00135Er 2               .ifdef KBD
00135Er 2                       beq     RTS4
00135Er 2               .else
00135Er 2  F0 CE                beq     RTS3
001360r 2               .endif
001360r 2  38                   sec
001361r 2  E5 B8                sbc     FAC
001363r 2  F0 24                beq     FADD3
001365r 2  90 12                bcc     L367F
001367r 2  84 B8                sty     FAC
001369r 2  A4 C5                ldy     ARGSIGN
00136Br 2  84 BD                sty     FACSIGN
00136Dr 2  49 FF                eor     #$FF
00136Fr 2  69 00                adc     #$00
001371r 2  A0 00                ldy     #$00
001373r 2  84 AD                sty     ARGEXTENSION
001375r 2  A2 B8                ldx     #FAC
001377r 2  D0 04                bne     L3683
001379r 2               L367F:
001379r 2  A0 00                ldy     #$00
00137Br 2  84 C7                sty     FACEXTENSION
00137Dr 2               L3683:
00137Dr 2  C9 F9                cmp     #$F9
00137Fr 2  30 C7                bmi     FADD1
001381r 2  A8                   tay
001382r 2  A5 C7                lda     FACEXTENSION
001384r 2  56 01                lsr     1,x
001386r 2  20 rr rr             jsr     SHIFT_RIGHT4
001389r 2               FADD3:
001389r 2  24 C6                bit     SGNCPR
00138Br 2  10 57                bpl     FADD4
00138Dr 2  A0 B8                ldy     #FAC
00138Fr 2  E0 C0                cpx     #ARG
001391r 2  F0 02                beq     L369B
001393r 2  A0 C0                ldy     #ARG
001395r 2               L369B:
001395r 2  38                   sec
001396r 2  49 FF                eor     #$FF
001398r 2  65 AD                adc     ARGEXTENSION
00139Ar 2  85 C7                sta     FACEXTENSION
00139Cr 2               .ifndef CONFIG_SMALL
00139Cr 2  B9 04 00             lda     4,y
00139Fr 2  F5 04                sbc     4,x
0013A1r 2  85 BC                sta     FAC+4
0013A3r 2               .endif
0013A3r 2  B9 03 00             lda     3,y
0013A6r 2  F5 03                sbc     3,x
0013A8r 2  85 BB                sta     FAC+3
0013AAr 2  B9 02 00             lda     2,y
0013ADr 2  F5 02                sbc     2,x
0013AFr 2  85 BA                sta     FAC+2
0013B1r 2  B9 01 00             lda     1,y
0013B4r 2  F5 01                sbc     1,x
0013B6r 2  85 B9                sta     FAC+1
0013B8r 2               
0013B8r 2               ; ----------------------------------------------------------------------------
0013B8r 2               ; NORMALIZE VALUE IN FAC
0013B8r 2               ; ----------------------------------------------------------------------------
0013B8r 2               NORMALIZE_FAC1:
0013B8r 2  B0 03                bcs     NORMALIZE_FAC2
0013BAr 2  20 rr rr             jsr     COMPLEMENT_FAC
0013BDr 2               NORMALIZE_FAC2:
0013BDr 2  A0 00                ldy     #$00
0013BFr 2  98                   tya
0013C0r 2  18                   clc
0013C1r 2               L36C7:
0013C1r 2  A6 B9                ldx     FAC+1
0013C3r 2  D0 4A                bne     NORMALIZE_FAC4
0013C5r 2  A6 BA                ldx     FAC+2
0013C7r 2  86 B9                stx     FAC+1
0013C9r 2  A6 BB                ldx     FAC+3
0013CBr 2  86 BA                stx     FAC+2
0013CDr 2               .ifdef CONFIG_SMALL
0013CDr 2                       ldx     FACEXTENSION
0013CDr 2                       stx     FAC+3
0013CDr 2               .else
0013CDr 2  A6 BC                ldx     FAC+4
0013CFr 2  86 BB                stx     FAC+3
0013D1r 2  A6 C7                ldx     FACEXTENSION
0013D3r 2  86 BC                stx     FAC+4
0013D5r 2               .endif
0013D5r 2  84 C7                sty     FACEXTENSION
0013D7r 2  69 08                adc     #$08
0013D9r 2               .ifdef CONFIG_2B
0013D9r 2               ; bugfix?
0013D9r 2               ; fix does not exist on AppleSoft 2
0013D9r 2                       cmp     #(MANTISSA_BYTES+1)*8
0013D9r 2               .else
0013D9r 2  C9 20                cmp     #MANTISSA_BYTES*8
0013DBr 2               .endif
0013DBr 2  D0 E4                bne     L36C7
0013DDr 2               
0013DDr 2               ; ----------------------------------------------------------------------------
0013DDr 2               ; SET FAC = 0
0013DDr 2               ; (ONLY NECESSARY TO ZERO EXPONENT AND SIGN CELLS)
0013DDr 2               ; ----------------------------------------------------------------------------
0013DDr 2               ZERO_FAC:
0013DDr 2  A9 00                lda     #$00
0013DFr 2               STA_IN_FAC_SIGN_AND_EXP:
0013DFr 2  85 B8                sta     FAC
0013E1r 2               STA_IN_FAC_SIGN:
0013E1r 2  85 BD                sta     FACSIGN
0013E3r 2  60                   rts
0013E4r 2               
0013E4r 2               ; ----------------------------------------------------------------------------
0013E4r 2               ; ADD MANTISSAS OF FAC AND ARG INTO FAC
0013E4r 2               ; ----------------------------------------------------------------------------
0013E4r 2               FADD4:
0013E4r 2  65 AD                adc     ARGEXTENSION
0013E6r 2  85 C7                sta     FACEXTENSION
0013E8r 2               .ifndef CONFIG_SMALL
0013E8r 2  A5 BC                lda     FAC+4
0013EAr 2  65 C4                adc     ARG+4
0013ECr 2  85 BC                sta     FAC+4
0013EEr 2               .endif
0013EEr 2  A5 BB                lda     FAC+3
0013F0r 2  65 C3                adc     ARG+3
0013F2r 2  85 BB                sta     FAC+3
0013F4r 2  A5 BA                lda     FAC+2
0013F6r 2  65 C2                adc     ARG+2
0013F8r 2  85 BA                sta     FAC+2
0013FAr 2  A5 B9                lda     FAC+1
0013FCr 2  65 C1                adc     ARG+1
0013FEr 2  85 B9                sta     FAC+1
001400r 2  4C rr rr             jmp     NORMALIZE_FAC5
001403r 2               
001403r 2               ; ----------------------------------------------------------------------------
001403r 2               ; FINISH NORMALIZING FAC
001403r 2               ; ----------------------------------------------------------------------------
001403r 2               NORMALIZE_FAC3:
001403r 2  69 01                adc     #$01
001405r 2  06 C7                asl     FACEXTENSION
001407r 2               .ifndef CONFIG_SMALL
001407r 2  26 BC                rol     FAC+4
001409r 2               .endif
001409r 2  26 BB                rol     FAC+3
00140Br 2  26 BA                rol     FAC+2
00140Dr 2  26 B9                rol     FAC+1
00140Fr 2               NORMALIZE_FAC4:
00140Fr 2  10 F2                bpl     NORMALIZE_FAC3
001411r 2  38                   sec
001412r 2  E5 B8                sbc     FAC
001414r 2  B0 C7                bcs     ZERO_FAC
001416r 2  49 FF                eor     #$FF
001418r 2  69 01                adc     #$01
00141Ar 2  85 B8                sta     FAC
00141Cr 2               NORMALIZE_FAC5:
00141Cr 2  90 0E                bcc     L3764
00141Er 2               NORMALIZE_FAC6:
00141Er 2  E6 B8                inc     FAC
001420r 2  F0 42                beq     OVERFLOW
001422r 2               .ifndef CONFIG_ROR_WORKAROUND
001422r 2  66 B9                ror     FAC+1
001424r 2  66 BA                ror     FAC+2
001426r 2  66 BB                ror     FAC+3
001428r 2                 .ifndef CONFIG_SMALL
001428r 2  66 BC                ror     FAC+4
00142Ar 2                 .endif
00142Ar 2  66 C7                ror     FACEXTENSION
00142Cr 2               .else
00142Cr 2                       lda     #$00
00142Cr 2                       bcc     L372E
00142Cr 2                       lda     #$80
00142Cr 2               L372E:
00142Cr 2                       lsr     FAC+1
00142Cr 2                       ora     FAC+1
00142Cr 2                       sta     FAC+1
00142Cr 2                       lda     #$00
00142Cr 2                       bcc     L373A
00142Cr 2                       lda     #$80
00142Cr 2               L373A:
00142Cr 2                       lsr     FAC+2
00142Cr 2                       ora     FAC+2
00142Cr 2                       sta     FAC+2
00142Cr 2                       lda     #$00
00142Cr 2                       bcc     L3746
00142Cr 2                       lda     #$80
00142Cr 2               L3746:
00142Cr 2                       lsr     FAC+3
00142Cr 2                       ora     FAC+3
00142Cr 2                       sta     FAC+3
00142Cr 2                       lda     #$00
00142Cr 2                       bcc     L3752
00142Cr 2                       lda     #$80
00142Cr 2               L3752:
00142Cr 2                       lsr     FAC+4
00142Cr 2                       ora     FAC+4
00142Cr 2                       sta     FAC+4
00142Cr 2                       lda     #$00
00142Cr 2                       bcc     L375E
00142Cr 2                       lda     #$80
00142Cr 2               L375E:
00142Cr 2                       lsr     FACEXTENSION
00142Cr 2                       ora     FACEXTENSION
00142Cr 2                       sta     FACEXTENSION
00142Cr 2               .endif
00142Cr 2               L3764:
00142Cr 2  60                   rts
00142Dr 2               
00142Dr 2               ; ----------------------------------------------------------------------------
00142Dr 2               ; 2'S COMPLEMENT OF FAC
00142Dr 2               ; ----------------------------------------------------------------------------
00142Dr 2               COMPLEMENT_FAC:
00142Dr 2  A5 BD                lda     FACSIGN
00142Fr 2  49 FF                eor     #$FF
001431r 2  85 BD                sta     FACSIGN
001433r 2               
001433r 2               ; ----------------------------------------------------------------------------
001433r 2               ; 2'S COMPLEMENT OF FAC MANTISSA ONLY
001433r 2               ; ----------------------------------------------------------------------------
001433r 2               COMPLEMENT_FAC_MANTISSA:
001433r 2  A5 B9                lda     FAC+1
001435r 2  49 FF                eor     #$FF
001437r 2  85 B9                sta     FAC+1
001439r 2  A5 BA                lda     FAC+2
00143Br 2  49 FF                eor     #$FF
00143Dr 2  85 BA                sta     FAC+2
00143Fr 2  A5 BB                lda     FAC+3
001441r 2  49 FF                eor     #$FF
001443r 2  85 BB                sta     FAC+3
001445r 2               .ifndef CONFIG_SMALL
001445r 2  A5 BC                lda     FAC+4
001447r 2  49 FF                eor     #$FF
001449r 2  85 BC                sta     FAC+4
00144Br 2               .endif
00144Br 2  A5 C7                lda     FACEXTENSION
00144Dr 2  49 FF                eor     #$FF
00144Fr 2  85 C7                sta     FACEXTENSION
001451r 2  E6 C7                inc     FACEXTENSION
001453r 2  D0 0E                bne     RTS12
001455r 2               
001455r 2               ; ----------------------------------------------------------------------------
001455r 2               ; INCREMENT FAC MANTISSA
001455r 2               ; ----------------------------------------------------------------------------
001455r 2               INCREMENT_FAC_MANTISSA:
001455r 2               .ifndef CONFIG_SMALL
001455r 2  E6 BC                inc     FAC+4
001457r 2  D0 0A                bne     RTS12
001459r 2               .endif
001459r 2  E6 BB                inc     FAC+3
00145Br 2  D0 06                bne     RTS12
00145Dr 2  E6 BA                inc     FAC+2
00145Fr 2  D0 02                bne     RTS12
001461r 2  E6 B9                inc     FAC+1
001463r 2               RTS12:
001463r 2  60                   rts
001464r 2               OVERFLOW:
001464r 2  A2 45                ldx     #ERR_OVERFLOW
001466r 2  4C rr rr             jmp     ERROR
001469r 2               
001469r 2               ; ----------------------------------------------------------------------------
001469r 2               ; SHIFT 1,X THRU 5,X RIGHT
001469r 2               ; (A) = NEGATIVE OF SHIFT COUNT
001469r 2               ; (X) = POINTER TO BYTES TO BE SHIFTED
001469r 2               ;
001469r 2               ; RETURN WITH (Y)=0, CARRY=0, EXTENSION BITS IN A-REG
001469r 2               ; ----------------------------------------------------------------------------
001469r 2               SHIFT_RIGHT1:
001469r 2  A2 7C                ldx     #RESULT-1
00146Br 2               SHIFT_RIGHT2:
00146Br 2               .ifdef CONFIG_SMALL
00146Br 2                       ldy     3,x
00146Br 2               .else
00146Br 2  B4 04                ldy     4,x
00146Dr 2               .endif
00146Dr 2  84 C7                sty     FACEXTENSION
00146Fr 2               .ifndef CONFIG_SMALL
00146Fr 2  B4 03                ldy     3,x
001471r 2  94 04                sty     4,x
001473r 2               .endif
001473r 2  B4 02                ldy     2,x
001475r 2  94 03                sty     3,x
001477r 2  B4 01                ldy     1,x
001479r 2  94 02                sty     2,x
00147Br 2  A4 BF                ldy     SHIFTSIGNEXT
00147Dr 2  94 01                sty     1,x
00147Fr 2               
00147Fr 2               ; ----------------------------------------------------------------------------
00147Fr 2               ; MAIN ENTRY TO RIGHT SHIFT SUBROUTINE
00147Fr 2               ; ----------------------------------------------------------------------------
00147Fr 2               SHIFT_RIGHT:
00147Fr 2  69 08                adc     #$08
001481r 2  30 E8                bmi     SHIFT_RIGHT2
001483r 2  F0 E6                beq     SHIFT_RIGHT2
001485r 2  E9 08                sbc     #$08
001487r 2  A8                   tay
001488r 2  A5 C7                lda     FACEXTENSION
00148Ar 2  B0 14                bcs     SHIFT_RIGHT5
00148Cr 2               .ifndef CONFIG_ROR_WORKAROUND
00148Cr 2               LB588:
00148Cr 2  16 01                asl     1,x
00148Er 2  90 02                bcc     LB58E
001490r 2  F6 01                inc     1,x
001492r 2               LB58E:
001492r 2  76 01                ror     1,x
001494r 2  76 01                ror     1,x
001496r 2               
001496r 2               ; ----------------------------------------------------------------------------
001496r 2               ; ENTER HERE FOR SHORT SHIFTS WITH NO SIGN EXTENSION
001496r 2               ; ----------------------------------------------------------------------------
001496r 2               SHIFT_RIGHT4:
001496r 2  76 02                ror     2,x
001498r 2  76 03                ror     3,x
00149Ar 2                 .ifndef CONFIG_SMALL
00149Ar 2  76 04                ror     4,x
00149Cr 2                 .endif
00149Cr 2  6A                   ror     a
00149Dr 2  C8                   iny
00149Er 2  D0 EC                bne     LB588
0014A0r 2               .else
0014A0r 2               L37C4:
0014A0r 2                       pha
0014A0r 2                       lda     1,x
0014A0r 2                       and     #$80
0014A0r 2                       lsr     1,x
0014A0r 2                       ora     1,x
0014A0r 2                       sta     1,x
0014A0r 2                       .byte   $24
0014A0r 2               SHIFT_RIGHT4:
0014A0r 2                       pha
0014A0r 2                       lda     #$00
0014A0r 2                       bcc     L37D7
0014A0r 2                       lda     #$80
0014A0r 2               L37D7:
0014A0r 2                       lsr     2,x
0014A0r 2                       ora     2,x
0014A0r 2                       sta     2,x
0014A0r 2                       lda     #$00
0014A0r 2                       bcc     L37E3
0014A0r 2                       lda     #$80
0014A0r 2               L37E3:
0014A0r 2                       lsr     3,x
0014A0r 2                       ora     3,x
0014A0r 2                       sta     3,x
0014A0r 2                       lda     #$00
0014A0r 2                       bcc     L37EF
0014A0r 2                       lda     #$80
0014A0r 2               L37EF:
0014A0r 2                       lsr     4,x
0014A0r 2                       ora     4,x
0014A0r 2                       sta     4,x
0014A0r 2                       pla
0014A0r 2                       php
0014A0r 2                       lsr     a
0014A0r 2                       plp
0014A0r 2                       bcc     L37FD
0014A0r 2                       ora     #$80
0014A0r 2               L37FD:
0014A0r 2                       iny
0014A0r 2                       bne     L37C4
0014A0r 2               .endif
0014A0r 2               SHIFT_RIGHT5:
0014A0r 2  18                   clc
0014A1r 2  60                   rts
0014A2r 2               
0014A2r 2               ; ----------------------------------------------------------------------------
0014A2r 2               .ifdef CONFIG_SMALL
0014A2r 2               CON_ONE:
0014A2r 2                       .byte   $81,$00,$00,$00
0014A2r 2               POLY_LOG:
0014A2r 2               		.byte	$02
0014A2r 2               		.byte   $80,$19,$56,$62
0014A2r 2               		.byte   $80,$76,$22,$F3
0014A2r 2               		.byte   $82,$38,$AA,$40
0014A2r 2               CON_SQR_HALF:
0014A2r 2               		.byte   $80,$35,$04,$F3
0014A2r 2               CON_SQR_TWO:
0014A2r 2               		.byte   $81,$35,$04,$F3
0014A2r 2               CON_NEG_HALF:
0014A2r 2               		.byte   $80,$80,$00,$00
0014A2r 2               CON_LOG_TWO:
0014A2r 2               		.byte   $80,$31,$72,$18
0014A2r 2               .else
0014A2r 2               CON_ONE:
0014A2r 2  81 00 00 00          .byte   $81,$00,$00,$00,$00
0014A6r 2  00           
0014A7r 2               POLY_LOG:
0014A7r 2  03                   .byte   $03
0014A8r 2  7F 5E 56 CB  		.byte   $7F,$5E,$56,$CB,$79
0014ACr 2  79           
0014ADr 2  80 13 9B 0B  		.byte   $80,$13,$9B,$0B,$64
0014B1r 2  64           
0014B2r 2  80 76 38 93  		.byte   $80,$76,$38,$93,$16
0014B6r 2  16           
0014B7r 2  82 38 AA 3B          .byte   $82,$38,$AA,$3B,$20
0014BBr 2  20           
0014BCr 2               CON_SQR_HALF:
0014BCr 2  80 35 04 F3          .byte   $80,$35,$04,$F3,$34
0014C0r 2  34           
0014C1r 2               CON_SQR_TWO:
0014C1r 2  81 35 04 F3          .byte   $81,$35,$04,$F3,$34
0014C5r 2  34           
0014C6r 2               CON_NEG_HALF:
0014C6r 2  80 80 00 00          .byte   $80,$80,$00,$00,$00
0014CAr 2  00           
0014CBr 2               CON_LOG_TWO:
0014CBr 2  80 31 72 17          .byte   $80,$31,$72,$17,$F8
0014CFr 2  F8           
0014D0r 2               .endif
0014D0r 2               
0014D0r 2               ; ----------------------------------------------------------------------------
0014D0r 2               ; "LOG" FUNCTION
0014D0r 2               ; ----------------------------------------------------------------------------
0014D0r 2               LOG:
0014D0r 2  20 rr rr             jsr     SIGN
0014D3r 2  F0 02                beq     GIQ
0014D5r 2  10 03                bpl     LOG2
0014D7r 2               GIQ:
0014D7r 2  4C rr rr             jmp     IQERR
0014DAr 2               LOG2:
0014DAr 2  A5 B8                lda     FAC
0014DCr 2  E9 7F                sbc     #$7F
0014DEr 2  48                   pha
0014DFr 2  A9 80                lda     #$80
0014E1r 2  85 B8                sta     FAC
0014E3r 2  A9 rr                lda     #<CON_SQR_HALF
0014E5r 2  A0 rr                ldy     #>CON_SQR_HALF
0014E7r 2  20 rr rr             jsr     FADD
0014EAr 2  A9 rr                lda     #<CON_SQR_TWO
0014ECr 2  A0 rr                ldy     #>CON_SQR_TWO
0014EEr 2  20 rr rr             jsr     FDIV
0014F1r 2  A9 rr                lda     #<CON_ONE
0014F3r 2  A0 rr                ldy     #>CON_ONE
0014F5r 2  20 rr rr             jsr     FSUB
0014F8r 2  A9 rr                lda     #<POLY_LOG
0014FAr 2  A0 rr                ldy     #>POLY_LOG
0014FCr 2  20 rr rr             jsr     POLYNOMIAL_ODD
0014FFr 2  A9 rr                lda     #<CON_NEG_HALF
001501r 2  A0 rr                ldy     #>CON_NEG_HALF
001503r 2  20 rr rr             jsr     FADD
001506r 2  68                   pla
001507r 2  20 rr rr             jsr     ADDACC
00150Ar 2  A9 rr                lda     #<CON_LOG_TWO
00150Cr 2  A0 rr                ldy     #>CON_LOG_TWO
00150Er 2               
00150Er 2               ; ----------------------------------------------------------------------------
00150Er 2               ; FAC = (Y,A) * FAC
00150Er 2               ; ----------------------------------------------------------------------------
00150Er 2               FMULT:
00150Er 2  20 rr rr             jsr     LOAD_ARG_FROM_YA
001511r 2               
001511r 2               ; ----------------------------------------------------------------------------
001511r 2               ; FAC = ARG * FAC
001511r 2               ; ----------------------------------------------------------------------------
001511r 2               FMULTT:
001511r 2               .ifndef CONFIG_11
001511r 2                       beq     L3903
001511r 2               .else
001511r 2  D0 03 4C rr          jeq     L3903
001515r 2  rr           
001516r 2               .endif
001516r 2  20 rr rr             jsr     ADD_EXPONENTS
001519r 2  A9 00                lda     #$00
00151Br 2  85 7D                sta     RESULT
00151Dr 2  85 7E                sta     RESULT+1
00151Fr 2  85 7F                sta     RESULT+2
001521r 2               .ifndef CONFIG_SMALL
001521r 2  85 80                sta     RESULT+3
001523r 2               .endif
001523r 2  A5 C7                lda     FACEXTENSION
001525r 2  20 rr rr             jsr     MULTIPLY1
001528r 2               .ifndef CONFIG_SMALL
001528r 2  A5 BC                lda     FAC+4
00152Ar 2  20 rr rr             jsr     MULTIPLY1
00152Dr 2               .endif
00152Dr 2  A5 BB                lda     FAC+3
00152Fr 2  20 rr rr             jsr     MULTIPLY1
001532r 2  A5 BA                lda     FAC+2
001534r 2  20 rr rr             jsr     MULTIPLY1
001537r 2  A5 B9                lda     FAC+1
001539r 2  20 rr rr             jsr     MULTIPLY2
00153Cr 2  4C rr rr             jmp     COPY_RESULT_INTO_FAC
00153Fr 2               
00153Fr 2               ; ----------------------------------------------------------------------------
00153Fr 2               ; MULTIPLY ARG BY (A) INTO RESULT
00153Fr 2               ; ----------------------------------------------------------------------------
00153Fr 2               MULTIPLY1:
00153Fr 2  D0 03                bne     MULTIPLY2
001541r 2  4C rr rr             jmp     SHIFT_RIGHT1
001544r 2               MULTIPLY2:
001544r 2  4A                   lsr     a
001545r 2  09 80                ora     #$80
001547r 2               L38A7:
001547r 2  A8                   tay
001548r 2  90 19                bcc     L38C3
00154Ar 2  18                   clc
00154Br 2               .ifndef CONFIG_SMALL
00154Br 2  A5 80                lda     RESULT+3
00154Dr 2  65 C4                adc     ARG+4
00154Fr 2  85 80                sta     RESULT+3
001551r 2               .endif
001551r 2  A5 7F                lda     RESULT+2
001553r 2  65 C3                adc     ARG+3
001555r 2  85 7F                sta     RESULT+2
001557r 2  A5 7E                lda     RESULT+1
001559r 2  65 C2                adc     ARG+2
00155Br 2  85 7E                sta     RESULT+1
00155Dr 2  A5 7D                lda     RESULT
00155Fr 2  65 C1                adc     ARG+1
001561r 2  85 7D                sta     RESULT
001563r 2               L38C3:
001563r 2               .ifndef CONFIG_ROR_WORKAROUND
001563r 2  66 7D                ror     RESULT
001565r 2  66 7E                ror     RESULT+1
001567r 2               .ifdef APPLE_BAD_BYTE
001567r 2               ; this seems to be a bad byte in the dump
001567r 2               		.byte	RESULT+2,RESULT+2 ; XXX BUG!
001567r 2               .else
001567r 2  66 7F                ror     RESULT+2
001569r 2               .endif
001569r 2               .ifndef CONFIG_SMALL
001569r 2  66 80                ror     RESULT+3
00156Br 2               .endif
00156Br 2  66 C7                ror     FACEXTENSION
00156Dr 2               .else
00156Dr 2                       lda     #$00
00156Dr 2                       bcc     L38C9
00156Dr 2                       lda     #$80
00156Dr 2               L38C9:
00156Dr 2                       lsr     RESULT
00156Dr 2                       ora     RESULT
00156Dr 2                       sta     RESULT
00156Dr 2                       lda     #$00
00156Dr 2                       bcc     L38D5
00156Dr 2                       lda     #$80
00156Dr 2               L38D5:
00156Dr 2                       lsr     RESULT+1
00156Dr 2                       ora     RESULT+1
00156Dr 2                       sta     RESULT+1
00156Dr 2                       lda     #$00
00156Dr 2                       bcc     L38E1
00156Dr 2                       lda     #$80
00156Dr 2               L38E1:
00156Dr 2                       lsr     RESULT+2
00156Dr 2                       ora     RESULT+2
00156Dr 2                       sta     RESULT+2
00156Dr 2                       lda     #$00
00156Dr 2                       bcc     L38ED
00156Dr 2                       lda     #$80
00156Dr 2               L38ED:
00156Dr 2                       lsr     RESULT+3
00156Dr 2                       ora     RESULT+3
00156Dr 2                       sta     RESULT+3
00156Dr 2                       lda     #$00
00156Dr 2                       bcc     L38F9
00156Dr 2                       lda     #$80
00156Dr 2               L38F9:
00156Dr 2                       lsr     FACEXTENSION
00156Dr 2                       ora     FACEXTENSION
00156Dr 2                       sta     FACEXTENSION
00156Dr 2               .endif
00156Dr 2  98                   tya
00156Er 2  4A                   lsr     a
00156Fr 2  D0 D6                bne     L38A7
001571r 2               L3903:
001571r 2  60                   rts
001572r 2               
001572r 2               ; ----------------------------------------------------------------------------
001572r 2               ; UNPACK NUMBER AT (Y,A) INTO ARG
001572r 2               ; ----------------------------------------------------------------------------
001572r 2               LOAD_ARG_FROM_YA:
001572r 2  85 79                sta     INDEX
001574r 2  84 7A                sty     INDEX+1
001576r 2  A0 04                ldy     #BYTES_FP-1
001578r 2               .ifndef CONFIG_SMALL
001578r 2  B1 79                lda     (INDEX),y
00157Ar 2  85 C4                sta     ARG+4
00157Cr 2  88                   dey
00157Dr 2               .endif
00157Dr 2  B1 79                lda     (INDEX),y
00157Fr 2  85 C3                sta     ARG+3
001581r 2  88                   dey
001582r 2  B1 79                lda     (INDEX),y
001584r 2  85 C2                sta     ARG+2
001586r 2  88                   dey
001587r 2  B1 79                lda     (INDEX),y
001589r 2  85 C5                sta     ARGSIGN
00158Br 2  45 BD                eor     FACSIGN
00158Dr 2  85 C6                sta     SGNCPR
00158Fr 2  A5 C5                lda     ARGSIGN
001591r 2  09 80                ora     #$80
001593r 2  85 C1                sta     ARG+1
001595r 2  88                   dey
001596r 2  B1 79                lda     (INDEX),y
001598r 2  85 C0                sta     ARG
00159Ar 2  A5 B8                lda     FAC
00159Cr 2  60                   rts
00159Dr 2               
00159Dr 2               ; ----------------------------------------------------------------------------
00159Dr 2               ; ADD EXPONENTS OF ARG AND FAC
00159Dr 2               ; (CALLED BY FMULT AND FDIV)
00159Dr 2               ;
00159Dr 2               ; ALSO CHECK FOR OVERFLOW, AND SET RESULT SIGN
00159Dr 2               ; ----------------------------------------------------------------------------
00159Dr 2               ADD_EXPONENTS:
00159Dr 2  A5 C0                lda     ARG
00159Fr 2               ADD_EXPONENTS1:
00159Fr 2  F0 1F                beq     ZERO
0015A1r 2  18                   clc
0015A2r 2  65 B8                adc     FAC
0015A4r 2  90 04                bcc     L393C
0015A6r 2  30 1D                bmi     JOV
0015A8r 2  18                   clc
0015A9r 2  2C                   .byte   $2C
0015AAr 2               L393C:
0015AAr 2  10 14                bpl     ZERO
0015ACr 2  69 80                adc     #$80
0015AEr 2  85 B8                sta     FAC
0015B0r 2  D0 03                bne     L3947
0015B2r 2  4C rr rr             jmp     STA_IN_FAC_SIGN
0015B5r 2               L3947:
0015B5r 2  A5 C6                lda     SGNCPR
0015B7r 2  85 BD                sta     FACSIGN
0015B9r 2  60                   rts
0015BAr 2               
0015BAr 2               ; ----------------------------------------------------------------------------
0015BAr 2               ; IF (FAC) IS POSITIVE, GIVE "OVERFLOW" ERROR
0015BAr 2               ; IF (FAC) IS NEGATIVE, SET FAC=0, POP ONE RETURN, AND RTS
0015BAr 2               ; CALLED FROM "EXP" FUNCTION
0015BAr 2               ; ----------------------------------------------------------------------------
0015BAr 2               OUTOFRNG:
0015BAr 2  A5 BD                lda     FACSIGN
0015BCr 2  49 FF                eor     #$FF
0015BEr 2  30 05                bmi     JOV
0015C0r 2               
0015C0r 2               ; ----------------------------------------------------------------------------
0015C0r 2               ; POP RETURN ADDRESS AND SET FAC=0
0015C0r 2               ; ----------------------------------------------------------------------------
0015C0r 2               ZERO:
0015C0r 2  68                   pla
0015C1r 2  68                   pla
0015C2r 2  4C rr rr             jmp     ZERO_FAC
0015C5r 2               JOV:
0015C5r 2  4C rr rr             jmp     OVERFLOW
0015C8r 2               
0015C8r 2               ; ----------------------------------------------------------------------------
0015C8r 2               ; MULTIPLY FAC BY 10
0015C8r 2               ; ----------------------------------------------------------------------------
0015C8r 2               MUL10:
0015C8r 2  20 rr rr             jsr     COPY_FAC_TO_ARG_ROUNDED
0015CBr 2  AA                   tax
0015CCr 2  F0 10                beq     L3970
0015CEr 2  18                   clc
0015CFr 2  69 02                adc     #$02
0015D1r 2  B0 F2                bcs     JOV
0015D3r 2               LD9BF:
0015D3r 2  A2 00                ldx     #$00
0015D5r 2  86 C6                stx     SGNCPR
0015D7r 2  20 rr rr             jsr     FADD2
0015DAr 2  E6 B8                inc     FAC
0015DCr 2  F0 E7                beq     JOV
0015DEr 2               L3970:
0015DEr 2  60                   rts
0015DFr 2               
0015DFr 2               ; ----------------------------------------------------------------------------
0015DFr 2               CONTEN:
0015DFr 2               .ifdef CONFIG_SMALL
0015DFr 2                       .byte   $84,$20,$00,$00
0015DFr 2               .else
0015DFr 2  84 20 00 00          .byte   $84,$20,$00,$00,$00
0015E3r 2  00           
0015E4r 2               .endif
0015E4r 2               
0015E4r 2               ; ----------------------------------------------------------------------------
0015E4r 2               ; DIVIDE FAC BY 10
0015E4r 2               ; ----------------------------------------------------------------------------
0015E4r 2               DIV10:
0015E4r 2  20 rr rr             jsr     COPY_FAC_TO_ARG_ROUNDED
0015E7r 2  A9 rr                lda     #<CONTEN
0015E9r 2  A0 rr                ldy     #>CONTEN
0015EBr 2  A2 00                ldx     #$00
0015EDr 2               
0015EDr 2               ; ----------------------------------------------------------------------------
0015EDr 2               ; FAC = ARG / (Y,A)
0015EDr 2               ; ----------------------------------------------------------------------------
0015EDr 2               DIV:
0015EDr 2  86 C6                stx     SGNCPR
0015EFr 2  20 rr rr             jsr     LOAD_FAC_FROM_YA
0015F2r 2  4C rr rr             jmp     FDIVT
0015F5r 2               
0015F5r 2               ; ----------------------------------------------------------------------------
0015F5r 2               ; FAC = (Y,A) / FAC
0015F5r 2               ; ----------------------------------------------------------------------------
0015F5r 2               FDIV:
0015F5r 2  20 rr rr             jsr     LOAD_ARG_FROM_YA
0015F8r 2               
0015F8r 2               ; ----------------------------------------------------------------------------
0015F8r 2               ; FAC = ARG / FAC
0015F8r 2               ; ----------------------------------------------------------------------------
0015F8r 2               FDIVT:
0015F8r 2  F0 76                beq     L3A02
0015FAr 2  20 rr rr             jsr     ROUND_FAC
0015FDr 2  A9 00                lda     #$00
0015FFr 2  38                   sec
001600r 2  E5 B8                sbc     FAC
001602r 2  85 B8                sta     FAC
001604r 2  20 rr rr             jsr     ADD_EXPONENTS
001607r 2  E6 B8                inc     FAC
001609r 2  F0 BA                beq     JOV
00160Br 2  A2 FC                ldx     #-MANTISSA_BYTES
00160Dr 2  A9 01                lda     #$01
00160Fr 2               L39A1:
00160Fr 2  A4 C1                ldy     ARG+1
001611r 2  C4 B9                cpy     FAC+1
001613r 2  D0 10                bne     L39B7
001615r 2  A4 C2                ldy     ARG+2
001617r 2  C4 BA                cpy     FAC+2
001619r 2  D0 0A                bne     L39B7
00161Br 2  A4 C3                ldy     ARG+3
00161Dr 2  C4 BB                cpy     FAC+3
00161Fr 2               .ifndef CONFIG_SMALL
00161Fr 2  D0 04                bne     L39B7
001621r 2  A4 C4                ldy     ARG+4
001623r 2  C4 BC                cpy     FAC+4
001625r 2               .endif
001625r 2               L39B7:
001625r 2  08                   php
001626r 2  2A                   rol     a
001627r 2  90 09                bcc     L39C4
001629r 2  E8                   inx
00162Ar 2  95 80                sta     RESULT_LAST-1,x
00162Cr 2  F0 32                beq     L39F2
00162Er 2  10 34                bpl     L39F6
001630r 2  A9 01                lda     #$01
001632r 2               L39C4:
001632r 2  28                   plp
001633r 2  B0 0E                bcs     L39D5
001635r 2               L39C7:
001635r 2  06 C4                asl     ARG_LAST
001637r 2               .ifndef CONFIG_SMALL
001637r 2  26 C3                rol     ARG+3
001639r 2               .endif
001639r 2  26 C2                rol     ARG+2
00163Br 2  26 C1                rol     ARG+1
00163Dr 2  B0 E6                bcs     L39B7
00163Fr 2  30 CE                bmi     L39A1
001641r 2  10 E2                bpl     L39B7
001643r 2               L39D5:
001643r 2  A8                   tay
001644r 2               .ifndef CONFIG_SMALL
001644r 2  A5 C4                lda     ARG+4
001646r 2  E5 BC                sbc     FAC+4
001648r 2  85 C4                sta     ARG+4
00164Ar 2               .endif
00164Ar 2  A5 C3                lda     ARG+3
00164Cr 2  E5 BB                sbc     FAC+3
00164Er 2  85 C3                sta     ARG+3
001650r 2  A5 C2                lda     ARG+2
001652r 2  E5 BA                sbc     FAC+2
001654r 2  85 C2                sta     ARG+2
001656r 2  A5 C1                lda     ARG+1
001658r 2  E5 B9                sbc     FAC+1
00165Ar 2  85 C1                sta     ARG+1
00165Cr 2  98                   tya
00165Dr 2  4C rr rr             jmp     L39C7
001660r 2               L39F2:
001660r 2  A9 40                lda     #$40
001662r 2  D0 CE                bne     L39C4
001664r 2               L39F6:
001664r 2  0A                   asl     a
001665r 2  0A                   asl     a
001666r 2  0A                   asl     a
001667r 2  0A                   asl     a
001668r 2  0A                   asl     a
001669r 2  0A                   asl     a
00166Ar 2  85 C7                sta     FACEXTENSION
00166Cr 2  28                   plp
00166Dr 2  4C rr rr             jmp     COPY_RESULT_INTO_FAC
001670r 2               L3A02:
001670r 2  A2 85                ldx     #ERR_ZERODIV
001672r 2  4C rr rr             jmp     ERROR
001675r 2               
001675r 2               ; ----------------------------------------------------------------------------
001675r 2               ; COPY RESULT INTO FAC MANTISSA, AND NORMALIZE
001675r 2               ; ----------------------------------------------------------------------------
001675r 2               COPY_RESULT_INTO_FAC:
001675r 2  A5 7D                lda     RESULT
001677r 2  85 B9                sta     FAC+1
001679r 2  A5 7E                lda     RESULT+1
00167Br 2  85 BA                sta     FAC+2
00167Dr 2  A5 7F                lda     RESULT+2
00167Fr 2  85 BB                sta     FAC+3
001681r 2               .ifndef CONFIG_SMALL
001681r 2  A5 80                lda     RESULT+3
001683r 2  85 BC                sta     FAC+4
001685r 2               .endif
001685r 2  4C rr rr             jmp     NORMALIZE_FAC2
001688r 2               
001688r 2               ; ----------------------------------------------------------------------------
001688r 2               ; UNPACK (Y,A) INTO FAC
001688r 2               ; ----------------------------------------------------------------------------
001688r 2               LOAD_FAC_FROM_YA:
001688r 2  85 79                sta     INDEX
00168Ar 2  84 7A                sty     INDEX+1
00168Cr 2  A0 04                ldy     #MANTISSA_BYTES
00168Er 2               .ifndef CONFIG_SMALL
00168Er 2  B1 79                lda     (INDEX),y
001690r 2  85 BC                sta     FAC+4
001692r 2  88                   dey
001693r 2               .endif
001693r 2  B1 79                lda     (INDEX),y
001695r 2  85 BB                sta     FAC+3
001697r 2  88                   dey
001698r 2  B1 79                lda     (INDEX),y
00169Ar 2  85 BA                sta     FAC+2
00169Cr 2  88                   dey
00169Dr 2  B1 79                lda     (INDEX),y
00169Fr 2  85 BD                sta     FACSIGN
0016A1r 2  09 80                ora     #$80
0016A3r 2  85 B9                sta     FAC+1
0016A5r 2  88                   dey
0016A6r 2  B1 79                lda     (INDEX),y
0016A8r 2  85 B8                sta     FAC
0016AAr 2  84 C7                sty     FACEXTENSION
0016ACr 2  60                   rts
0016ADr 2               
0016ADr 2               ; ----------------------------------------------------------------------------
0016ADr 2               ; ROUND FAC, STORE IN TEMP2
0016ADr 2               ; ----------------------------------------------------------------------------
0016ADr 2               STORE_FAC_IN_TEMP2_ROUNDED:
0016ADr 2  A2 B3                ldx     #TEMP2
0016AFr 2  2C                   .byte   $2C
0016B0r 2               
0016B0r 2               ; ----------------------------------------------------------------------------
0016B0r 2               ; ROUND FAC, STORE IN TEMP1
0016B0r 2               ; ----------------------------------------------------------------------------
0016B0r 2               STORE_FAC_IN_TEMP1_ROUNDED:
0016B0r 2  A2 AE                ldx     #TEMP1X
0016B2r 2  A0 00                ldy     #$00
0016B4r 2  F0 04                beq     STORE_FAC_AT_YX_ROUNDED
0016B6r 2               
0016B6r 2               ; ----------------------------------------------------------------------------
0016B6r 2               ; ROUND FAC, AND STORE WHERE FORPNT POINTS
0016B6r 2               ; ----------------------------------------------------------------------------
0016B6r 2               SETFOR:
0016B6r 2  A6 A0                ldx     FORPNT
0016B8r 2  A4 A1                ldy     FORPNT+1
0016BAr 2               
0016BAr 2               ; ----------------------------------------------------------------------------
0016BAr 2               ; ROUND FAC, AND STORE AT (Y,X)
0016BAr 2               ; ----------------------------------------------------------------------------
0016BAr 2               STORE_FAC_AT_YX_ROUNDED:
0016BAr 2  20 rr rr             jsr     ROUND_FAC
0016BDr 2  86 79                stx     INDEX
0016BFr 2  84 7A                sty     INDEX+1
0016C1r 2  A0 04                ldy     #MANTISSA_BYTES
0016C3r 2               .ifndef CONFIG_SMALL
0016C3r 2  A5 BC                lda     FAC+4
0016C5r 2  91 79                sta     (INDEX),y
0016C7r 2  88                   dey
0016C8r 2               .endif
0016C8r 2  A5 BB                lda     FAC+3
0016CAr 2  91 79                sta     (INDEX),y
0016CCr 2  88                   dey
0016CDr 2  A5 BA                lda     FAC+2
0016CFr 2  91 79                sta     (INDEX),y
0016D1r 2  88                   dey
0016D2r 2  A5 BD                lda     FACSIGN
0016D4r 2  09 7F                ora     #$7F
0016D6r 2  25 B9                and     FAC+1
0016D8r 2  91 79                sta     (INDEX),y
0016DAr 2  88                   dey
0016DBr 2  A5 B8                lda     FAC
0016DDr 2  91 79                sta     (INDEX),y
0016DFr 2  84 C7                sty     FACEXTENSION
0016E1r 2  60                   rts
0016E2r 2               
0016E2r 2               ; ----------------------------------------------------------------------------
0016E2r 2               ; COPY ARG INTO FAC
0016E2r 2               ; ----------------------------------------------------------------------------
0016E2r 2               COPY_ARG_TO_FAC:
0016E2r 2  A5 C5                lda     ARGSIGN
0016E4r 2               MFA:
0016E4r 2  85 BD                sta     FACSIGN
0016E6r 2  A2 05                ldx     #BYTES_FP
0016E8r 2               L3A7A:
0016E8r 2  B5 BF                lda     SHIFTSIGNEXT,x
0016EAr 2  95 B7                sta     EXPSGN,x
0016ECr 2  CA                   dex
0016EDr 2  D0 F9                bne     L3A7A
0016EFr 2  86 C7                stx     FACEXTENSION
0016F1r 2  60                   rts
0016F2r 2               
0016F2r 2               ; ----------------------------------------------------------------------------
0016F2r 2               ; ROUND FAC AND COPY TO ARG
0016F2r 2               ; ----------------------------------------------------------------------------
0016F2r 2               COPY_FAC_TO_ARG_ROUNDED:
0016F2r 2  20 rr rr             jsr     ROUND_FAC
0016F5r 2               MAF:
0016F5r 2  A2 06                ldx     #BYTES_FP+1
0016F7r 2               L3A89:
0016F7r 2  B5 B7                lda     EXPSGN,x
0016F9r 2  95 BF                sta     SHIFTSIGNEXT,x
0016FBr 2  CA                   dex
0016FCr 2  D0 F9                bne     L3A89
0016FEr 2  86 C7                stx     FACEXTENSION
001700r 2               RTS14:
001700r 2  60                   rts
001701r 2               
001701r 2               ; ----------------------------------------------------------------------------
001701r 2               ; ROUND FAC USING EXTENSION BYTE
001701r 2               ; ----------------------------------------------------------------------------
001701r 2               ROUND_FAC:
001701r 2  A5 B8                lda     FAC
001703r 2  F0 FB                beq     RTS14
001705r 2  06 C7                asl     FACEXTENSION
001707r 2  90 F7                bcc     RTS14
001709r 2               
001709r 2               ; ----------------------------------------------------------------------------
001709r 2               ; INCREMENT MANTISSA AND RE-NORMALIZE IF CARRY
001709r 2               ; ----------------------------------------------------------------------------
001709r 2               INCREMENT_MANTISSA:
001709r 2  20 rr rr             jsr     INCREMENT_FAC_MANTISSA
00170Cr 2  D0 F2                bne     RTS14
00170Er 2  4C rr rr             jmp     NORMALIZE_FAC6
001711r 2               
001711r 2               ; ----------------------------------------------------------------------------
001711r 2               ; TEST FAC FOR ZERO AND SIGN
001711r 2               ;
001711r 2               ; FAC > 0, RETURN +1
001711r 2               ; FAC = 0, RETURN  0
001711r 2               ; FAC < 0, RETURN -1
001711r 2               ; ----------------------------------------------------------------------------
001711r 2               SIGN:
001711r 2  A5 B8                lda     FAC
001713r 2  F0 09                beq     RTS15
001715r 2               L3AA7:
001715r 2  A5 BD                lda     FACSIGN
001717r 2               SIGN2:
001717r 2  2A                   rol     a
001718r 2  A9 FF                lda     #$FF
00171Ar 2  B0 02                bcs     RTS15
00171Cr 2  A9 01                lda     #$01
00171Er 2               RTS15:
00171Er 2  60                   rts
00171Fr 2               
00171Fr 2               ; ----------------------------------------------------------------------------
00171Fr 2               ; "SGN" FUNCTION
00171Fr 2               ; ----------------------------------------------------------------------------
00171Fr 2               SGN:
00171Fr 2  20 rr rr             jsr     SIGN
001722r 2               
001722r 2               ; ----------------------------------------------------------------------------
001722r 2               ; CONVERT (A) INTO FAC, AS SIGNED VALUE -128 TO +127
001722r 2               ; ----------------------------------------------------------------------------
001722r 2               FLOAT:
001722r 2  85 B9                sta     FAC+1
001724r 2  A9 00                lda     #$00
001726r 2  85 BA                sta     FAC+2
001728r 2  A2 88                ldx     #$88
00172Ar 2               
00172Ar 2               ; ----------------------------------------------------------------------------
00172Ar 2               ; FLOAT UNSIGNED VALUE IN FAC+1,2
00172Ar 2               ; (X) = EXPONENT
00172Ar 2               ; ----------------------------------------------------------------------------
00172Ar 2               FLOAT1:
00172Ar 2  A5 B9                lda     FAC+1
00172Cr 2  49 FF                eor     #$FF
00172Er 2  2A                   rol     a
00172Fr 2               
00172Fr 2               ; ----------------------------------------------------------------------------
00172Fr 2               ; FLOAT UNSIGNED VALUE IN FAC+1,2
00172Fr 2               ; (X) = EXPONENT
00172Fr 2               ; C=0 TO MAKE VALUE NEGATIVE
00172Fr 2               ; C=1 TO MAKE VALUE POSITIVE
00172Fr 2               ; ----------------------------------------------------------------------------
00172Fr 2               FLOAT2:
00172Fr 2  A9 00                lda     #$00
001731r 2               .ifndef CONFIG_SMALL
001731r 2  85 BC                sta     FAC+4
001733r 2               .endif
001733r 2  85 BB                sta     FAC+3
001735r 2               LDB21:
001735r 2  86 B8                stx     FAC
001737r 2  85 C7                sta     FACEXTENSION
001739r 2  85 BD                sta     FACSIGN
00173Br 2  4C rr rr             jmp     NORMALIZE_FAC1
00173Er 2               
00173Er 2               ; ----------------------------------------------------------------------------
00173Er 2               ; "ABS" FUNCTION
00173Er 2               ; ----------------------------------------------------------------------------
00173Er 2               ABS:
00173Er 2  46 BD                lsr     FACSIGN
001740r 2  60                   rts
001741r 2               
001741r 2               ; ----------------------------------------------------------------------------
001741r 2               ; COMPARE FAC WITH PACKED # AT (Y,A)
001741r 2               ; RETURN A=1,0,-1 AS (Y,A) IS <,=,> FAC
001741r 2               ; ----------------------------------------------------------------------------
001741r 2               FCOMP:
001741r 2  85 7B                sta     DEST
001743r 2               
001743r 2               ; ----------------------------------------------------------------------------
001743r 2               ; SPECIAL ENTRY FROM "NEXT" PROCESSOR
001743r 2               ; "DEST" ALREADY SET UP
001743r 2               ; ----------------------------------------------------------------------------
001743r 2               FCOMP2:
001743r 2  84 7C                sty     DEST+1
001745r 2  A0 00                ldy     #$00
001747r 2  B1 7B                lda     (DEST),y
001749r 2  C8                   iny
00174Ar 2  AA                   tax
00174Br 2  F0 C4                beq     SIGN
00174Dr 2  B1 7B                lda     (DEST),y
00174Fr 2  45 BD                eor     FACSIGN
001751r 2  30 C2                bmi     L3AA7
001753r 2  E4 B8                cpx     FAC
001755r 2  D0 21                bne     L3B0A
001757r 2  B1 7B                lda     (DEST),y
001759r 2  09 80                ora     #$80
00175Br 2  C5 B9                cmp     FAC+1
00175Dr 2  D0 19                bne     L3B0A
00175Fr 2  C8                   iny
001760r 2  B1 7B                lda     (DEST),y
001762r 2  C5 BA                cmp     FAC+2
001764r 2  D0 12                bne     L3B0A
001766r 2  C8                   iny
001767r 2               .ifndef CONFIG_SMALL
001767r 2  B1 7B                lda     (DEST),y
001769r 2  C5 BB                cmp     FAC+3
00176Br 2  D0 0B                bne     L3B0A
00176Dr 2  C8                   iny
00176Er 2               .endif
00176Er 2  A9 7F                lda     #$7F
001770r 2  C5 C7                cmp     FACEXTENSION
001772r 2  B1 7B                lda     (DEST),y
001774r 2  E5 BC                sbc     FAC_LAST
001776r 2  F0 28                beq     L3B32
001778r 2               L3B0A:
001778r 2  A5 BD                lda     FACSIGN
00177Ar 2  90 02                bcc     L3B10
00177Cr 2  49 FF                eor     #$FF
00177Er 2               L3B10:
00177Er 2  4C rr rr             jmp     SIGN2
001781r 2               
001781r 2               ; ----------------------------------------------------------------------------
001781r 2               ; QUICK INTEGER FUNCTION
001781r 2               ;
001781r 2               ; CONVERTS FP VALUE IN FAC TO INTEGER VALUE
001781r 2               ; IN FAC+1...FAC+4, BY SHIFTING RIGHT WITH SIGN
001781r 2               ; EXTENSION UNTIL FRACTIONAL BITS ARE OUT.
001781r 2               ;
001781r 2               ; THIS SUBROUTINE ASSUMES THE EXPONENT < 32.
001781r 2               ; ----------------------------------------------------------------------------
001781r 2               QINT:
001781r 2  A5 B8                lda     FAC
001783r 2  F0 4A                beq     QINT3
001785r 2  38                   sec
001786r 2  E9 A0                sbc     #120+8*BYTES_FP
001788r 2  24 BD                bit     FACSIGN
00178Ar 2  10 09                bpl     L3B27
00178Cr 2  AA                   tax
00178Dr 2  A9 FF                lda     #$FF
00178Fr 2  85 BF                sta     SHIFTSIGNEXT
001791r 2  20 rr rr             jsr     COMPLEMENT_FAC_MANTISSA
001794r 2  8A                   txa
001795r 2               L3B27:
001795r 2  A2 B8                ldx     #FAC
001797r 2  C9 F9                cmp     #$F9
001799r 2  10 06                bpl     QINT2
00179Br 2  20 rr rr             jsr     SHIFT_RIGHT
00179Er 2  84 BF                sty     SHIFTSIGNEXT
0017A0r 2               L3B32:
0017A0r 2  60                   rts
0017A1r 2               QINT2:
0017A1r 2  A8                   tay
0017A2r 2  A5 BD                lda     FACSIGN
0017A4r 2  29 80                and     #$80
0017A6r 2  46 B9                lsr     FAC+1
0017A8r 2  05 B9                ora     FAC+1
0017AAr 2  85 B9                sta     FAC+1
0017ACr 2  20 rr rr             jsr     SHIFT_RIGHT4
0017AFr 2  84 BF                sty     SHIFTSIGNEXT
0017B1r 2  60                   rts
0017B2r 2               
0017B2r 2               ; ----------------------------------------------------------------------------
0017B2r 2               ; "INT" FUNCTION
0017B2r 2               ;
0017B2r 2               ; USES QINT TO CONVERT (FAC) TO INTEGER FORM,
0017B2r 2               ; AND THEN REFLOATS THE INTEGER.
0017B2r 2               ; ----------------------------------------------------------------------------
0017B2r 2               INT:
0017B2r 2  A5 B8                lda     FAC
0017B4r 2  C9 A0                cmp     #120+8*BYTES_FP
0017B6r 2  B0 20                bcs     RTS17
0017B8r 2  20 rr rr             jsr     QINT
0017BBr 2  84 C7                sty     FACEXTENSION
0017BDr 2  A5 BD                lda     FACSIGN
0017BFr 2  84 BD                sty     FACSIGN
0017C1r 2  49 80                eor     #$80
0017C3r 2  2A                   rol     a
0017C4r 2  A9 A0                lda     #120+8*BYTES_FP
0017C6r 2  85 B8                sta     FAC
0017C8r 2  A5 BC                lda     FAC_LAST
0017CAr 2  85 62                sta     CHARAC
0017CCr 2  4C rr rr             jmp     NORMALIZE_FAC1
0017CFr 2               QINT3:
0017CFr 2  85 B9                sta     FAC+1
0017D1r 2  85 BA                sta     FAC+2
0017D3r 2  85 BB                sta     FAC+3
0017D5r 2               .ifndef CONFIG_SMALL
0017D5r 2  85 BC                sta     FAC+4
0017D7r 2               .endif
0017D7r 2  A8                   tay
0017D8r 2               RTS17:
0017D8r 2  60                   rts
0017D9r 2               
0017D9r 2               ; ----------------------------------------------------------------------------
0017D9r 2               ; CONVERT STRING TO FP VALUE IN FAC
0017D9r 2               ;
0017D9r 2               ; STRING POINTED TO BY TXTPTR
0017D9r 2               ; FIRST CHAR ALREADY SCANNED BY CHRGET
0017D9r 2               ; (A) = FIRST CHAR, C=0 IF DIGIT.
0017D9r 2               ; ----------------------------------------------------------------------------
0017D9r 2               FIN:
0017D9r 2  A0 00                ldy     #$00
0017DBr 2  A2 0A                ldx     #SERLEN-TMPEXP
0017DDr 2               L3B6F:
0017DDr 2  94 B4                sty     TMPEXP,x
0017DFr 2  CA                   dex
0017E0r 2  10 FB                bpl     L3B6F
0017E2r 2  90 0F                bcc     FIN2
0017E4r 2               .ifdef SYM1
0017E4r 2                       cmp     #$26
0017E4r 2                       bne     LDABB
0017E4r 2                       jmp     LCDFE
0017E4r 2               LDABB:
0017E4r 2               .endif
0017E4r 2  C9 2D                cmp     #$2D
0017E6r 2  D0 04                bne     L3B7E
0017E8r 2  86 BE                stx     SERLEN
0017EAr 2  F0 04                beq     FIN1
0017ECr 2               L3B7E:
0017ECr 2  C9 2B                cmp     #$2B
0017EEr 2  D0 05                bne     FIN3
0017F0r 2               FIN1:
0017F0r 2  20 CA 00             jsr     CHRGET
0017F3r 2               FIN2:
0017F3r 2  90 5B                bcc     FIN9
0017F5r 2               FIN3:
0017F5r 2  C9 2E                cmp     #$2E
0017F7r 2  F0 2E                beq     FIN10
0017F9r 2  C9 45                cmp     #$45
0017FBr 2  D0 30                bne     FIN7
0017FDr 2  20 CA 00             jsr     CHRGET
001800r 2  90 17                bcc     FIN5
001802r 2  C9 A6                cmp     #TOKEN_MINUS
001804r 2  F0 0E                beq     L3BA6
001806r 2  C9 2D                cmp     #$2D
001808r 2  F0 0A                beq     L3BA6
00180Ar 2  C9 A5                cmp     #TOKEN_PLUS
00180Cr 2  F0 08                beq     FIN4
00180Er 2  C9 2B                cmp     #$2B
001810r 2  F0 04                beq     FIN4
001812r 2  D0 07                bne     FIN6
001814r 2               L3BA6:
001814r 2               .ifndef CONFIG_ROR_WORKAROUND
001814r 2  66 B7                ror     EXPSGN
001816r 2               .else
001816r 2                       lda     #$00
001816r 2                       bcc     L3BAC
001816r 2                       lda     #$80
001816r 2               L3BAC:
001816r 2                       lsr     EXPSGN
001816r 2                       ora     EXPSGN
001816r 2                       sta     EXPSGN
001816r 2               .endif
001816r 2               FIN4:
001816r 2  20 CA 00             jsr     CHRGET
001819r 2               FIN5:
001819r 2  90 5C                bcc     GETEXP
00181Br 2               FIN6:
00181Br 2  24 B7                bit     EXPSGN
00181Dr 2  10 0E                bpl     FIN7
00181Fr 2  A9 00                lda     #$00
001821r 2  38                   sec
001822r 2  E5 B5                sbc     EXPON
001824r 2  4C rr rr             jmp     FIN8
001827r 2               
001827r 2               ; ----------------------------------------------------------------------------
001827r 2               ; FOUND A DECIMAL POINT
001827r 2               ; ----------------------------------------------------------------------------
001827r 2               FIN10:
001827r 2               .ifndef CONFIG_ROR_WORKAROUND
001827r 2  66 B6                ror     LOWTR
001829r 2               .else
001829r 2                       lda     #$00
001829r 2                       bcc     L3BC9
001829r 2                       lda     #$80
001829r 2               L3BC9:
001829r 2                       lsr     LOWTR
001829r 2                       ora     LOWTR
001829r 2                       sta     LOWTR
001829r 2               .endif
001829r 2  24 B6                bit     LOWTR
00182Br 2  50 C3                bvc     FIN1
00182Dr 2               
00182Dr 2               ; ----------------------------------------------------------------------------
00182Dr 2               ; NUMBER TERMINATED, ADJUST EXPONENT NOW
00182Dr 2               ; ----------------------------------------------------------------------------
00182Dr 2               FIN7:
00182Dr 2  A5 B5                lda     EXPON
00182Fr 2               FIN8:
00182Fr 2  38                   sec
001830r 2  E5 B4                sbc     INDX
001832r 2  85 B5                sta     EXPON
001834r 2  F0 12                beq     L3BEE
001836r 2  10 09                bpl     L3BE7
001838r 2               L3BDE:
001838r 2  20 rr rr             jsr     DIV10
00183Br 2  E6 B5                inc     EXPON
00183Dr 2  D0 F9                bne     L3BDE
00183Fr 2  F0 07                beq     L3BEE
001841r 2               L3BE7:
001841r 2  20 rr rr             jsr     MUL10
001844r 2  C6 B5                dec     EXPON
001846r 2  D0 F9                bne     L3BE7
001848r 2               L3BEE:
001848r 2  A5 BE                lda     SERLEN
00184Ar 2  30 01                bmi     L3BF3
00184Cr 2  60                   rts
00184Dr 2               L3BF3:
00184Dr 2  4C rr rr             jmp     NEGOP
001850r 2               
001850r 2               ; ----------------------------------------------------------------------------
001850r 2               ; ACCUMULATE A DIGIT INTO FAC
001850r 2               ; ----------------------------------------------------------------------------
001850r 2               FIN9:
001850r 2  48                   pha
001851r 2  24 B6                bit     LOWTR
001853r 2  10 02                bpl     L3BFD
001855r 2  E6 B4                inc     INDX
001857r 2               L3BFD:
001857r 2  20 rr rr             jsr     MUL10
00185Ar 2  68                   pla
00185Br 2  38                   sec
00185Cr 2  E9 30                sbc     #$30
00185Er 2  20 rr rr             jsr     ADDACC
001861r 2  4C rr rr             jmp     FIN1
001864r 2               
001864r 2               ; ----------------------------------------------------------------------------
001864r 2               ; ADD (A) TO FAC
001864r 2               ; ----------------------------------------------------------------------------
001864r 2               ADDACC:
001864r 2  48                   pha
001865r 2  20 rr rr             jsr     COPY_FAC_TO_ARG_ROUNDED
001868r 2  68                   pla
001869r 2  20 rr rr             jsr     FLOAT
00186Cr 2  A5 C5                lda     ARGSIGN
00186Er 2  45 BD                eor     FACSIGN
001870r 2  85 C6                sta     SGNCPR
001872r 2  A6 B8                ldx     FAC
001874r 2  4C rr rr             jmp     FADDT
001877r 2               
001877r 2               ; ----------------------------------------------------------------------------
001877r 2               ; ACCUMULATE DIGIT OF EXPONENT
001877r 2               ; ----------------------------------------------------------------------------
001877r 2               GETEXP:
001877r 2  A5 B5                lda     EXPON
001879r 2  C9 0A                cmp     #MAX_EXPON
00187Br 2  90 09                bcc     L3C2C
00187Dr 2               .ifdef CONFIG_10A
00187Dr 2  A9 64                lda     #$64
00187Fr 2               .endif
00187Fr 2  24 B7                bit     EXPSGN
001881r 2               .ifdef CONFIG_10A
001881r 2  30 11                bmi     L3C3A
001883r 2               .else
001883r 2                       bmi     LDC70
001883r 2               .endif
001883r 2  4C rr rr             jmp     OVERFLOW
001886r 2               LDC70:
001886r 2               .ifndef CONFIG_10A
001886r 2                       lda     #$0B
001886r 2               .endif
001886r 2               L3C2C:
001886r 2  0A                   asl     a
001887r 2  0A                   asl     a
001888r 2  18                   clc
001889r 2  65 B5                adc     EXPON
00188Br 2  0A                   asl     a
00188Cr 2  18                   clc
00188Dr 2  A0 00                ldy     #$00
00188Fr 2  71 D1                adc     (TXTPTR),y
001891r 2  38                   sec
001892r 2  E9 30                sbc     #$30
001894r 2               L3C3A:
001894r 2  85 B5                sta     EXPON
001896r 2  4C rr rr             jmp     FIN4
001899r 2               
001899r 2               ; ----------------------------------------------------------------------------
001899r 2               .ifdef CONFIG_SMALL
001899r 2               ; these values are /1000 of what the labels say
001899r 2               CON_99999999_9:
001899r 2                       .byte   $91,$43,$4F,$F8
001899r 2               CON_999999999:
001899r 2               		.byte   $94,$74,$23,$F7
001899r 2               CON_BILLION:
001899r 2                       .byte   $94,$74,$24,$00
001899r 2               .else
001899r 2               CON_99999999_9:
001899r 2  9B 3E BC 1F          .byte   $9B,$3E,$BC,$1F,$FD
00189Dr 2  FD           
00189Er 2               CON_999999999:
00189Er 2               .ifndef CONFIG_10A
00189Er 2                       .byte   $9E,$6E,$6B,$27,$FE
00189Er 2               .else
00189Er 2  9E 6E 6B 27          .byte   $9E,$6E,$6B,$27,$FD
0018A2r 2  FD           
0018A3r 2               .endif
0018A3r 2               CON_BILLION:
0018A3r 2  9E 6E 6B 28          .byte   $9E,$6E,$6B,$28,$00
0018A7r 2  00           
0018A8r 2               .endif
0018A8r 2               
0018A8r 2               ; ----------------------------------------------------------------------------
0018A8r 2               ; PRINT "IN <LINE #>"
0018A8r 2               ; ----------------------------------------------------------------------------
0018A8r 2               INPRT:
0018A8r 2               .ifdef KBD
0018A8r 2                       jsr     LFE0B
0018A8r 2                       .byte	" in"
0018A8r 2                       .byte	0
0018A8r 2               .else
0018A8r 2  A9 rr                lda     #<QT_IN
0018AAr 2  A0 rr                ldy     #>QT_IN
0018ACr 2  20 rr rr             jsr     GOSTROUT2
0018AFr 2               .endif
0018AFr 2  A5 91                lda     CURLIN+1
0018B1r 2  A6 90                ldx     CURLIN
0018B3r 2               
0018B3r 2               ; ----------------------------------------------------------------------------
0018B3r 2               ; PRINT A,X AS DECIMAL INTEGER
0018B3r 2               ; ----------------------------------------------------------------------------
0018B3r 2               LINPRT:
0018B3r 2  85 B9                sta     FAC+1
0018B5r 2  86 BA                stx     FAC+2
0018B7r 2  A2 90                ldx     #$90
0018B9r 2  38                   sec
0018BAr 2  20 rr rr             jsr     FLOAT2
0018BDr 2  20 rr rr             jsr     FOUT
0018C0r 2               GOSTROUT2:
0018C0r 2  4C rr rr             jmp     STROUT
0018C3r 2               
0018C3r 2               ; ----------------------------------------------------------------------------
0018C3r 2               ; CONVERT (FAC) TO STRING STARTING AT STACK
0018C3r 2               ; RETURN WITH (Y,A) POINTING AT STRING
0018C3r 2               ; ----------------------------------------------------------------------------
0018C3r 2               FOUT:
0018C3r 2  A0 01                ldy     #$01
0018C5r 2               
0018C5r 2               ; ----------------------------------------------------------------------------
0018C5r 2               ; "STR$" FUNCTION ENTERS HERE, WITH (Y)=0
0018C5r 2               ; SO THAT RESULT STRING STARTS AT STACK-1
0018C5r 2               ; (THIS IS USED AS A FLAG)
0018C5r 2               ; ----------------------------------------------------------------------------
0018C5r 2               FOUT1:
0018C5r 2  A9 20                lda     #$20
0018C7r 2  24 BD                bit     FACSIGN
0018C9r 2  10 02                bpl     L3C73
0018CBr 2  A9 2D                lda     #$2D
0018CDr 2               L3C73:
0018CDr 2  99 FF 00             sta     STACK2-1,y
0018D0r 2  85 BD                sta     FACSIGN
0018D2r 2  84 C8                sty     STRNG2
0018D4r 2  C8                   iny
0018D5r 2  A9 30                lda     #$30
0018D7r 2  A6 B8                ldx     FAC
0018D9r 2  D0 03                bne     L3C84
0018DBr 2  4C rr rr             jmp     FOUT4
0018DEr 2               L3C84:
0018DEr 2  A9 00                lda     #$00
0018E0r 2  E0 80                cpx     #$80
0018E2r 2  F0 02                beq     L3C8C
0018E4r 2  B0 09                bcs     L3C95
0018E6r 2               L3C8C:
0018E6r 2  A9 rr                lda     #<CON_BILLION
0018E8r 2  A0 rr                ldy     #>CON_BILLION
0018EAr 2  20 rr rr             jsr     FMULT
0018EDr 2               .ifdef CONFIG_SMALL
0018EDr 2                       lda     #-6 ; exponent adjustment
0018EDr 2               .else
0018EDr 2  A9 F7                lda     #-9
0018EFr 2               .endif
0018EFr 2               L3C95:
0018EFr 2  85 B4                sta     INDX
0018F1r 2               ; ----------------------------------------------------------------------------
0018F1r 2               ; ADJUST UNTIL 1E8 <= (FAC) <1E9
0018F1r 2               ; ----------------------------------------------------------------------------
0018F1r 2               L3C97:
0018F1r 2  A9 rr                lda     #<CON_999999999
0018F3r 2  A0 rr                ldy     #>CON_999999999
0018F5r 2  20 rr rr             jsr     FCOMP
0018F8r 2  F0 1E                beq     L3CBE
0018FAr 2  10 12                bpl     L3CB4
0018FCr 2               L3CA2:
0018FCr 2  A9 rr                lda     #<CON_99999999_9
0018FEr 2  A0 rr                ldy     #>CON_99999999_9
001900r 2  20 rr rr             jsr     FCOMP
001903r 2  F0 02                beq     L3CAD
001905r 2  10 0E                bpl     L3CBB
001907r 2               L3CAD:
001907r 2  20 rr rr             jsr     MUL10
00190Ar 2  C6 B4                dec     INDX
00190Cr 2  D0 EE                bne     L3CA2
00190Er 2               L3CB4:
00190Er 2  20 rr rr             jsr     DIV10
001911r 2  E6 B4                inc     INDX
001913r 2  D0 DC                bne     L3C97
001915r 2               L3CBB:
001915r 2  20 rr rr             jsr     FADDH
001918r 2               L3CBE:
001918r 2  20 rr rr             jsr     QINT
00191Br 2               ; ----------------------------------------------------------------------------
00191Br 2               ; FAC+1...FAC+4 IS NOW IN INTEGER FORM
00191Br 2               ; WITH POWER OF TEN ADJUSTMENT IN TMPEXP
00191Br 2               ;
00191Br 2               ; IF -10 < TMPEXP > 1, PRINT IN DECIMAL FORM
00191Br 2               ; OTHERWISE, PRINT IN EXPONENTIAL FORM
00191Br 2               ; ----------------------------------------------------------------------------
00191Br 2  A2 01                ldx     #$01
00191Dr 2  A5 B4                lda     INDX
00191Fr 2  18                   clc
001920r 2  69 0A                adc     #3*BYTES_FP-5
001922r 2  30 09                bmi     L3CD3
001924r 2  C9 0B                cmp     #3*BYTES_FP-4
001926r 2  B0 06                bcs     L3CD4
001928r 2  69 FF                adc     #$FF
00192Ar 2  AA                   tax
00192Br 2  A9 02                lda     #$02
00192Dr 2               L3CD3:
00192Dr 2  38                   sec
00192Er 2               L3CD4:
00192Er 2  E9 02                sbc     #$02
001930r 2  85 B5                sta     EXPON
001932r 2  86 B4                stx     INDX
001934r 2  8A                   txa
001935r 2  F0 02                beq     L3CDF
001937r 2  10 13                bpl     L3CF2
001939r 2               L3CDF:
001939r 2  A4 C8                ldy     STRNG2
00193Br 2  A9 2E                lda     #$2E
00193Dr 2  C8                   iny
00193Er 2  99 FF 00             sta     STACK2-1,y
001941r 2  8A                   txa
001942r 2  F0 06                beq     L3CF0
001944r 2  A9 30                lda     #$30
001946r 2  C8                   iny
001947r 2  99 FF 00             sta     STACK2-1,y
00194Ar 2               L3CF0:
00194Ar 2  84 C8                sty     STRNG2
00194Cr 2               ; ----------------------------------------------------------------------------
00194Cr 2               ; NOW DIVIDE BY POWERS OF TEN TO GET SUCCESSIVE DIGITS
00194Cr 2               ; ----------------------------------------------------------------------------
00194Cr 2               L3CF2:
00194Cr 2  A0 00                ldy     #$00
00194Er 2               LDD3A:
00194Er 2  A2 80                ldx     #$80
001950r 2               L3CF6:
001950r 2  A5 BC                lda     FAC_LAST
001952r 2  18                   clc
001953r 2               .ifndef CONFIG_SMALL
001953r 2  79 rr rr             adc     DECTBL+3,y
001956r 2  85 BC                sta     FAC+4
001958r 2  A5 BB                lda     FAC+3
00195Ar 2               .endif
00195Ar 2  79 rr rr             adc     DECTBL+2,y
00195Dr 2  85 BB                sta     FAC+3
00195Fr 2  A5 BA                lda     FAC+2
001961r 2  79 rr rr             adc     DECTBL+1,y
001964r 2  85 BA                sta     FAC+2
001966r 2  A5 B9                lda     FAC+1
001968r 2  79 rr rr             adc     DECTBL,y
00196Br 2  85 B9                sta     FAC+1
00196Dr 2  E8                   inx
00196Er 2  B0 04                bcs     L3D1A
001970r 2  10 DE                bpl     L3CF6
001972r 2  30 02                bmi     L3D1C
001974r 2               L3D1A:
001974r 2  30 DA                bmi     L3CF6
001976r 2               L3D1C:
001976r 2  8A                   txa
001977r 2  90 04                bcc     L3D23
001979r 2  49 FF                eor     #$FF
00197Br 2  69 0A                adc     #$0A
00197Dr 2               L3D23:
00197Dr 2  69 2F                adc     #$2F
00197Fr 2  C8                   iny
001980r 2  C8                   iny
001981r 2  C8                   iny
001982r 2               .ifndef CONFIG_SMALL
001982r 2  C8                   iny
001983r 2               .endif
001983r 2  84 9E                sty     VARPNT
001985r 2  A4 C8                ldy     STRNG2
001987r 2  C8                   iny
001988r 2  AA                   tax
001989r 2  29 7F                and     #$7F
00198Br 2  99 FF 00             sta     STACK2-1,y
00198Er 2  C6 B4                dec     INDX
001990r 2  D0 06                bne     L3D3E
001992r 2  A9 2E                lda     #$2E
001994r 2  C8                   iny
001995r 2  99 FF 00             sta     STACK2-1,y
001998r 2               L3D3E:
001998r 2  84 C8                sty     STRNG2
00199Ar 2  A4 9E                ldy     VARPNT
00199Cr 2  8A                   txa
00199Dr 2  49 FF                eor     #$FF
00199Fr 2  29 80                and     #$80
0019A1r 2  AA                   tax
0019A2r 2  C0 24                cpy     #DECTBL_END-DECTBL
0019A4r 2               .ifdef CONFIG_CBM_ALL
0019A4r 2                       beq     LDD96
0019A4r 2                       cpy     #$3C ; XXX
0019A4r 2               .endif
0019A4r 2  D0 AA                bne     L3CF6
0019A6r 2               ; ----------------------------------------------------------------------------
0019A6r 2               ; NINE DIGITS HAVE BEEN STORED IN STRING.  NOW LOOK
0019A6r 2               ; BACK AND LOP OFF TRAILING ZEROES AND A TRAILING
0019A6r 2               ; DECIMAL POINT.
0019A6r 2               ; ----------------------------------------------------------------------------
0019A6r 2               LDD96:
0019A6r 2  A4 C8                ldy     STRNG2
0019A8r 2               L3D4E:
0019A8r 2  B9 FF 00             lda     STACK2-1,y
0019ABr 2  88                   dey
0019ACr 2  C9 30                cmp     #$30
0019AEr 2  F0 F8                beq     L3D4E
0019B0r 2  C9 2E                cmp     #$2E
0019B2r 2  F0 01                beq     L3D5B
0019B4r 2  C8                   iny
0019B5r 2               L3D5B:
0019B5r 2  A9 2B                lda     #$2B
0019B7r 2  A6 B5                ldx     EXPON
0019B9r 2  F0 2E                beq     L3D8F
0019BBr 2  10 08                bpl     L3D6B
0019BDr 2  A9 00                lda     #$00
0019BFr 2  38                   sec
0019C0r 2  E5 B5                sbc     EXPON
0019C2r 2  AA                   tax
0019C3r 2  A9 2D                lda     #$2D
0019C5r 2               L3D6B:
0019C5r 2  99 01 01             sta     STACK2+1,y
0019C8r 2  A9 45                lda     #$45
0019CAr 2  99 00 01             sta     STACK2,y
0019CDr 2  8A                   txa
0019CEr 2  A2 2F                ldx     #$2F
0019D0r 2  38                   sec
0019D1r 2               L3D77:
0019D1r 2  E8                   inx
0019D2r 2  E9 0A                sbc     #$0A
0019D4r 2  B0 FB                bcs     L3D77
0019D6r 2  69 3A                adc     #$3A
0019D8r 2  99 03 01             sta     STACK2+3,y
0019DBr 2  8A                   txa
0019DCr 2  99 02 01             sta     STACK2+2,y
0019DFr 2  A9 00                lda     #$00
0019E1r 2  99 04 01             sta     STACK2+4,y
0019E4r 2  F0 08                beq     L3D94
0019E6r 2               FOUT4:
0019E6r 2  99 FF 00             sta     STACK2-1,y
0019E9r 2               L3D8F:
0019E9r 2  A9 00                lda     #$00
0019EBr 2  99 00 01             sta     STACK2,y
0019EEr 2               L3D94:
0019EEr 2  A9 00                lda     #<STACK2
0019F0r 2  A0 01                ldy     #>STACK2
0019F2r 2  60                   rts
0019F3r 2               
0019F3r 2               ; ----------------------------------------------------------------------------
0019F3r 2               CON_HALF:
0019F3r 2               .ifdef CONFIG_SMALL
0019F3r 2                       .byte   $80,$00,$00,$00
0019F3r 2               .else
0019F3r 2  80 00 00 00          .byte   $80,$00,$00,$00,$00
0019F7r 2  00           
0019F8r 2               .endif
0019F8r 2               
0019F8r 2               ; ----------------------------------------------------------------------------
0019F8r 2               ; POWERS OF 10 FROM 1E8 DOWN TO 1,
0019F8r 2               ; AS 32-BIT INTEGERS, WITH ALTERNATING SIGNS
0019F8r 2               ; ----------------------------------------------------------------------------
0019F8r 2               DECTBL:
0019F8r 2               .ifdef CONFIG_SMALL
0019F8r 2                       .byte   $FE,$79,$60 ; -100000
0019F8r 2               		.byte	$00,$27,$10 ; 10000
0019F8r 2               		.byte	$FF,$FC,$18 ; -1000
0019F8r 2               		.byte	$00,$00,$64 ; 100
0019F8r 2               		.byte	$FF,$FF,$F6 ; -10
0019F8r 2               		.byte	$00,$00,$01 ; 1
0019F8r 2               .else
0019F8r 2  FA 0A 1F 00  		.byte	$FA,$0A,$1F,$00	; -100000000
0019FCr 2  00 98 96 80  		.byte	$00,$98,$96,$80	; 10000000
001A00r 2  FF F0 BD C0  		.byte	$FF,$F0,$BD,$C0	; -1000000
001A04r 2  00 01 86 A0  		.byte	$00,$01,$86,$A0	; 100000
001A08r 2  FF FF D8 F0  		.byte	$FF,$FF,$D8,$F0	; -10000
001A0Cr 2  00 00 03 E8  		.byte   $00,$00,$03,$E8	; 1000
001A10r 2  FF FF FF 9C  		.byte	$FF,$FF,$FF,$9C	; -100
001A14r 2  00 00 00 0A  		.byte   $00,$00,$00,$0A	; 10
001A18r 2  FF FF FF FF  		.byte	$FF,$FF,$FF,$FF	; -1
001A1Cr 2               .endif
001A1Cr 2               DECTBL_END:
001A1Cr 2               .ifdef CONFIG_CBM_ALL
001A1Cr 2               		.byte	$FF,$DF,$0A,$80 ; TI$
001A1Cr 2               		.byte	$00,$03,$4B,$C0
001A1Cr 2               		.byte	$FF,$FF,$73,$60
001A1Cr 2               		.byte	$00,$00,$0E,$10
001A1Cr 2               		.byte	$FF,$FF,$FD,$A8
001A1Cr 2               		.byte	$00,$00,$00,$3C
001A1Cr 2               .endif
001A1Cr 2               .ifdef CONFIG_2
001A1Cr 2               C_ZERO = CON_HALF + 2
001A1Cr 2               .endif
001A1Cr 2               
001A1Cr 2               ; ----------------------------------------------------------------------------
001A1Cr 2               ; "SQR" FUNCTION
001A1Cr 2               ; ----------------------------------------------------------------------------
001A1Cr 2               SQR:
001A1Cr 2  20 rr rr             jsr     COPY_FAC_TO_ARG_ROUNDED
001A1Fr 2  A9 rr                lda     #<CON_HALF
001A21r 2  A0 rr                ldy     #>CON_HALF
001A23r 2  20 rr rr             jsr     LOAD_FAC_FROM_YA
001A26r 2               
001A26r 2               ; ----------------------------------------------------------------------------
001A26r 2               ; EXPONENTIATION OPERATION
001A26r 2               ;
001A26r 2               ; ARG ^ FAC  =  EXP( LOG(ARG) * FAC )
001A26r 2               ; ----------------------------------------------------------------------------
001A26r 2               FPWRT:
001A26r 2  F0 70                beq     EXP
001A28r 2  A5 C0                lda     ARG
001A2Ar 2  D0 03                bne     L3DD5
001A2Cr 2  4C rr rr             jmp     STA_IN_FAC_SIGN_AND_EXP
001A2Fr 2               L3DD5:
001A2Fr 2  A2 A5                ldx     #TEMP3
001A31r 2  A0 00                ldy     #$00
001A33r 2  20 rr rr             jsr     STORE_FAC_AT_YX_ROUNDED
001A36r 2  A5 C5                lda     ARGSIGN
001A38r 2  10 0F                bpl     L3DEF
001A3Ar 2  20 rr rr             jsr     INT
001A3Dr 2  A9 A5                lda     #TEMP3
001A3Fr 2  A0 00                ldy     #$00
001A41r 2  20 rr rr             jsr     FCOMP
001A44r 2  D0 03                bne     L3DEF
001A46r 2  98                   tya
001A47r 2  A4 62                ldy     CHARAC
001A49r 2               L3DEF:
001A49r 2  20 rr rr             jsr     MFA
001A4Cr 2  98                   tya
001A4Dr 2  48                   pha
001A4Er 2  20 rr rr             jsr     LOG
001A51r 2  A9 A5                lda     #TEMP3
001A53r 2  A0 00                ldy     #$00
001A55r 2  20 rr rr             jsr     FMULT
001A58r 2  20 rr rr             jsr     EXP
001A5Br 2  68                   pla
001A5Cr 2  4A                   lsr     a
001A5Dr 2  90 0A                bcc     L3E0F
001A5Fr 2               
001A5Fr 2               ; ----------------------------------------------------------------------------
001A5Fr 2               ; NEGATE VALUE IN FAC
001A5Fr 2               ; ----------------------------------------------------------------------------
001A5Fr 2               NEGOP:
001A5Fr 2  A5 B8                lda     FAC
001A61r 2  F0 06                beq     L3E0F
001A63r 2  A5 BD                lda     FACSIGN
001A65r 2  49 FF                eor     #$FF
001A67r 2  85 BD                sta     FACSIGN
001A69r 2               L3E0F:
001A69r 2  60                   rts
001A6Ar 2               
001A6Ar 2               ; ----------------------------------------------------------------------------
001A6Ar 2               .ifdef CONFIG_SMALL
001A6Ar 2               CON_LOG_E:
001A6Ar 2                       .byte   $81,$38,$AA,$3B
001A6Ar 2               POLY_EXP:
001A6Ar 2               		.byte	$06
001A6Ar 2               		.byte	$74,$63,$90,$8C
001A6Ar 2               		.byte	$77,$23,$0C,$AB
001A6Ar 2               		.byte	$7A,$1E,$94,$00
001A6Ar 2               		.byte	$7C,$63,$42,$80
001A6Ar 2               		.byte	$7E,$75,$FE,$D0
001A6Ar 2               		.byte	$80,$31,$72,$15
001A6Ar 2               		.byte	$81,$00,$00,$00
001A6Ar 2               .else
001A6Ar 2               CON_LOG_E:
001A6Ar 2  81 38 AA 3B          .byte   $81,$38,$AA,$3B,$29
001A6Er 2  29           
001A6Fr 2               POLY_EXP:
001A6Fr 2  07                   .byte   $07
001A70r 2  71 34 58 3E  		.byte	$71,$34,$58,$3E,$56
001A74r 2  56           
001A75r 2  74 16 7E B3  		.byte	$74,$16,$7E,$B3,$1B
001A79r 2  1B           
001A7Ar 2  77 2F EE E3  		.byte	$77,$2F,$EE,$E3,$85
001A7Er 2  85           
001A7Fr 2  7A 1D 84 1C          .byte   $7A,$1D,$84,$1C,$2A
001A83r 2  2A           
001A84r 2  7C 63 59 58  		.byte	$7C,$63,$59,$58,$0A
001A88r 2  0A           
001A89r 2  7E 75 FD E7  		.byte	$7E,$75,$FD,$E7,$C6
001A8Dr 2  C6           
001A8Er 2  80 31 72 18  		.byte	$80,$31,$72,$18,$10
001A92r 2  10           
001A93r 2  81 00 00 00  		.byte	$81,$00,$00,$00,$00
001A97r 2  00           
001A98r 2               .endif
001A98r 2               
001A98r 2               ; ----------------------------------------------------------------------------
001A98r 2               ; "EXP" FUNCTION
001A98r 2               ;
001A98r 2               ; FAC = E ^ FAC
001A98r 2               ; ----------------------------------------------------------------------------
001A98r 2               EXP:
001A98r 2  A9 rr                lda     #<CON_LOG_E
001A9Ar 2  A0 rr                ldy     #>CON_LOG_E
001A9Cr 2  20 rr rr             jsr     FMULT
001A9Fr 2  A5 C7                lda     FACEXTENSION
001AA1r 2  69 50                adc     #$50
001AA3r 2  90 03                bcc     L3E4E
001AA5r 2  20 rr rr             jsr     INCREMENT_MANTISSA
001AA8r 2               L3E4E:
001AA8r 2  85 AD                sta     ARGEXTENSION
001AAAr 2  20 rr rr             jsr     MAF
001AADr 2  A5 B8                lda     FAC
001AAFr 2  C9 88                cmp     #$88
001AB1r 2  90 03                bcc     L3E5C
001AB3r 2               L3E59:
001AB3r 2  20 rr rr             jsr     OUTOFRNG
001AB6r 2               L3E5C:
001AB6r 2  20 rr rr             jsr     INT
001AB9r 2  A5 62                lda     CHARAC
001ABBr 2  18                   clc
001ABCr 2  69 81                adc     #$81
001ABEr 2  F0 F3                beq     L3E59
001AC0r 2  38                   sec
001AC1r 2  E9 01                sbc     #$01
001AC3r 2  48                   pha
001AC4r 2  A2 05                ldx     #BYTES_FP
001AC6r 2               L3E6C:
001AC6r 2  B5 C0                lda     ARG,x
001AC8r 2  B4 B8                ldy     FAC,x
001ACAr 2  95 B8                sta     FAC,x
001ACCr 2  94 C0                sty     ARG,x
001ACEr 2  CA                   dex
001ACFr 2  10 F5                bpl     L3E6C
001AD1r 2  A5 AD                lda     ARGEXTENSION
001AD3r 2  85 C7                sta     FACEXTENSION
001AD5r 2  20 rr rr             jsr     FSUBT
001AD8r 2  20 rr rr             jsr     NEGOP
001ADBr 2  A9 rr                lda     #<POLY_EXP
001ADDr 2  A0 rr                ldy     #>POLY_EXP
001ADFr 2  20 rr rr             jsr     POLYNOMIAL
001AE2r 2  A9 00                lda     #$00
001AE4r 2  85 C6                sta     SGNCPR
001AE6r 2  68                   pla
001AE7r 2  20 rr rr             jsr     ADD_EXPONENTS1
001AEAr 2  60                   rts
001AEBr 2               
001AEBr 2               ; ----------------------------------------------------------------------------
001AEBr 2               ; ODD POLYNOMIAL SUBROUTINE
001AEBr 2               ;
001AEBr 2               ; F(X) = X * P(X^2)
001AEBr 2               ;
001AEBr 2               ; WHERE:  X IS VALUE IN FAC
001AEBr 2               ;	Y,A POINTS AT COEFFICIENT TABLE
001AEBr 2               ;	FIRST BYTE OF COEFF. TABLE IS N
001AEBr 2               ;	COEFFICIENTS FOLLOW, HIGHEST POWER FIRST
001AEBr 2               ;
001AEBr 2               ; P(X^2) COMPUTED USING NORMAL POLYNOMIAL SUBROUTINE
001AEBr 2               ; ----------------------------------------------------------------------------
001AEBr 2               POLYNOMIAL_ODD:
001AEBr 2  85 C8                sta     STRNG2
001AEDr 2  84 C9                sty     STRNG2+1
001AEFr 2  20 rr rr             jsr     STORE_FAC_IN_TEMP1_ROUNDED
001AF2r 2  A9 AE                lda     #TEMP1X
001AF4r 2  20 rr rr             jsr     FMULT
001AF7r 2  20 rr rr             jsr     SERMAIN
001AFAr 2  A9 AE                lda     #TEMP1X
001AFCr 2  A0 00                ldy     #$00
001AFEr 2  4C rr rr             jmp     FMULT
001B01r 2               
001B01r 2               ; ----------------------------------------------------------------------------
001B01r 2               ; NORMAL POLYNOMIAL SUBROUTINE
001B01r 2               ;
001B01r 2               ; P(X) = C(0)*X^N + C(1)*X^(N-1) + ... + C(N)
001B01r 2               ;
001B01r 2               ; WHERE:  X IS VALUE IN FAC
001B01r 2               ;	Y,A POINTS AT COEFFICIENT TABLE
001B01r 2               ;	FIRST BYTE OF COEFF. TABLE IS N
001B01r 2               ;	COEFFICIENTS FOLLOW, HIGHEST POWER FIRST
001B01r 2               ; ----------------------------------------------------------------------------
001B01r 2               POLYNOMIAL:
001B01r 2  85 C8                sta     STRNG2
001B03r 2  84 C9                sty     STRNG2+1
001B05r 2               SERMAIN:
001B05r 2  20 rr rr             jsr     STORE_FAC_IN_TEMP2_ROUNDED
001B08r 2  B1 C8                lda     (STRNG2),y
001B0Ar 2  85 BE                sta     SERLEN
001B0Cr 2  A4 C8                ldy     STRNG2
001B0Er 2  C8                   iny
001B0Fr 2  98                   tya
001B10r 2  D0 02                bne     L3EBA
001B12r 2  E6 C9                inc     STRNG2+1
001B14r 2               L3EBA:
001B14r 2  85 C8                sta     STRNG2
001B16r 2  A4 C9                ldy     STRNG2+1
001B18r 2               L3EBE:
001B18r 2  20 rr rr             jsr     FMULT
001B1Br 2  A5 C8                lda     STRNG2
001B1Dr 2  A4 C9                ldy     STRNG2+1
001B1Fr 2  18                   clc
001B20r 2  69 05                adc     #BYTES_FP
001B22r 2  90 01                bcc     L3ECB
001B24r 2  C8                   iny
001B25r 2               L3ECB:
001B25r 2  85 C8                sta     STRNG2
001B27r 2  84 C9                sty     STRNG2+1
001B29r 2  20 rr rr             jsr     FADD
001B2Cr 2  A9 B3                lda     #TEMP2
001B2Er 2  A0 00                ldy     #$00
001B30r 2  C6 BE                dec     SERLEN
001B32r 2  D0 E4                bne     L3EBE
001B34r 2               RTS19:
001B34r 2  60                   rts
001B35r 2               
001B35r 1               .include "chrget.s"
001B35r 2               .segment "CHRGET"
000000r 2               RAMSTART1:
000000r 2               GENERIC_CHRGET:
000000r 2  E6 D1                inc     TXTPTR
000002r 2  D0 02                bne     GENERIC_CHRGOT
000004r 2  E6 D2                inc     TXTPTR+1
000006r 2               GENERIC_CHRGOT:
000006r 2               GENERIC_TXTPTR = GENERIC_CHRGOT + 1
000006r 2  AD 60 EA             lda     $EA60
000009r 2               .ifdef KBD
000009r 2                       jsr     LF430
000009r 2               .endif
000009r 2  C9 3A                cmp     #$3A
00000Br 2  B0 0A                bcs     L4058
00000Dr 2               GENERIC_CHRGOT2:
00000Dr 2  C9 20                cmp     #$20
00000Fr 2  F0 EF                beq     GENERIC_CHRGET
000011r 2  38                   sec
000012r 2  E9 30                sbc     #$30
000014r 2  38                   sec
000015r 2  E9 D0                sbc     #$D0
000017r 2               L4058:
000017r 2  60                   rts
000018r 2               
000018r 1               .include "rnd.s"
000018r 2               .segment "CODE"
001B35r 2               
001B35r 2               ; ----------------------------------------------------------------------------
001B35r 2               ; "RND" FUNCTION
001B35r 2               ; ----------------------------------------------------------------------------
001B35r 2               
001B35r 2               .ifdef KBD
001B35r 2               RND:
001B35r 2                       ldx     #$10
001B35r 2                       jsr     SIGN
001B35r 2                       beq     LFC26
001B35r 2                       bmi     LFC10
001B35r 2                       lda     RNDSEED
001B35r 2                       ldy     RNDSEED+1
001B35r 2               LFBFA:
001B35r 2                       sta     FAC+2
001B35r 2                       sty     FAC+1
001B35r 2               LFBFE:
001B35r 2                       asl     a
001B35r 2                       asl     a
001B35r 2                       eor     FAC+2
001B35r 2                       asl     a
001B35r 2                       eor     FAC+1
001B35r 2                       asl     a
001B35r 2                       asl     a
001B35r 2                       asl     a
001B35r 2                       asl     a
001B35r 2                       eor     FAC+1
001B35r 2                       asl     a
001B35r 2                       rol     FAC+2
001B35r 2                       rol     FAC+1
001B35r 2               LFC10:
001B35r 2                       lda     FAC+2
001B35r 2                       dex
001B35r 2                       bne     LFBFE
001B35r 2                       sta     RNDSEED
001B35r 2                       sta     FAC+3
001B35r 2                       lda     FAC+1
001B35r 2                       sta     RNDSEED+1
001B35r 2                       lda     #$80
001B35r 2                       sta     FAC
001B35r 2                       stx     FACSIGN
001B35r 2                       jmp     NORMALIZE_FAC2
001B35r 2               LFC26:
001B35r 2                       ldy     $03CA
001B35r 2                       lda     $03C7
001B35r 2                       ora     #$01
001B35r 2               GOMOVMF:
001B35r 2                       bne     LFBFA
001B35r 2                       .byte   $F0
001B35r 2               .else
001B35r 2               ; <<< THESE ARE MISSING ONE BYTE FOR FP VALUES >>>
001B35r 2               ; (non CONFIG_SMALL)
001B35r 2               CONRND1:
001B35r 2  98 35 44 7A          .byte   $98,$35,$44,$7A
001B39r 2               CONRND2:
001B39r 2  68 28 B1 46          .byte   $68,$28,$B1,$46
001B3Dr 2               RND:
001B3Dr 2  20 rr rr             jsr     SIGN
001B40r 2               .ifdef CONFIG_CBM_ALL
001B40r 2                       bmi     L3F01
001B40r 2                       bne     LDF63
001B40r 2                       lda     ENTROPY
001B40r 2                       sta     FAC+1
001B40r 2                       lda     ENTROPY+4
001B40r 2                       sta     FAC+2
001B40r 2                       lda     ENTROPY+1
001B40r 2                       sta     FAC+3
001B40r 2                       lda     ENTROPY+5
001B40r 2                       sta     FAC+4
001B40r 2                       jmp     LDF88
001B40r 2               LDF63:
001B40r 2               .else
001B40r 2  AA                   tax
001B41r 2  30 18                bmi     L3F01
001B43r 2               .endif
001B43r 2  A9 E2                lda     #<RNDSEED
001B45r 2  A0 00                ldy     #>RNDSEED
001B47r 2  20 rr rr             jsr     LOAD_FAC_FROM_YA
001B4Ar 2               .ifndef CONFIG_CBM_ALL
001B4Ar 2  8A                   txa
001B4Br 2  F0 E7                beq     RTS19
001B4Dr 2               .endif
001B4Dr 2  A9 rr                lda     #<CONRND1
001B4Fr 2  A0 rr                ldy     #>CONRND1
001B51r 2  20 rr rr             jsr     FMULT
001B54r 2  A9 rr                lda     #<CONRND2
001B56r 2  A0 rr                ldy     #>CONRND2
001B58r 2  20 rr rr             jsr     FADD
001B5Br 2               L3F01:
001B5Br 2  A6 BC                ldx     FAC_LAST
001B5Dr 2  A5 B9                lda     FAC+1
001B5Fr 2  85 BC                sta     FAC_LAST
001B61r 2  86 B9                stx     FAC+1
001B63r 2               .ifdef CONFIG_CBM_ALL
001B63r 2                       ldx     FAC+2
001B63r 2                       lda     FAC+3
001B63r 2                       sta     FAC+2
001B63r 2                       stx     FAC+3
001B63r 2               LDF88:
001B63r 2               .endif
001B63r 2  A9 00                lda     #$00
001B65r 2  85 BD                sta     FACSIGN
001B67r 2  A5 B8                lda     FAC
001B69r 2  85 C7                sta     FACEXTENSION
001B6Br 2  A9 80                lda     #$80
001B6Dr 2  85 B8                sta     FAC
001B6Fr 2  20 rr rr             jsr     NORMALIZE_FAC2
001B72r 2  A2 E2                ldx     #<RNDSEED
001B74r 2  A0 00                ldy     #>RNDSEED
001B76r 2               GOMOVMF:
001B76r 2  4C rr rr             jmp     STORE_FAC_AT_YX_ROUNDED
001B79r 2               .endif
001B79r 2               
001B79r 2               .segment "CHRGET"
000018r 2               ; ----------------------------------------------------------------------------
000018r 2               ; INITIAL VALUE FOR RANDOM NUMBER, ALSO COPIED
000018r 2               ; IN ALONG WITH CHRGET, BUT ERRONEOUSLY:
000018r 2               ; <<< THE LAST BYTE IS NOT COPIED >>>
000018r 2               ; (on all non-CONFIG_SMALL)
000018r 2               ; ----------------------------------------------------------------------------
000018r 2               GENERIC_RNDSEED:
000018r 2               .ifndef KBD
000018r 2               ; random number seed
000018r 2                 .ifdef CONFIG_SMALL
000018r 2                       .byte   $80,$4F,$C7,$52
000018r 2                 .else
000018r 2                   .ifdef CONFIG_11
000018r 2  80 4F C7 52          .byte   $80,$4F,$C7,$52,$58
00001Cr 2  58           
00001Dr 2                   .else
00001Dr 2                       .byte   $80,$4F,$C7,$52,$59
00001Dr 2                   .endif
00001Dr 2                 .endif
00001Dr 2               .endif
00001Dr 2               GENERIC_CHRGET_END:
00001Dr 2               
00001Dr 1               .include "trig.s"
00001Dr 2               .segment "CODE"
001B79r 2               
001B79r 2               .ifndef SYM1
001B79r 2               SIN_COS_TAN_ATN:
001B79r 2               ; ----------------------------------------------------------------------------
001B79r 2               ; "COS" FUNCTION
001B79r 2               ; ----------------------------------------------------------------------------
001B79r 2               COS:
001B79r 2  A9 rr                lda     #<CON_PI_HALF
001B7Br 2  A0 rr                ldy     #>CON_PI_HALF
001B7Dr 2  20 rr rr             jsr     FADD
001B80r 2               
001B80r 2               ; ----------------------------------------------------------------------------
001B80r 2               ; "SIN" FUNCTION
001B80r 2               ; ----------------------------------------------------------------------------
001B80r 2               SIN:
001B80r 2  20 rr rr             jsr     COPY_FAC_TO_ARG_ROUNDED
001B83r 2  A9 rr                lda     #<CON_PI_DOUB
001B85r 2  A0 rr                ldy     #>CON_PI_DOUB
001B87r 2  A6 C5                ldx     ARGSIGN
001B89r 2  20 rr rr             jsr     DIV
001B8Cr 2  20 rr rr             jsr     COPY_FAC_TO_ARG_ROUNDED
001B8Fr 2  20 rr rr             jsr     INT
001B92r 2  A9 00                lda     #$00
001B94r 2  85 C6                sta     STRNG1
001B96r 2  20 rr rr             jsr     FSUBT
001B99r 2               ; ----------------------------------------------------------------------------
001B99r 2               ; (FAC) = ANGLE AS A FRACTION OF A FULL CIRCLE
001B99r 2               ;
001B99r 2               ; NOW FOLD THE RANGE INTO A QUARTER CIRCLE
001B99r 2               ;
001B99r 2               ; <<< THERE ARE MUCH SIMPLER WAYS TO DO THIS >>>
001B99r 2               ; ----------------------------------------------------------------------------
001B99r 2  A9 rr                lda     #<QUARTER
001B9Br 2  A0 rr                ldy     #>QUARTER
001B9Dr 2  20 rr rr             jsr     FSUB
001BA0r 2  A5 BD                lda     FACSIGN
001BA2r 2  48                   pha
001BA3r 2  10 0D                bpl     SIN1
001BA5r 2  20 rr rr             jsr     FADDH
001BA8r 2  A5 BD                lda     FACSIGN
001BAAr 2  30 09                bmi     L3F5B
001BACr 2  A5 6B                lda     CPRMASK
001BAEr 2  49 FF                eor     #$FF
001BB0r 2  85 6B                sta     CPRMASK
001BB2r 2               ; ----------------------------------------------------------------------------
001BB2r 2               ; IF FALL THRU, RANGE IS 0...1/2
001BB2r 2               ; IF BRANCH HERE, RANGE IS 0...1/4
001BB2r 2               ; ----------------------------------------------------------------------------
001BB2r 2               SIN1:
001BB2r 2  20 rr rr             jsr     NEGOP
001BB5r 2               ; ----------------------------------------------------------------------------
001BB5r 2               ; IF FALL THRU, RANGE IS -1/2...0
001BB5r 2               ; IF BRANCH HERE, RANGE IS -1/4...0
001BB5r 2               ; ----------------------------------------------------------------------------
001BB5r 2               L3F5B:
001BB5r 2  A9 rr                lda     #<QUARTER
001BB7r 2  A0 rr                ldy     #>QUARTER
001BB9r 2  20 rr rr             jsr     FADD
001BBCr 2  68                   pla
001BBDr 2  10 03                bpl     L3F68
001BBFr 2  20 rr rr             jsr     NEGOP
001BC2r 2               L3F68:
001BC2r 2  A9 rr                lda     #<POLY_SIN
001BC4r 2  A0 rr                ldy     #>POLY_SIN
001BC6r 2  4C rr rr             jmp     POLYNOMIAL_ODD
001BC9r 2               
001BC9r 2               ; ----------------------------------------------------------------------------
001BC9r 2               ; "TAN" FUNCTION
001BC9r 2               ;
001BC9r 2               ; COMPUTE TAN(X) = SIN(X) / COS(X)
001BC9r 2               ; ----------------------------------------------------------------------------
001BC9r 2               TAN:
001BC9r 2  20 rr rr             jsr     STORE_FAC_IN_TEMP1_ROUNDED
001BCCr 2  A9 00                lda     #$00
001BCEr 2  85 6B                sta     CPRMASK
001BD0r 2  20 rr rr             jsr     SIN
001BD3r 2  A2 A5                ldx     #TEMP3
001BD5r 2  A0 00                ldy     #$00
001BD7r 2  20 rr rr             jsr     GOMOVMF
001BDAr 2  A9 AE                lda     #TEMP1+(5-BYTES_FP)
001BDCr 2  A0 00                ldy     #$00
001BDEr 2  20 rr rr             jsr     LOAD_FAC_FROM_YA
001BE1r 2  A9 00                lda     #$00
001BE3r 2  85 BD                sta     FACSIGN
001BE5r 2  A5 6B                lda     CPRMASK
001BE7r 2  20 rr rr             jsr     TAN1
001BEAr 2  A9 A5                lda     #TEMP3
001BECr 2  A0 00                ldy     #$00
001BEEr 2  4C rr rr             jmp     FDIV
001BF1r 2               TAN1:
001BF1r 2  48                   pha
001BF2r 2  4C rr rr             jmp     SIN1
001BF5r 2               
001BF5r 2               ; ----------------------------------------------------------------------------
001BF5r 2               .ifdef CONFIG_SMALL
001BF5r 2               CON_PI_HALF:
001BF5r 2                       .byte   $81,$49,$0F,$DB
001BF5r 2               CON_PI_DOUB:
001BF5r 2                       .byte   $83,$49,$0F,$DB
001BF5r 2               QUARTER:
001BF5r 2                       .byte   $7F,$00,$00,$00
001BF5r 2               POLY_SIN:
001BF5r 2                       .byte   $04,$86,$1E,$D7,$FB,$87,$99,$26
001BF5r 2                       .byte   $65,$87,$23,$34,$58,$86,$A5,$5D
001BF5r 2                       .byte   $E1,$83,$49,$0F,$DB
001BF5r 2               .else
001BF5r 2               CON_PI_HALF:
001BF5r 2  81 49 0F DA          .byte   $81,$49,$0F,$DA,$A2
001BF9r 2  A2           
001BFAr 2               CON_PI_DOUB:
001BFAr 2  83 49 0F DA          .byte   $83,$49,$0F,$DA,$A2
001BFEr 2  A2           
001BFFr 2               QUARTER:
001BFFr 2  7F 00 00 00          .byte   $7F,$00,$00,$00,$00
001C03r 2  00           
001C04r 2               POLY_SIN:
001C04r 2  05 84 E6 1A          .byte   $05,$84,$E6,$1A,$2D,$1B,$86,$28
001C08r 2  2D 1B 86 28  
001C0Cr 2  07 FB F8 87          .byte   $07,$FB,$F8,$87,$99,$68,$89,$01
001C10r 2  99 68 89 01  
001C14r 2  87 23 35 DF          .byte   $87,$23,$35,$DF,$E1,$86,$A5,$5D
001C18r 2  E1 86 A5 5D  
001C1Cr 2  E7 28 83 49          .byte   $E7,$28,$83,$49,$0F,$DA,$A2
001C20r 2  0F DA A2     
001C23r 2                 .ifndef CONFIG_11
001C23r 2               ; no easter egg text before BASIC 1.1
001C23r 2                 .elseif !.def(CONFIG_2A)
001C23r 2               ; ASCII encoded easter egg
001C23r 2               MICROSOFT:
001C23r 2                       .byte   $A6,$D3,$C1,$C8,$D4,$C8,$D5,$C4
001C23r 2                       .byte   $CE,$CA
001C23r 2                 .else
001C23r 2               ; PET encoded easter egg text since CBM2
001C23r 2               MICROSOFT:
001C23r 2  A1 54 46 8F          .byte   $A1,$54,$46,$8F,$13,$8F,$52,$43
001C27r 2  13 8F 52 43  
001C2Br 2  89 CD                .byte   $89,$CD
001C2Dr 2                 .endif
001C2Dr 2               .endif
001C2Dr 2               
001C2Dr 2               .ifndef AIM65
001C2Dr 2               ; ----------------------------------------------------------------------------
001C2Dr 2               ; "ATN" FUNCTION
001C2Dr 2               ; ----------------------------------------------------------------------------
001C2Dr 2               ATN:
001C2Dr 2  A5 BD                lda     FACSIGN
001C2Fr 2  48                   pha
001C30r 2  10 03                bpl     L3FDB
001C32r 2  20 rr rr             jsr     NEGOP
001C35r 2               L3FDB:
001C35r 2  A5 B8                lda     FAC
001C37r 2  48                   pha
001C38r 2  C9 81                cmp     #$81
001C3Ar 2  90 07                bcc     L3FE9
001C3Cr 2  A9 rr                lda     #<CON_ONE
001C3Er 2  A0 rr                ldy     #>CON_ONE
001C40r 2  20 rr rr             jsr     FDIV
001C43r 2               ; ----------------------------------------------------------------------------
001C43r 2               ; 0 <= X <= 1
001C43r 2               ; 0 <= ATN(X) <= PI/8
001C43r 2               ; ----------------------------------------------------------------------------
001C43r 2               L3FE9:
001C43r 2  A9 rr                lda     #<POLY_ATN
001C45r 2  A0 rr                ldy     #>POLY_ATN
001C47r 2  20 rr rr             jsr     POLYNOMIAL_ODD
001C4Ar 2  68                   pla
001C4Br 2  C9 81                cmp     #$81
001C4Dr 2  90 07                bcc     L3FFC
001C4Fr 2  A9 rr                lda     #<CON_PI_HALF
001C51r 2  A0 rr                ldy     #>CON_PI_HALF
001C53r 2  20 rr rr             jsr     FSUB
001C56r 2               L3FFC:
001C56r 2  68                   pla
001C57r 2  10 03                bpl     L4002
001C59r 2  4C rr rr             jmp     NEGOP
001C5Cr 2               L4002:
001C5Cr 2  60                   rts
001C5Dr 2               
001C5Dr 2               ; ----------------------------------------------------------------------------
001C5Dr 2               POLY_ATN:
001C5Dr 2               .ifdef CONFIG_SMALL
001C5Dr 2                       .byte   $08
001C5Dr 2               		.byte	$78,$3A,$C5,$37
001C5Dr 2               		.byte	$7B,$83,$A2,$5C
001C5Dr 2               		.byte	$7C,$2E,$DD,$4D
001C5Dr 2               		.byte	$7D,$99,$B0,$1E
001C5Dr 2               		.byte	$7D,$59,$ED,$24
001C5Dr 2               		.byte	$7E,$91,$72,$00
001C5Dr 2               		.byte	$7E,$4C,$B9,$73
001C5Dr 2               		.byte	$7F,$AA,$AA,$53
001C5Dr 2               		.byte	$81,$00,$00,$00
001C5Dr 2               .else
001C5Dr 2  0B                   .byte   $0B
001C5Er 2  76 B3 83 BD  		.byte	$76,$B3,$83,$BD,$D3
001C62r 2  D3           
001C63r 2  79 1E F4 A6  		.byte	$79,$1E,$F4,$A6,$F5
001C67r 2  F5           
001C68r 2  7B 83 FC B0  		.byte	$7B,$83,$FC,$B0,$10
001C6Cr 2  10           
001C6Dr 2  7C 0C 1F 67          .byte   $7C,$0C,$1F,$67,$CA
001C71r 2  CA           
001C72r 2  7C DE 53 CB  		.byte	$7C,$DE,$53,$CB,$C1
001C76r 2  C1           
001C77r 2  7D 14 64 70  		.byte	$7D,$14,$64,$70,$4C
001C7Br 2  4C           
001C7Cr 2  7D B7 EA 51  		.byte	$7D,$B7,$EA,$51,$7A
001C80r 2  7A           
001C81r 2  7D 63 30 88  		.byte	$7D,$63,$30,$88,$7E
001C85r 2  7E           
001C86r 2  7E 92 44 99  		.byte	$7E,$92,$44,$99,$3A
001C8Ar 2  3A           
001C8Br 2  7E 4C CC 91  		.byte	$7E,$4C,$CC,$91,$C7
001C8Fr 2  C7           
001C90r 2  7F AA AA AA  		.byte	$7F,$AA,$AA,$AA,$13
001C94r 2  13           
001C95r 2  81 00 00 00          .byte   $81,$00,$00,$00,$00
001C99r 2  00           
001C9Ar 2               .endif
001C9Ar 2               
001C9Ar 2               .if .def(CONFIG_11A) && (!.def(CONFIG_2))
001C9Ar 2               		.byte	$00 ; XXX
001C9Ar 2               .endif
001C9Ar 2               .endif
001C9Ar 2               .endif
001C9Ar 2               
001C9Ar 1               .include "init.s"
001C9Ar 2               .segment "INIT"
000000r 2               
000000r 2               .ifdef KBD
000000r 2               FNDLIN2:
000000r 2                       php
000000r 2                       jmp     FNDLIN
000000r 2               .endif
000000r 2               
000000r 2               ; ----------------------------------------------------------------------------
000000r 2               PR_WRITTEN_BY:
000000r 2               .ifndef KBD
000000r 2                 .ifndef CONFIG_CBM_ALL
000000r 2                   .ifndef AIM65
000000r 2                     .ifndef SYM1
000000r 2  A9 rr                lda     #<QT_WRITTEN_BY
000002r 2  A0 rr                ldy     #>QT_WRITTEN_BY
000004r 2  20 rr rr             jsr     STROUT
000007r 2                     .endif
000007r 2                   .endif
000007r 2                 .endif
000007r 2               .endif
000007r 2               COLD_START:
000007r 2               .ifdef SYM1
000007r 2                       jsr     ACCESS
000007r 2               .endif
000007r 2               .ifdef KBD
000007r 2                       lda     #<LFD81
000007r 2                       sta     $03A0
000007r 2                       lda     #>LFD81
000007r 2                       sta     $03A1
000007r 2                       lda     #$20
000007r 2                       sta     $0480
000007r 2                       lda     $0352
000007r 2                       sta     $04
000007r 2                       lda     $0353
000007r 2                       sta     $05
000007r 2               .else
000007r 2                 .ifndef CBM2
000007r 2  A2 FF                ldx     #$FF
000009r 2  86 91                stx     CURLIN+1
00000Br 2                 .endif
00000Br 2                 .ifdef CONFIG_NO_INPUTBUFFER_ZP
00000Br 2                       ldx     #$FB
00000Br 2                 .elseif .def(AIM65)
00000Br 2                       ldx     #$FE
00000Br 2                 .endif
00000Br 2  9A                   txs
00000Cr 2                 .ifndef CONFIG_CBM_ALL
00000Cr 2  A9 rr                lda     #<COLD_START
00000Er 2  A0 rr                ldy     #>COLD_START
000010r 2  85 03                sta     GORESTART+1
000012r 2  84 04                sty     GORESTART+2
000014r 2                   .ifndef AIM65
000014r 2  85 06                sta     GOSTROUT+1
000016r 2  84 07                sty     GOSTROUT+2
000018r 2  A9 rr                lda     #<AYINT
00001Ar 2  A0 rr                ldy     #>AYINT
00001Cr 2  85 08                sta     GOAYINT
00001Er 2  84 09                sty     GOAYINT+1
000020r 2  A9 rr                lda     #<GIVAYF
000022r 2  A0 rr                ldy     #>GIVAYF
000024r 2  85 0A                sta     GOGIVEAYF
000026r 2  84 0B                sty     GOGIVEAYF+1
000028r 2                   .endif
000028r 2                 .endif
000028r 2  A9 4C                lda     #$4C
00002Ar 2                 .ifdef CONFIG_CBM_ALL
00002Ar 2                       sta     JMPADRS
00002Ar 2                 .endif
00002Ar 2  85 02                sta     GORESTART
00002Cr 2                 .ifdef AIM65
00002Cr 2                       sta     JMPADRS
00002Cr 2                       sta     ATN
00002Cr 2                       sta     GOSTROUT
00002Cr 2                 .else
00002Cr 2                 .ifndef CONFIG_CBM_ALL
00002Cr 2  85 05                sta     GOSTROUT
00002Er 2  85 AB                sta     JMPADRS
000030r 2                 .endif
000030r 2                 .ifdef SYM1
000030r 2                       sta     USR1
000030r 2                       sta     USR3
000030r 2                       sta     USR2
000030r 2                 .endif
000030r 2                 .if (!.def(CONFIG_RAM)) && (!.def(CONFIG_CBM_ALL))
000030r 2  85 02                sta     USR
000032r 2                 .endif
000032r 2                 .endif
000032r 2               
000032r 2                 .ifndef CONFIG_RAM
000032r 2                   .ifdef APPLE
000032r 2                         lda     #<USR_FUNC
000032r 2                         ldy     #>USR_FUNC
000032r 2                   .else
000032r 2  A9 rr                  lda     #<IQERR
000034r 2  A0 rr                  ldy     #>IQERR
000036r 2                   .endif
000036r 2                   .ifdef AIM65
000036r 2                         sta     ATN+1
000036r 2                         sty     ATN+2
000036r 2                         sta     GOSTROUT+1
000036r 2                         sty     GOSTROUT+2
000036r 2                   .else
000036r 2  85 03                  sta     USR+1
000038r 2  84 04                  sty     USR+2
00003Ar 2                     .ifdef SYM1
00003Ar 2                         sta     USR1+1
00003Ar 2                         sty     USR1+2
00003Ar 2                         lda     #<DUMPT
00003Ar 2                         ldy     #>DUMPT
00003Ar 2                         sta     USR2+1
00003Ar 2                         sty     USR2+2
00003Ar 2                         lda     #<L8C78
00003Ar 2                         ldy     #>L8C78
00003Ar 2                         sta     USR3+1
00003Ar 2                         sty     USR3+2
00003Ar 2                     .endif
00003Ar 2                   .endif
00003Ar 2                 .endif
00003Ar 2                 .ifndef CBM1
00003Ar 2  A9 28                lda     #WIDTH
00003Cr 2  85 0E                sta     Z17
00003Er 2  A9 1E                lda     #WIDTH2
000040r 2  85 0F                sta     Z18
000042r 2                 .endif
000042r 2                 .ifdef EATER
000042r 2  20 rr rr             jsr     LCDINIT
000045r 2                 .endif
000045r 2               .endif
000045r 2               
000045r 2               ; All non-CONFIG_SMALL versions of BASIC have
000045r 2               ; the same bug here: While the number of bytes
000045r 2               ; to be copied is correct for CONFIG_SMALL,
000045r 2               ; it is one byte short on non-CONFIG_SMALL:
000045r 2               ; It seems the "ldx" value below has been
000045r 2               ; hardcoded. So on these configurations,
000045r 2               ; the last byte of GENERIC_RNDSEED, which
000045r 2               ; is 5 bytes instead of 4, does not get copied -
000045r 2               ; which is nothing major, because it is just
000045r 2               ; the least significant 8 bits of the mantissa
000045r 2               ; of the random number seed.
000045r 2               ; KBD added three bytes to CHRGET and removed
000045r 2               ; the random number seed, but only adjusted
000045r 2               ; the number of bytes by adding 3 - this
000045r 2               ; copies four bytes too many, which is no
000045r 2               ; problem.
000045r 2               .ifdef CONFIG_SMALL
000045r 2                 .ifdef KBD
000045r 2                       ldx     #GENERIC_CHRGET_END-GENERIC_CHRGET+4
000045r 2                 .else
000045r 2                       ldx     #GENERIC_CHRGET_END-GENERIC_CHRGET
000045r 2                 .endif
000045r 2               .else
000045r 2  A2 1C                ldx     #GENERIC_CHRGET_END-GENERIC_CHRGET-1 ; XXX
000047r 2               .endif
000047r 2               L4098:
000047r 2  BD rr rr             lda     GENERIC_CHRGET-1,x
00004Ar 2  95 C9                sta     CHRGET-1,x
00004Cr 2  CA                   dex
00004Dr 2  D0 F8                bne     L4098
00004Fr 2               .ifdef CONFIG_2
00004Fr 2  A9 03                lda     #$03
000051r 2  85 AA                sta     DSCLEN
000053r 2               .endif
000053r 2               .ifndef KBD
000053r 2  8A                   txa
000054r 2  85 BF                sta     SHIFTSIGNEXT
000056r 2                 .ifdef CONFIG_CBM_ALL
000056r 2                       sta     CURDVC
000056r 2                 .endif
000056r 2  85 6F                sta     LASTPT+1
000058r 2                 .ifndef AIM65
000058r 2                 .if .defined(CONFIG_NULL) || .defined(CONFIG_PRINTNULLS)
000058r 2                       sta     Z15
000058r 2                 .endif
000058r 2                 .endif
000058r 2                 .ifndef CONFIG_11
000058r 2                       sta     POSX
000058r 2                 .endif
000058r 2  48                   pha
000059r 2  85 6C                sta     Z14
00005Br 2                 .ifndef CBM2
00005Br 2                  .ifndef AIM65
00005Br 2                  .ifndef SYM1
00005Br 2                   .ifndef MICROTAN
00005Br 2  A9 03                lda     #$03
00005Dr 2  85 AA                sta     DSCLEN
00005Fr 2                   .endif
00005Fr 2                  .endif
00005Fr 2                  .endif
00005Fr 2                   .ifndef CONFIG_11
00005Fr 2                       lda     #$2C
00005Fr 2                       sta     LINNUM+1
00005Fr 2                   .endif
00005Fr 2  20 rr rr             jsr     CRDO
000062r 2                 .endif
000062r 2                 .ifdef CBM2
000062r 2                       inx
000062r 2                       stx     INPUTBUFFER-3
000062r 2                       stx     INPUTBUFFER-4
000062r 2                 .endif
000062r 2                 .ifdef APPLE
000062r 2                       lda     #$01
000062r 2                       sta     INPUTBUFFER-3
000062r 2                       sta     INPUTBUFFER-4
000062r 2                 .endif
000062r 2  A2 70                ldx     #TEMPST
000064r 2  86 6D                stx     TEMPPT
000066r 2               .ifndef CONFIG_CBM_ALL
000066r 2  A9 rr                lda     #<QT_MEMORY_SIZE
000068r 2  A0 rr                ldy     #>QT_MEMORY_SIZE
00006Ar 2  20 rr rr             jsr     STROUT
00006Dr 2                 .ifdef APPLE
00006Dr 2                       jsr     INLINX
00006Dr 2                 .else
00006Dr 2  20 rr rr             jsr     NXIN
000070r 2                 .endif
000070r 2  86 D1                stx     TXTPTR
000072r 2  84 D2                sty     TXTPTR+1
000074r 2  20 CA 00             jsr     CHRGET
000077r 2                 .ifndef AIM65
000077r 2                   .ifndef SYM1
000077r 2  C9 41                cmp     #$41
000079r 2  F0 85                beq     PR_WRITTEN_BY
00007Br 2                   .endif
00007Br 2                 .endif
00007Br 2  A8                   tay
00007Cr 2  D0 25                bne     L40EE
00007Er 2               .endif
00007Er 2               .ifndef CBM2
00007Er 2  A9 00                lda     #<RAMSTART2
000080r 2               .endif
000080r 2  A0 04                ldy     #>RAMSTART2
000082r 2               .ifdef CONFIG_2
000082r 2  85 82                sta     TXTTAB
000084r 2  84 83                sty     TXTTAB+1
000086r 2               .endif
000086r 2  85 10                sta     LINNUM
000088r 2  84 11                sty     LINNUM+1
00008Ar 2               .ifdef CBM2
00008Ar 2               		tay
00008Ar 2               .else
00008Ar 2  A0 00                ldy     #$00
00008Cr 2               .endif
00008Cr 2               L40D7:
00008Cr 2  E6 10                inc     LINNUM
00008Er 2  D0 02                bne     L40DD
000090r 2  E6 11                inc     LINNUM+1
000092r 2               .ifdef CBM1
000092r 2               ; CBM: hard RAM top limit is $8000
000092r 2                       lda     LINNUM+1
000092r 2                       cmp     #$80
000092r 2                       beq     L40FA
000092r 2               .endif
000092r 2               .ifdef CBM2
000092r 2               ; optimized version of the CBM1 code
000092r 2                       bmi     L40FA
000092r 2               .endif
000092r 2               .if .def(AIM65)
000092r 2               ; AIM65: hard RAM top limit is $A000
000092r 2                       lda     LINNUM+1
000092r 2                       cmp     #$A0
000092r 2                       beq     L40FA
000092r 2               .endif
000092r 2               L40DD:
000092r 2               .ifdef CONFIG_2
000092r 2  A9 55                lda     #$55 ; 01010101 / 10101010
000094r 2               .else
000094r 2                       lda     #$92 ; 10010010 / 00100100
000094r 2               .endif
000094r 2  91 10                sta     (LINNUM),y
000096r 2  D1 10                cmp     (LINNUM),y
000098r 2  D0 15                bne     L40FA
00009Ar 2  0A                   asl     a
00009Br 2  91 10                sta     (LINNUM),y
00009Dr 2  D1 10                cmp     (LINNUM),y
00009Fr 2               .ifdef CONFIG_CBM_ALL
00009Fr 2                       beq     L40D7
00009Fr 2               .else
00009Fr 2                 .ifndef CONFIG_11
00009Fr 2                       beq     L40D7; old: faster
00009Fr 2                       bne     L40FA
00009Fr 2                 .else
00009Fr 2  D0 0E                bne     L40FA; new: slower
0000A1r 2  F0 E9                beq     L40D7
0000A3r 2                 .endif
0000A3r 2               L40EE:
0000A3r 2  20 D0 00             jsr     CHRGOT
0000A6r 2  20 rr rr             jsr     LINGET
0000A9r 2  A8                   tay
0000AAr 2  F0 03                beq     L40FA
0000ACr 2  4C rr rr             jmp     SYNERR
0000AFr 2               .endif
0000AFr 2               L40FA:
0000AFr 2  A5 10                lda     LINNUM
0000B1r 2  A4 11                ldy     LINNUM+1
0000B3r 2  85 8E                sta     MEMSIZ
0000B5r 2  84 8F                sty     MEMSIZ+1
0000B7r 2               .if !(.def(MICROTAN) || .def(AIM65) || .def(SYM1))
0000B7r 2  85 8A                sta     FRETOP
0000B9r 2  84 8B                sty     FRETOP+1
0000BBr 2               .endif
0000BBr 2               L4106:
0000BBr 2               .ifndef CONFIG_CBM_ALL
0000BBr 2                 .ifdef APPLE
0000BBr 2                       lda     #$FF
0000BBr 2                       jmp     L2829
0000BBr 2                       .word	STROUT ; PATCH!
0000BBr 2                       jsr     NXIN
0000BBr 2                 .else
0000BBr 2  A9 rr                lda     #<QT_TERMINAL_WIDTH
0000BDr 2  A0 rr                ldy     #>QT_TERMINAL_WIDTH
0000BFr 2  20 rr rr             jsr     STROUT
0000C2r 2  20 rr rr             jsr     NXIN
0000C5r 2                 .endif
0000C5r 2  86 D1                stx     TXTPTR
0000C7r 2  84 D2                sty     TXTPTR+1
0000C9r 2  20 CA 00             jsr     CHRGET
0000CCr 2  A8                   tay
0000CDr 2  F0 1C                beq     L4136
0000CFr 2  20 rr rr             jsr     LINGET
0000D2r 2  A5 11                lda     LINNUM+1
0000D4r 2  D0 E5                bne     L4106
0000D6r 2  A5 10                lda     LINNUM
0000D8r 2  C9 10                cmp     #$10
0000DAr 2  90 DF                bcc     L4106
0000DCr 2               L2829:
0000DCr 2  85 0E                sta     Z17
0000DEr 2               L4129:
0000DEr 2                 .ifdef AIM65
0000DEr 2                       sbc     #$0A
0000DEr 2                 .else
0000DEr 2  E9 0E                sbc     #$0E
0000E0r 2                 .endif
0000E0r 2  B0 FC                bcs     L4129
0000E2r 2  49 FF                eor     #$FF
0000E4r 2                 .ifdef AIM65
0000E4r 2                       sbc     #$08
0000E4r 2                 .else
0000E4r 2  E9 0C                sbc     #$0C
0000E6r 2                 .endif
0000E6r 2  18                   clc
0000E7r 2  65 0E                adc     Z17
0000E9r 2  85 0F                sta     Z18
0000EBr 2               .endif
0000EBr 2               L4136:
0000EBr 2               .ifdef CONFIG_RAM
0000EBr 2                       lda     #<QT_WANT
0000EBr 2                       ldy     #>QT_WANT
0000EBr 2                       jsr     STROUT
0000EBr 2                       jsr     NXIN
0000EBr 2                       stx     TXTPTR
0000EBr 2                       sty     TXTPTR+1
0000EBr 2                       jsr     CHRGET
0000EBr 2                       ldx     #<RAMSTART1
0000EBr 2                       ldy     #>RAMSTART1
0000EBr 2                       cmp     #'Y'
0000EBr 2                       beq     L4183
0000EBr 2                       cmp     #'A'
0000EBr 2                       beq     L4157
0000EBr 2                       cmp     #'N'
0000EBr 2                       bne     L4136
0000EBr 2               L4157:
0000EBr 2                       ldx     #<IQERR
0000EBr 2                       ldy     #>IQERR
0000EBr 2                       stx     UNFNC_ATN
0000EBr 2                       sty     UNFNC_ATN+1
0000EBr 2                       ldx     #<ATN	; overwrite starting
0000EBr 2                       ldy     #>ATN	; with ATN
0000EBr 2                       cmp     #'A'
0000EBr 2                       beq     L4183
0000EBr 2                       ldx     #<IQERR
0000EBr 2                       ldy     #>IQERR
0000EBr 2                       stx     UNFNC_COS
0000EBr 2                       sty     UNFNC_COS+1
0000EBr 2                       stx     UNFNC_TAN
0000EBr 2                       sty     UNFNC_TAN+1
0000EBr 2                       stx     UNFNC_SIN
0000EBr 2                       sty     UNFNC_SIN+1
0000EBr 2                       ldx     #<SIN_COS_TAN_ATN	; overwrite
0000EBr 2                       ldy     #>SIN_COS_TAN_ATN	; all of trig.s
0000EBr 2               L4183:
0000EBr 2               .else
0000EBr 2  A2 00                ldx     #<RAMSTART2
0000EDr 2  A0 04                ldy     #>RAMSTART2
0000EFr 2               .endif
0000EFr 2  86 82                stx     TXTTAB
0000F1r 2  84 83                sty     TXTTAB+1
0000F3r 2  A0 00                ldy     #$00
0000F5r 2  98                   tya
0000F6r 2  91 82                sta     (TXTTAB),y
0000F8r 2  E6 82                inc     TXTTAB
0000FAr 2               .ifndef CBM2
0000FAr 2  D0 02                bne     L4192
0000FCr 2  E6 83                inc     TXTTAB+1
0000FEr 2               L4192:
0000FEr 2               .endif
0000FEr 2               .if CONFIG_SCRTCH_ORDER = 1
0000FEr 2                       jsr     SCRTCH
0000FEr 2               .endif
0000FEr 2  A5 82                lda     TXTTAB
000100r 2  A4 83                ldy     TXTTAB+1
000102r 2  20 rr rr             jsr     REASON
000105r 2               .ifdef CBM2
000105r 2                       lda     #<QT_BASIC
000105r 2                       ldy     #>QT_BASIC
000105r 2                       jsr     STROUT
000105r 2               .else
000105r 2  20 rr rr             jsr     CRDO
000108r 2               .endif
000108r 2  A5 8E                lda     MEMSIZ
00010Ar 2  38                   sec
00010Br 2  E5 82                sbc     TXTTAB
00010Dr 2  AA                   tax
00010Er 2  A5 8F                lda     MEMSIZ+1
000110r 2  E5 83                sbc     TXTTAB+1
000112r 2  20 rr rr             jsr     LINPRT
000115r 2  A9 rr                lda     #<QT_BYTES_FREE
000117r 2  A0 rr                ldy     #>QT_BYTES_FREE
000119r 2  20 rr rr             jsr     STROUT
00011Cr 2               .if CONFIG_SCRTCH_ORDER = 2
00011Cr 2  20 rr rr             jsr     SCRTCH
00011Fr 2               .endif
00011Fr 2               .ifdef CONFIG_CBM_ALL
00011Fr 2                       jmp     RESTART
00011Fr 2               .elseif .def(AIM65)
00011Fr 2                       lda     #<CRDO
00011Fr 2                       ldy     #>CRDO
00011Fr 2                       sta     GORESTART+1
00011Fr 2                       sty     GORESTART+2
00011Fr 2                       jmp     RESTART
00011Fr 2               .else
00011Fr 2  A9 rr                lda     #<STROUT
000121r 2  A0 rr                ldy     #>STROUT
000123r 2  85 06                sta     GOSTROUT+1
000125r 2  84 07                sty     GOSTROUT+2
000127r 2                 .if CONFIG_SCRTCH_ORDER = 3
000127r 2                        jsr     SCRTCH
000127r 2                 .endif
000127r 2  A9 rr                lda     #<RESTART
000129r 2  A0 rr                ldy     #>RESTART
00012Br 2  85 03                sta     GORESTART+1
00012Dr 2  84 04                sty     GORESTART+2
00012Fr 2  6C 03 00             jmp     (GORESTART+1)
000132r 2               .endif
000132r 2               
000132r 2                 .if .def(CONFIG_RAM) || .def(OSI)
000132r 2               ; OSI is compiled for ROM, but includes
000132r 2               ; this unused string
000132r 2               QT_WANT:
000132r 2                       .byte   "WANT SIN-COS-TAN-ATN"
000132r 2                       .byte   0
000132r 2                 .endif
000132r 2               QT_WRITTEN_BY:
000132r 2                 .ifndef CONFIG_CBM_ALL
000132r 2                 .if !(.def(AIM65) || .def(SYM1))
000132r 2                   .ifdef APPLE
000132r 2               		asc80 "COPYRIGHT 1977 BY MICROSOFT CO"
000132r 2               		.byte	CR,0
000132r 2                   .else
000132r 2  0D 0A 0C             .byte   CR,LF,$0C ; FORM FEED
000135r 2                     .ifndef CONFIG_11
000135r 2                       .byte   "WRITTEN BY RICHARD W. WEILAND."
000135r 2                     .else
000135r 2  57 52 49 54          .byte   "WRITTEN BY WEILAND & GATES"
000139r 2  54 45 4E 20  
00013Dr 2  42 59 20 57  
00014Fr 2                     .endif
00014Fr 2  0D 0A 00             .byte   CR,LF,0
000152r 2                   .endif
000152r 2                  .endif
000152r 2               QT_MEMORY_SIZE:
000152r 2  4D 45 4D 4F          .byte   "MEMORY SIZE"
000156r 2  52 59 20 53  
00015Ar 2  49 5A 45     
00015Dr 2  00                   .byte   0
00015Er 2               QT_TERMINAL_WIDTH:
00015Er 2                   .if !(.def(AIM65) || .def(SYM1))
00015Er 2  54 45 52 4D          .byte   "TERMINAL "
000162r 2  49 4E 41 4C  
000166r 2  20           
000167r 2                   .endif
000167r 2  57 49 44 54          .byte   "WIDTH"
00016Br 2  48           
00016Cr 2  00                   .byte   0
00016Dr 2                 .endif
00016Dr 2               QT_BYTES_FREE:
00016Dr 2  20 42 59 54          .byte   " BYTES FREE"
000171r 2  45 53 20 46  
000175r 2  52 45 45     
000178r 2                 .ifdef CBM1
000178r 2                 .elseif .def(CBM2)
000178r 2                       .byte   CR,0
000178r 2                 .elseif .def(APPLE)
000178r 2                       .byte   0
000178r 2                 .else
000178r 2  0D 0A 0D 0A          .byte   CR,LF,CR,LF
00017Cr 2                 .endif
00017Cr 2               QT_BASIC:
00017Cr 2                 .ifdef OSI
00017Cr 2                       .byte   "OSI 6502 BASIC VERSION 1.0 REV 3.2"
00017Cr 2                 .endif
00017Cr 2                 .ifdef KIM
00017Cr 2                       .byte   "MOS TECH 6502 BASIC V1.1"
00017Cr 2                 .endif
00017Cr 2                 .ifdef MICROTAN
00017Cr 2                       .byte   "MICROTAN BASIC"
00017Cr 2                 .endif
00017Cr 2                 .ifdef AIM65
00017Cr 2                       .byte   "  AIM 65 BASIC V1.1"
00017Cr 2                 .endif
00017Cr 2                 .ifdef SYM1
00017Cr 2                       .byte   "BASIC V1.1"
00017Cr 2                 .endif
00017Cr 2                 .ifdef CBM1
00017Cr 2                       .byte   $13 ; HOME
00017Cr 2                       .byte   "*** COMMODORE BASIC ***"
00017Cr 2                       .byte   $11,$11,$11,0 ; DOWN/DOWN/DOWN
00017Cr 2                 .endif
00017Cr 2                 .ifdef CBM2
00017Cr 2                       .byte   "### COMMODORE BASIC ###"
00017Cr 2                       .byte   CR,CR,0
00017Cr 2                 .endif
00017Cr 2                 .ifdef APPLE
00017Cr 2                       .byte   LF,CR,LF
00017Cr 2               		.byte	"APPLE BASIC V1.1"
00017Cr 2                 .endif
00017Cr 2                 .ifndef CONFIG_CBM_ALL
00017Cr 2  0D 0A                .byte   CR,LF
00017Er 2                   .ifdef MICROTAN
00017Er 2                       .byte   "(C) 1980 MICROSOFT"
00017Er 2                   .elseif .def(AIM65)
00017Er 2                       .byte   0
00017Er 2                       .byte   "(C) 1978 MICROSOFT"
00017Er 2                   .elseif .def(SYM1)
00017Er 2                       .byte   "COPYRIGHT 1978 SYNERTEK SYSTEMS CORP."
00017Er 2                   .else
00017Er 2  43 4F 50 59          .byte   "COPYRIGHT 1977 BY MICROSOFT CO."
000182r 2  52 49 47 48  
000186r 2  54 20 31 39  
00019Dr 2                   .endif
00019Dr 2  0D 0A                .byte   CR,LF
00019Fr 2                     .ifndef AIM65
00019Fr 2  00                   .byte   0
0001A0r 2                     .endif
0001A0r 2                 .endif
0001A0r 2               .endif
0001A0r 2               
0001A0r 1               .include "extra.s"
0001A0r 2               .segment "EXTRA"
000000r 2               
000000r 2               .ifdef KIM
000000r 2               .include "kim_extra.s"
000000r 2               .endif
000000r 2               
000000r 2               .ifdef CONFIG_CBM1_PATCHES
000000r 2               .include "cbm1_patches.s"
000000r 2               .endif
000000r 2               
000000r 2               .ifdef KBD
000000r 2               .include "kbd_extra.s"
000000r 2               .endif
000000r 2               
000000r 2               .ifdef APPLE
000000r 2               .include "apple_extra.s"
000000r 2               .endif
000000r 2               
000000r 2               .ifdef MICROTAN
000000r 2               .include "microtan_extra.s"
000000r 2               .endif
000000r 2               
000000r 2               .ifdef AIM65
000000r 2               .include "aim65_extra.s"
000000r 2               .endif
000000r 2               
000000r 2               .ifdef SYM1
000000r 2                       .byte   0,0,0
000000r 2               .endif
000000r 2               
000000r 2               .ifdef EATER
000000r 2               .include "bios.s"
000000r 3               .setcpu "65C02"
000000r 3               .debuginfo
000000r 3               
000000r 3               .zeropage
0000CA  3                               .org ZP_START0
000000  3  xx           READ_PTR:       .res 1
000001  3  xx           WRITE_PTR:      .res 1
000002  3               
000002  3               .segment "INPUT_BUFFER"
000000r 3  xx xx xx xx  INPUT_BUFFER:   .res $100
000004r 3  xx xx xx xx  
000008r 3  xx xx xx xx  
000100r 3               
000100r 3               .segment "BIOS"
000000r 3               
000000r 3               ACIA_DATA       = $5000
000000r 3               ACIA_STATUS     = $5001
000000r 3               ACIA_CMD        = $5002
000000r 3               ACIA_CTRL       = $5003
000000r 3               PORTA           = $6001
000000r 3               DDRA            = $6003
000000r 3               
000000r 3               DELAY           = $01     ; transmission delay
000000r 3               
000000r 3               LOAD:
000000r 3  60                           rts
000001r 3               
000001r 3               SAVE:
000001r 3  60                           rts
000002r 3               
000002r 3               
000002r 3               ; Input a character from the serial interface.
000002r 3               ; On return, carry flag indicates whether a key was pressed
000002r 3               ; If a key was pressed, the key value will be in the A register
000002r 3               ;
000002r 3               ; Modifies: flags, A
000002r 3               MONRDKEY:
000002r 3               CHRIN:
000002r 3  DA                           phx
000003r 3  20 rr rr                     jsr     BUFFER_SIZE
000006r 3  F0 1A                        beq     @no_keypressed
000008r 3  20 rr rr                     jsr     READ_BUFFER
00000Br 3  20 rr rr                     jsr     CHROUT                  ; echo
00000Er 3  48                           pha
00000Fr 3  20 rr rr                     jsr     BUFFER_SIZE
000012r 3  C9 B0                        cmp     #$B0
000014r 3  B0 08                        bcs     @mostly_full
000016r 3  A9 FE                        lda     #$fe
000018r 3  2D 01 60                     and     PORTA
00001Br 3  8D 01 60                     sta     PORTA
00001Er 3               @mostly_full:
00001Er 3  68                           pla
00001Fr 3  FA                           plx
000020r 3  38                           sec
000021r 3  60                           rts
000022r 3               @no_keypressed:
000022r 3  FA                           plx
000023r 3  18                           clc
000024r 3  60                           rts
000025r 3               
000025r 3               
000025r 3               ; Output a character (from the A register) to the serial interface.
000025r 3               ;
000025r 3               ; Modifies: flags
000025r 3               MONCOUT:
000025r 3               CHROUT:
000025r 3  48                           pha
000026r 3  8D 00 50                     sta     ACIA_DATA
000029r 3  A9 01                        lda     #DELAY
00002Br 3  3A           @txdelay:       dec
00002Cr 3  D0 FD                        bne     @txdelay
00002Er 3  68                           pla
00002Fr 3  60                           rts
000030r 3               
000030r 3               ; Initialize the circular input buffer
000030r 3               ; Modifies: flags, A
000030r 3               INIT_BUFFER:
000030r 3  A5 00                        lda READ_PTR
000032r 3  85 01                        sta WRITE_PTR
000034r 3  A9 01                        lda #$01
000036r 3  8D 03 60                     sta DDRA
000039r 3  A9 FE                        lda #$fe
00003Br 3  2D 01 60                     and PORTA
00003Er 3  8D 01 60                     sta PORTA
000041r 3  60                           rts
000042r 3               
000042r 3               ; Write a character (from the A register) to the circular input buffer
000042r 3               ; Modifies: flags, X
000042r 3               WRITE_BUFFER:
000042r 3  A6 01                        ldx WRITE_PTR
000044r 3  9D rr rr                     sta INPUT_BUFFER,x
000047r 3  E6 01                        inc WRITE_PTR
000049r 3  60                           rts
00004Ar 3               
00004Ar 3               ; Read a character from the circular input buffer and put it in the A register
00004Ar 3               ; Modifies: flags, A, X
00004Ar 3               READ_BUFFER:
00004Ar 3  A6 00                        ldx READ_PTR
00004Cr 3  BD rr rr                     lda INPUT_BUFFER,x
00004Fr 3  E6 00                        inc READ_PTR
000051r 3  60                           rts
000052r 3               
000052r 3               ; Return (in A) the number of unread bytes in the circular input buffer
000052r 3               ; Modifies: flags, A
000052r 3               BUFFER_SIZE:
000052r 3  A5 01                        lda WRITE_PTR
000054r 3  38                           sec
000055r 3  E5 00                        sbc READ_PTR
000057r 3  60                           rts
000058r 3               
000058r 3               
000058r 3               ; Interrupt request handler
000058r 3               IRQ_HANDLER:
000058r 3  48                           pha
000059r 3  DA                           phx
00005Ar 3  AD 01 50                     lda     ACIA_STATUS
00005Dr 3                               ; For now, assume the only source of interrupts is incoming data
00005Dr 3  AD 00 50                     lda     ACIA_DATA
000060r 3  20 rr rr                     jsr     WRITE_BUFFER
000063r 3  20 rr rr                     jsr     BUFFER_SIZE
000066r 3  C9 F0                        cmp     #$F0
000068r 3  90 08                        bcc     @not_full
00006Ar 3  A9 01                        lda     #$01
00006Cr 3  0D 01 60                     ora     PORTA
00006Fr 3  8D 01 60                     sta     PORTA
000072r 3               @not_full:
000072r 3  FA                           plx
000073r 3  68                           pla
000074r 3  40                           rti
000075r 3               
000075r 3               .include "appleiimonitor-serial.s"
000075r 4               .segment "APPLE2_MON"
000000r 4               ; Port of Apple II monitor to Apple 1
000000r 4               ;
000000r 4               ; Original port by Winston Gayler with additional adaptations by
000000r 4               ; Wendell Sander. Source code reverse-engineered and ported to CA65
000000r 4               ; assembler by Jeff Tranter <tranter@pobox.com>.
000000r 4               ; Ported to Ben Eater's hardware configuration by reddit user
000000r 4               ; @The8BitEnthusiast
000000r 4               
000000r 4               ; Define to get Ben Eater's hardware version, otherwise generates original Apple II
000000r 4               ; code.
000000r 4               ; EATER = 1
000000r 4               
000000r 4               ; Definitions for 16C550 UART
000000r 4               ; ACE_DATA  = $A000   ; Serial data register
000000r 4               ; ACE_LSR   = $A005   ; Line status register
000000r 4               
000000r 4               ; Definitions for BE6502 65C51 UART
000000r 4               ; ACIA_DATA       = $5000
000000r 4               ; ACIA_STATUS     = $5001
000000r 4               
000000r 4               ;CHRIN = $8001           ; temporary definition
000000r 4               ;DELAY = $01          ; serial transmission delay - set to 1 when running with slow clock
000000r 4                                    ; or when debugging with emulator, or $FF when running with 1Mhz clock
000000r 4               
000000r 4               
000000r 4               ; Define if you want the Apple 1 Woz Monitor included in the build. Only
000000r 4               ; works if start address is $F400.
000000r 4               ; --> @The8BitEnthusiast: disabled since Ben's build includes its own version
000000r 4               ;WOZMON = 1
000000r 4               
000000r 4               ; Macro to define a string in ASCII with high bit set on each character.
000000r 4               .macro Str Arg
000000r 4                   .repeat .strlen(Arg), I
000000r 4                   .byte   .strat(Arg, I) | $80
000000r 4                   .endrep
000000r 4               .endmacro
000000r 4               
000000r 4               ; ***********************
000000r 4               ; *                     *
000000r 4               ; * APPLE-II            *
000000r 4               ; * MINI-ASSEMBLER      *
000000r 4               ; *                     *
000000r 4               ; * COPYRIGHT 1977 BY   *
000000r 4               ; * APPLE COMPUTER INC. *
000000r 4               ; *                     *
000000r 4               ; * ALL RIGHTS RESERVED *
000000r 4               ; *                     *
000000r 4               ; * S. WOZNIAK          *
000000r 4               ; * A. BAUM             *
000000r 4               ; ***********************
000000r 4               ; TITLE "APPLE-II MINI-ASSEMBLER"
000000r 4               FORMAT = $2E
000000r 4               LENGTH = $2F
000000r 4               A2_MODE =   $31
000000r 4               PROMPT = $33
000000r 4               A2_YSAV =   $34
000000r 4               A2_L =      $35
000000r 4               PCL =    $3A
000000r 4               PCH =    $3B
000000r 4               A1H =    $3D
000000r 4               A2L =    $3E
000000r 4               A2H =    $3F
000000r 4               A4L =    $42
000000r 4               A4H =    $43
000000r 4               FMT =    $44
000000r 4               A2_IN =     $200
000000r 4               ; INSDS2 = $F88E
000000r 4               ; INSTDSP = $F8D0
000000r 4               ; PRBL2 =  $F94A
000000r 4               ; PCADJ =  $F953
000000r 4               ; CHAR1 =  $F9B4
000000r 4               ; CHAR2 =  $F9BA
000000r 4               ; MNEML =  $F9C0
000000r 4               ; MNEMR =  $FA00
000000r 4               CURSUP = $FC1A
000000r 4               ; GETLNZ = $FD67
000000r 4               ; COUT =   $FDED
000000r 4               ; BL1 =    $FE00
000000r 4               ; A1PCLP = $FE78
000000r 4               ; BELL =   $FF3A
000000r 4               ; GETNUM = $FFA7
000000r 4               ; TOSUB =  $FFBE
000000r 4               ; ZMODE =  $FFC7
000000r 4               ; CHRTBL = $FFCC
000000r 4               
000000r 4               .ifdef EATER
000000r 4               ;  .org $3500
000000r 4               ;  .org $6500
000000r 4               ;  .org $7500
000000r 4               ;  .org $B500
000000r 4               ;  .org $F400
000000r 4                  .org $C400
00C400  4               .else
00C400  4                 .org $F500
00C400  4               .endif
00C400  4               
00C400  4                 .export MON
00C400  4                 .export REL
00C400  4               
00C400  4  E9 81        REL: SBC #$81 ; IS FMT COMPATIBLE
00C402  4  4A             LSR ; WITH RELATIVE MODE?
00C403  4  D0 14          BNE ERR3 ; NO.
00C405  4  A4 3F          LDY A2H
00C407  4  A6 3E          LDX A2L ; DOUBLE DECREMENT
00C409  4  D0 01          BNE REL2
00C40B  4  88             DEY
00C40C  4  CA           REL2: DEX
00C40D  4  8A             TXA
00C40E  4  18             CLC
00C40F  4  E5 3A          SBC PCL ; FORM ADDR-PC-2
00C411  4  85 3E          STA A2L
00C413  4  10 01          BPL REL3
00C415  4  C8             INY
00C416  4  98           REL3: TYA
00C417  4  E5 3B          SBC PCH
00C419  4  D0 6B        ERR3: BNE ERR ; ERROR IF >1-BYTE BRANCH
00C41B  4  A4 2F        FINDOP: LDY LENGTH
00C41D  4  B9 3D 00     FNDOP2: LDA A1H,Y ; MOVE INST TO (PC)
00C420  4  91 3A          STA (PCL),Y
00C422  4  88             DEY
00C423  4  10 F8          BPL FNDOP2
00C425  4  EA             NOP
00C426  4  EA             NOP
00C427  4  EA             NOP
00C428  4  EA             NOP
00C429  4  EA             NOP
00C42A  4  EA             NOP
00C42B  4               ; JSR CURSUP
00C42B  4               ; JSR CURSUP ; RESTORE CURSOR
00C42B  4  20 D3 C7       JSR INSTDSP ; TYPE FORMATTED LINE
00C42E  4  20 56 C8       JSR PCADJ ; UPDATE PC
00C431  4  84 3B          STY PCH
00C433  4  85 3A          STA PCL
00C435  4  4C 95 C4       JMP NXTLINE ; GET NEXT LINE
00C438  4  20 BE CE     FAKEMON3: JSR TOSUB ; GO TO DELIM HANDLER
00C43B  4  A4 34          LDY A2_YSAV ; RESTORE Y-INDEX
00C43D  4  20 A7 CE     FAKEMON: JSR GETNUM ; READ PARAM
00C440  4  84 34          STY A2_YSAV ; SAVE Y-INDEX
00C442  4  A0 17          LDY #$17 ; INIT DELIMITER INDEX
00C444  4  88           FAKEMON2: DEY ; CHECK NEXT DELIM
00C445  4  30 4B          BMI RESETZ ; ERR IF UNRECOGNIZED DELIM
00C447  4  D9 CC CE       CMP CHRTBL,Y ; COMPARE WITH DELIM TABLE
00C44A  4  D0 F8          BNE FAKEMON2 ; NO MATCH
00C44C  4  C0 15          CPY #$15 ; MATCH, IS IT CR
00C44E  4  D0 E8          BNE FAKEMON3 ; NO, HANDLE IT IN MONITOR
00C450  4  A5 31          LDA A2_MODE
00C452  4  A0 00          LDY #$0
00C454  4  C6 34          DEC A2_YSAV
00C456  4  20 00 CD       JSR BL1 ; HANDLE CR OUTSIDE MONITOR
00C459  4  4C 95 C4       JMP NXTLINE
00C45C  4  A5 3D        TRYNEXT: LDA A1H ; GET TRIAL OPCODE
00C45E  4               .ifdef EATER
00C45E  4  20 6B C5       JSR L6 ; GET FMT+LENGTH FOR OPCODE
00C461  4               .else
00C461  4                 JSR INSDS2 ; GET FMT+LENGTH FOR OPCODE
00C461  4               .endif
00C461  4  AA             TAX
00C462  4  BD 03 C9       LDA MNEMR,X ; GET LOWER MNEMONIC BYTE
00C465  4  C5 42          CMP A4L ; MATCH?
00C467  4  D0 13          BNE NEXTOP ; NO, TRY NEXT OPCODE.
00C469  4  BD C3 C8       LDA MNEML,X ; GET UPPER MNEMONIC BYTE
00C46C  4  C5 43          CMP A4H ; MATCH?
00C46E  4  D0 0C          BNE NEXTOP ; NO, TRY NEXT OPCODE
00C470  4  A5 44          LDA FMT
00C472  4  A4 2E          LDY FORMAT ; GET TRIAL FORMAT
00C474  4  C0 9D          CPY #$9D ; TRIAL FORMAT RELATIVE?
00C476  4  F0 88          BEQ REL ; YES.
00C478  4  C5 2E        NREL: CMP FORMAT ; SAME FORMAT?
00C47A  4  F0 9F          BEQ FINDOP ; YES.
00C47C  4  C6 3D        NEXTOP: DEC A1H ; NO, TRY NEXT OPCODE
00C47E  4  D0 DC          BNE TRYNEXT
00C480  4  E6 44          INC FMT ; NO MORE, TRY WITH LEN=2
00C482  4  C6 35          DEC A2_L ; WAS L=2 ALREADY?
00C484  4  F0 D6          BEQ TRYNEXT ; NO.
00C486  4  A4 34        ERR: LDY A2_YSAV ; YES, UNRECOGNIZED INST.
00C488  4  98           ERR2: TYA
00C489  4  AA             TAX
00C48A  4  20 4D C8       JSR PRBL2 ; PRINT ^ UNDER LAST READ
00C48D  4  A9 DE          LDA #$DE ; CHAR TO INDICATE ERROR
00C48F  4  20 ED CC       JSR COUT ; POSITION.
00C492  4  20 3A CE     RESETZ: JSR BELL
00C495  4  A9 A1        NXTLINE: LDA #$A1 ; '!'
00C497  4  85 33          STA PROMPT ; INITIALIZE PROMPT
00C499  4  20 67 CC       JSR GETLNZ ; GET LINE.
00C49C  4  20 C7 CE       JSR ZMODE ; INIT SCREEN STUFF
00C49F  4  AD 00 02       LDA A2_IN ; GET CHAR
00C4A2  4  C9 A0          CMP #$A0 ; ASCII BLANK?
00C4A4  4  F0 13          BEQ SPACE ; YES
00C4A6  4  C8             INY
00C4A7  4  C9 A4          CMP #$A4 ; ASCII '$' IN COL 1?
00C4A9  4  F0 92          BEQ FAKEMON ; YES, SIMULATE MONITOR
00C4AB  4  88             DEY ; NO, BACKUP A CHAR
00C4AC  4  20 A7 CE       JSR GETNUM ; GET A NUMBER
00C4AF  4  C9 93          CMP #$93 ; ':' TERMINATOR?
00C4B1  4  D0 D5        ERR4: BNE ERR2 ; NO, ERR.
00C4B3  4  8A             TXA
00C4B4  4  F0 D2          BEQ ERR2 ; NO ADR PRECEDING COLON.
00C4B6  4  20 78 CD       JSR A1PCLP ; MOVE ADR TO PCL, PCH.
00C4B9  4  A9 03        SPACE: LDA #$3 ; COUNT OF CHARS IN MNEMONIC
00C4BB  4  85 3D          STA A1H
00C4BD  4  20 34 C5     NXTMN: JSR GETNSP ; GET FIRST MNEM CHAR.
00C4C0  4  0A           NXTM: ASL A
00C4C1  4  E9 BE          SBC #$BE ; SUBTRACT OFFSET
00C4C3  4  C9 C2          CMP #$C2 ; LEGAL CHAR?
00C4C5  4  90 C1          BCC ERR2 ; NO.
00C4C7  4  0A             ASL A ; COMPRESS-LEFT JUSTIFY
00C4C8  4  0A             ASL A
00C4C9  4  A2 04          LDX #$4
00C4CB  4  0A           NXTM2: ASL A ; DO 5 TRIPLE WORD SHIFTS
00C4CC  4  26 42          ROL A4L
00C4CE  4  26 43          ROL A4H
00C4D0  4  CA             DEX
00C4D1  4  10 F8          BPL NXTM2
00C4D3  4  C6 3D          DEC A1H ; DONE WITH 3 CHARS?
00C4D5  4  F0 F4          BEQ NXTM2 ; YES, BUT DO 1 MORE SHIFT
00C4D7  4  10 E4          BPL NXTMN ; NO
00C4D9  4  A2 05        FORM1: LDX #$5 ; 5 CHARS IN ADDR MODE
00C4DB  4  20 34 C5     FORM2: JSR GETNSP ; GET FIRST CHAR OF ADDR
00C4DE  4  84 34          STY A2_YSAV
00C4E0  4  DD B7 C8       CMP CHAR1,X ; FIRST CHAR MATCH PATTERN?
00C4E3  4  D0 13          BNE FORM3 ; NO
00C4E5  4  20 34 C5       JSR GETNSP ; YES, GET SECOND CHAR
00C4E8  4  DD BD C8       CMP CHAR2,X ; MATCHES SECOND HALF?
00C4EB  4  F0 0D          BEQ FORM5 ; YES.
00C4ED  4  BD BD C8       LDA CHAR2,X ; NO, IS SECOND HALF ZERO?
00C4F0  4  F0 07          BEQ FORM4 ; YES.
00C4F2  4  C9 A4          CMP #$A4 ; NO,SECOND HALF OPTIONAL?
00C4F4  4  F0 03          BEQ FORM4 ; YES.
00C4F6  4  A4 34          LDY A2_YSAV
00C4F8  4  18           FORM3: CLC ; CLEAR BIT-NO MATCH
00C4F9  4  88           FORM4: DEY ; BACK UP 1 CHAR
00C4FA  4  26 44        FORM5: ROL FMT ; FORM FORMAT BYTE
00C4FC  4  E0 03          CPX #$3 ; TIME TO CHECK FOR ADDR.
00C4FE  4  D0 0D          BNE FORM7 ; NO
00C500  4  20 A7 CE       JSR GETNUM ; YES
00C503  4  A5 3F          LDA A2H
00C505  4  F0 01          BEQ FORM6 ; HIGH-ORDER BYTE ZERO
00C507  4  E8             INX ; NO, INCR FOR 2-BYTE
00C508  4  86 35        FORM6: STX A2_L ; STORE LENGTH
00C50A  4  A2 03          LDX #$3 ; RELOAD FORMAT INDEX
00C50C  4  88             DEY ; BACKUP A CHAR
00C50D  4  86 3D        FORM7: STX A1H ; SAVE INDEX
00C50F  4  CA             DEX ; DONE WITH FORMAT CHECK?
00C510  4  10 C9          BPL FORM2 ; NO.
00C512  4  A5 44          LDA FMT ; YES, PUT LENGTH
00C514  4  0A             ASL A ; IN LOW BITS
00C515  4  0A             ASL A
00C516  4  05 35          ORA A2_L
00C518  4  C9 20          CMP #$20
00C51A  4  B0 06          BCS FORM8 ; ADD "$" IF NONZERO LENGTH
00C51C  4  A6 35          LDX A2_L ; AND DON'T ALREADY HAVE IT
00C51E  4  F0 02          BEQ FORM8
00C520  4  09 80          ORA #$80
00C522  4  85 44        FORM8: STA FMT
00C524  4  84 34          STY A2_YSAV
00C526  4  B9 00 02       LDA A2_IN,Y ; GET NEXT NONBLANK
00C529  4  C9 BB          CMP #$BB ; '' START OF COMMENT?
00C52B  4  F0 04          BEQ FORM9 ; YES
00C52D  4  C9 8D          CMP #$8D ; CARRIAGE RETURN?
00C52F  4  D0 80          BNE ERR4 ; NO, ERR.
00C531  4  4C 5C C4     FORM9: JMP TRYNEXT
00C534  4  B9 00 02     GETNSP: LDA A2_IN,Y
00C537  4  C8             INY
00C538  4  C9 A0          CMP #$A0 ; GET NEXT NON BLANK CHAR
00C53A  4  F0 F8          BEQ GETNSP
00C53C  4  60             RTS
00C53D  4               
00C53D  4               ; Add filler bytes so that the Mini-Assembler starts at the documented
00C53D  4               ; entry point at address $F666
00C53D  4  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C541  4  FF FF FF FF  
00C545  4  FF FF FF FF  
00C54D  4  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C551  4  FF FF FF FF  
00C555  4  FF FF FF FF  
00C55D  4  FF           .byte $FF
00C55E  4               
00C55E  4               .ifndef EATER
00C55E  4               
00C55E  4               .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C55E  4               
00C55E  4               MINIASM:  JMP   RESETZ
00C55E  4               .endif
00C55E  4               
00C55E  4               ; Apple 1 specific code
00C55E  4               .ifdef EATER
00C55E  4  A1 3A          LDA   ($3A,X)
00C560  4  A8             TAY
00C561  4  4A             LSR
00C562  4  90 06          BCC   L0+1
00C564  4  4A             LSR
00C565  4  09             .BYTE $09 ; ORA #
00C566  4  4C 92 C4     MINIASM:  JMP   RESETZ
00C569  4  A1 3A        L0: LDA ($3A,X)
00C56B  4  A8           L6: TAY
00C56C  4  4A             LSR A
00C56D  4  90 06          BCC L1
00C56F  4  4A             LSR A
00C570  4  09 80          ORA #$80
00C572  4  4C 96 C7       JMP   INSDS2
00C575  4  4C 9E C7     L1: JMP   IEVEN
00C578  4               L8:
00C578  4                 ;LDA   #$7F ; Initialize 6820
00C578  4                 ;STA   $D012
00C578  4                 ;LDX   #$A7
00C578  4                 ;STX   $D011
00C578  4                 ;STX   $D013
00C578  4                 ;LDX   #$8B ; Initialize Serial Card 300 Baud
00C578  4                 ;STX   $D004
00C578  4                 ;LDX   #$96
00C578  4                 ;STX   $D005
00C578  4  60             RTS
00C579  4               L3: ; BIT   $D012 ; Character Out
00C579  4  29 7F          AND     #$7F            ; Clear high bit
00C57B  4  8D 00 50       STA     ACIA_DATA       ; Output character.
00C57E  4  48             PHA                     ; Save A.
00C57F  4  A9 01          LDA     #DELAY            ; Initialize delay loop.
00C581  4               @TXDELAY:
00C581  4  3A             DEC                     ; Decrement A.
00C582  4  D0 FD          BNE     @TXDELAY         ; Until A gets to 0.
00C584  4  68             PLA                     ; Restore A.
00C585  4               
00C585  4               ; L2: BMI   L3
00C585  4               ;  STA   $D012
00C585  4  60             RTS
00C586  4               L7:
00C586  4  09 80          ORA   #$80 ; Set high bit
00C588  4  C9 9B          CMP   #$9B ; Use Esc for line kill
00C58A  4  D0 02          BNE   L4
00C58C  4  A9 98          LDA   #$98
00C58E  4  C9 88        L4: CMP   #$88 ; Use Control h for Backspace
00C590  4  D0 02          BNE   L5
00C592  4  A9 DF          LDA   #$DF ; Underscore out
00C594  4               .ifdef WOZMON
00C594  4                 CMP #$91   ; Control-Q typed?
00C594  4                 BNE L5     ; If so, jump to WozMon
00C594  4                 JMP A2_RESET
00C594  4               .endif
00C594  4  60           L5:  RTS
00C595  4               .ifdef WOZMON
00C595  4                 NOP
00C595  4                 NOP
00C595  4                 NOP
00C595  4               .endif
00C595  4               
00C595  4               ; 346 filler bytes in place of SWEET16 code
00C595  4               
00C595  4               .ifndef WOZMON
00C595  4  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C599  4  00 00 00 00  
00C59D  4  00 00        
00C59F  4  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C5A3  4  00 00 00 00  
00C5A7  4  00 00        
00C5A9  4  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C5AD  4  00 00 00 00  
00C5B1  4  00 00        
00C5B3  4  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C5B7  4  00 00 00 00  
00C5BB  4  00 00        
00C5BD  4  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C5C1  4  00 00 00 00  
00C5C5  4  00 00        
00C5C7  4  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C5CB  4  00 00 00 00  
00C5CF  4  00 00        
00C5D1  4  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C5D5  4  00 00 00 00  
00C5D9  4  00 00        
00C5DB  4  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C5DF  4  00 00 00 00  
00C5E3  4  00 00        
00C5E5  4  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C5E9  4  00 00 00 00  
00C5ED  4  00 00        
00C5EF  4  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C5F3  4  00 00 00 00  
00C5F7  4  00 00        
00C5F9  4               
00C5F9  4  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C5FD  4  00 00 00 00  
00C601  4  00 00        
00C603  4  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C607  4  00 00 00 00  
00C60B  4  00 00        
00C60D  4  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C611  4  00 00 00 00  
00C615  4  00 00        
00C617  4  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C61B  4  00 00 00 00  
00C61F  4  00 00        
00C621  4  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C625  4  00 00 00 00  
00C629  4  00 00        
00C62B  4  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C62F  4  00 00 00 00  
00C633  4  00 00        
00C635  4  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C639  4  00 00 00 00  
00C63D  4  00 00        
00C63F  4  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C643  4  00 00 00 00  
00C647  4  00 00        
00C649  4  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C64D  4  00 00 00 00  
00C651  4  00 00        
00C653  4  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C657  4  00 00 00 00  
00C65B  4  00 00        
00C65D  4               
00C65D  4  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C661  4  00 00 00 00  
00C665  4  00 00        
00C667  4  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C66B  4  00 00 00 00  
00C66F  4  00 00        
00C671  4  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C675  4  00 00 00 00  
00C679  4  00 00        
00C67B  4  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C67F  4  00 00 00 00  
00C683  4  00 00        
00C685  4  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C689  4  00 00 00 00  
00C68D  4  00 00        
00C68F  4  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C693  4  00 00 00 00  
00C697  4  00 00        
00C699  4  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C69D  4  00 00 00 00  
00C6A1  4  00 00        
00C6A3  4  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C6A7  4  00 00 00 00  
00C6AB  4  00 00        
00C6AD  4  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C6B1  4  00 00 00 00  
00C6B5  4  00 00        
00C6B7  4  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C6BB  4  00 00 00 00  
00C6BF  4  00 00        
00C6C1  4               
00C6C1  4  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C6C5  4  00 00 00 00  
00C6C9  4  00 00        
00C6CB  4  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C6CF  4  00 00 00 00  
00C6D3  4  00 00        
00C6D5  4  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C6D9  4  00 00 00 00  
00C6DD  4  00 00        
00C6DF  4  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C6E3  4  00 00 00 00  
00C6E7  4  00 00        
00C6E9  4  00 00 00 00  .byte 0,0,0,0,0,0
00C6ED  4  00 00        
00C6EF  4               
00C6EF  4               ; The8BitEnthusiast: additional bytes
00C6EF  4               ; to make sure the monitor start address
00C6EF  4               ; remains where it should after Ben Eater's
00C6EF  4               ; hardware conversion
00C6EF  4  00 00 00 00    .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
00C6F3  4  00 00 00 00  
00C6F7  4  00 00 00 00  
00C703  4               
00C703  4               
00C703  4               
00C703  4               .else
00C703  4               
00C703  4               ; 336 filler bytes in place of SWEET16 code
00C703  4               
00C703  4               .byte 0,0,0,0,0,0,0,0,0,0
00C703  4               .byte 0,0,0,0,0,0,0,0,0,0
00C703  4               .byte 0,0,0,0,0,0,0,0,0,0
00C703  4               .byte 0,0,0,0,0,0,0,0,0,0
00C703  4               .byte 0,0,0,0,0,0,0,0,0,0
00C703  4               .byte 0,0,0,0,0,0,0,0,0,0
00C703  4               .byte 0,0,0,0,0,0,0,0,0,0
00C703  4               .byte 0,0,0,0,0,0,0,0,0,0
00C703  4               .byte 0,0,0,0,0,0,0,0,0,0
00C703  4               .byte 0,0,0,0,0,0,0,0,0,0
00C703  4               
00C703  4               .byte 0,0,0,0,0,0,0,0,0,0
00C703  4               .byte 0,0,0,0,0,0,0,0,0,0
00C703  4               .byte 0,0,0,0,0,0,0,0,0,0
00C703  4               .byte 0,0,0,0,0,0,0,0,0,0
00C703  4               .byte 0,0,0,0,0,0,0,0,0,0
00C703  4               .byte 0,0,0,0,0,0,0,0,0,0
00C703  4               .byte 0,0,0,0,0,0,0,0,0,0
00C703  4               .byte 0,0,0,0,0,0,0,0,0,0
00C703  4               .byte 0,0,0,0,0,0,0,0,0,0
00C703  4               .byte 0,0,0,0,0,0,0,0,0,0
00C703  4               
00C703  4               .byte 0,0,0,0,0,0,0,0,0,0
00C703  4               .byte 0,0,0,0,0,0,0,0,0,0
00C703  4               .byte 0,0,0,0,0,0,0,0,0,0
00C703  4               .byte 0,0,0,0,0,0,0,0,0,0
00C703  4               .byte 0,0,0,0,0,0,0,0,0,0
00C703  4               .byte 0,0,0,0,0,0,0,0,0,0
00C703  4               .byte 0,0,0,0,0,0,0,0,0,0
00C703  4               .byte 0,0,0,0,0,0,0,0,0,0
00C703  4               .byte 0,0,0,0,0,0,0,0,0,0
00C703  4               .byte 0,0,0,0,0,0,0,0,0,0
00C703  4               
00C703  4               .byte 0,0,0,0,0,0,0,0,0,0
00C703  4               .byte 0,0,0,0,0,0,0,0,0,0
00C703  4               .byte 0,0,0,0,0,0,0,0,0,0
00C703  4               .byte 0,0,0,0,0,0
00C703  4               
00C703  4               .endif
00C703  4               
00C703  4               .else
00C703  4               
00C703  4               ; Add filler bytes up to documented SWEET16 entry point at
00C703  4               ; address $X689
00C703  4               .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
00C703  4               .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
00C703  4               
00C703  4               ; ***********************
00C703  4               ; *                     *
00C703  4               ; * APPLE-II PSEUDO     *
00C703  4               ; * MACHINE INTERPRETER *
00C703  4               ; *                     *
00C703  4               ; * COPYRIGHT 1977      *
00C703  4               ; * APPLE COMPUTER INC  *
00C703  4               ; *                     *
00C703  4               ; * ALL RIGHTS RESERVED *
00C703  4               ; * S. WOZNIAK          *
00C703  4               ; *                     *
00C703  4               ; ***********************
00C703  4               ; TITLE "SWEET16 INTERPRETER"
00C703  4               R0L = $0
00C703  4               R0H = $1
00C703  4               R14H = $1D
00C703  4               R15L = $1E
00C703  4               R15H = $1F
00C703  4               SW16PAG = $F7
00C703  4               ; SAVE = $FF4A
00C703  4               ; RESTORE = $FF3F
00C703  4               ;  .ORG $F689
00C703  4               SW16: JSR A2_SAVE ; PRESERVE 6502 REG CONTENTS
00C703  4                 PLA
00C703  4                 STA R15L ; INIT SWEET16 PC
00C703  4                 PLA ; FROM RETURN
00C703  4                 STA R15H ; ADDRESS
00C703  4               SW16B: JSR SW16C ; INTERPRET AND EXECUTE
00C703  4                 JMP SW16B ; ONE SWEET16 INSTR.
00C703  4               SW16C: INC R15L
00C703  4                 BNE SW16D ; INCR SWEET16 PC FOR FETCH
00C703  4                 INC R15H
00C703  4               SW16D: LDA #SW16PAG
00C703  4                 PHA ; PUSH ON STACK FOR RTS
00C703  4                 LDY #$0
00C703  4                 LDA (R15L),Y ; FETCH INSTR
00C703  4                 AND #$F ; MASK REG SPECIFICATION
00C703  4                 ASL A ; DOUBLE FOR TWO BYTE REGISTERS
00C703  4                 TAX ; TO X REG FOR INDEXING
00C703  4                 LSR A
00C703  4                 EOR (R15L),Y ; NOW HAVE OPCODE
00C703  4                 BEQ TOBR ; IF ZERO THEN NON-REG OP
00C703  4                 STX R14H ; INDICATE'PRIOR RESULT REG'
00C703  4                 LSR A
00C703  4                 LSR A ; OPCODE*2 TO LSB'S
00C703  4                 LSR A
00C703  4                 TAY ; TO Y REG FOR INDEXING
00C703  4                 LDA OPTBL-2,Y ; LOW ORDER ADR BYTE
00C703  4                 PHA ; ONTO STACK
00C703  4                 RTS ; GOTO REG-OP ROUTINE
00C703  4               TOBR: INC R15L
00C703  4                 BNE TOBR2 ; INCR PC
00C703  4                 INC R15H
00C703  4               TOBR2: LDA BRTBL,X ; LOW ORDER ADR BYTE
00C703  4                 PHA ; ONTO STACK FOR NON-REG OP
00C703  4                 LDA R14H ; 'PRIOR RESULT REG' INDEX
00C703  4                 LSR A ; PREPARE CARRY FOR BC, BNC.
00C703  4                 RTS ; GOTO NON-REG OP ROUTINE
00C703  4               RTNZ: PLA ; POP RETURN ADDRESS
00C703  4                 PLA
00C703  4                 JSR A2_RESTORE ; RESTORE 6502 REG CONTENTS
00C703  4                 JMP (R15L) ; RETURN TO 6502 CODE VIA PC
00C703  4               SETZ: LDA (R15L),Y ; HIGH-ORDER BYTE OF CONSTANT
00C703  4                 STA R0H,X
00C703  4                 DEY
00C703  4                 LDA (R15L),Y ; LOW-ORDER BYTE OF CONSTANT
00C703  4                 STA R0L,X
00C703  4                 TYA ; Y-REG CONTAINS 1
00C703  4                 SEC
00C703  4                 ADC R15L ; ADD 2 TO PC
00C703  4                 STA R15L
00C703  4                 BCC SET2
00C703  4                 INC R15H
00C703  4               SET2: RTS
00C703  4               OPTBL: .BYTE <SET-1 ; 1X
00C703  4               BRTBL: .BYTE <RTN-1 ; 0
00C703  4                 .BYTE <LD-1 ; 2X
00C703  4                 .BYTE <BR-1 ; 1
00C703  4                 .BYTE <ST-1 ; 3X
00C703  4                 .BYTE <BNC-1 ; 2
00C703  4                 .BYTE <LDAT-1 ; 4X
00C703  4                 .BYTE <BC-1 ; 3
00C703  4                 .BYTE <STAT-1 ; 5X
00C703  4                 .BYTE <BP-1 ; 4
00C703  4                 .BYTE <LDDAT-1 ; 6X
00C703  4                 .BYTE <BM-1 ; 5
00C703  4                 .BYTE <STDAT-1 ; 7X
00C703  4                 .BYTE <BZ-1 ; 6
00C703  4                 .BYTE <POP-1 ; 8X
00C703  4                 .BYTE <BNZ-1 ; 7
00C703  4                 .BYTE <STPAT-1 ; 9X
00C703  4                 .BYTE <BM1-1 ; 8
00C703  4                 .BYTE <ADD-1 ; AX
00C703  4                 .BYTE <BNM1-1 ; 9
00C703  4                 .BYTE <SUB-1 ; BX
00C703  4                 .BYTE <BK-1 ; A
00C703  4                 .BYTE <POPD-1 ; CX
00C703  4                 .BYTE <RS-1 ; B
00C703  4                 .BYTE <CPR-1 ; DX
00C703  4                 .BYTE <BS-1 ; C
00C703  4                 .BYTE <INR-1 ; EX
00C703  4                 .BYTE <NUL-1 ; D
00C703  4                 .BYTE <DCR-1 ; FX
00C703  4                 .BYTE <NUL-1 ; E
00C703  4                 .BYTE <NUL-1 ; UNUSED
00C703  4                 .BYTE <NUL-1 ; F
00C703  4               SET: BPL SETZ ; ALWAYS TAKEN
00C703  4               LD: LDA R0L,X
00C703  4               BK = LD+1
00C703  4                 STA R0L
00C703  4                 LDA R0H,X ; MOVE RX TO R0
00C703  4                 STA R0H
00C703  4                 RTS
00C703  4               ST: LDA R0L
00C703  4                 STA R0L,X ; MOVE R0 TO RX
00C703  4                 LDA R0H
00C703  4                 STA R0H,X
00C703  4                 RTS
00C703  4               STAT: LDA R0L
00C703  4               STAT2: STA (R0L,X) ; STORE BYTE INDIRECT
00C703  4                 LDY #$0
00C703  4               STAT3: STY R14H ; INDICATE R0 IS RESULT NEG
00C703  4               INR: INC R0L,X
00C703  4                 BNE INR2 ; INCR RX
00C703  4                 INC R0H,X
00C703  4               INR2: RTS
00C703  4               LDAT: LDA (R0L,X) ; LOAD INDIRECT (RX)
00C703  4                 STA R0L ; TO R0
00C703  4                 LDY #$0
00C703  4                 STY R0H ; ZERO HIGH-ORDER R0 BYTE
00C703  4                 BEQ STAT3 ; ALWAYS TAKEN
00C703  4               POP: LDY #$0 ; HIGH ORDER BYTE = 0
00C703  4                 BEQ POP2 ; ALWAYS TAKEN
00C703  4               POPD: JSR DCR ; DECR RX
00C703  4                 LDA (R0L,X) ; POP HIGH ORDER BYTE @RX
00C703  4                 TAY ; SAVE IN Y-REG
00C703  4               POP2: JSR DCR ; DECR RX
00C703  4                 LDA (R0L,X) ; LOW-ORDER BYTE
00C703  4                 STA R0L ; TO R0
00C703  4                 STY R0H
00C703  4               POP3: LDY #$0 ; INDICATE R0 AS LAST RESULT REG
00C703  4                 STY R14H
00C703  4                 RTS
00C703  4               LDDAT: JSR LDAT ; LOW-ORDER BYTE TO R0, INCR RX
00C703  4                 LDA (R0L,X) ; HIGH-ORDER BYTE TO R0
00C703  4                 STA R0H
00C703  4                 JMP INR ; INCR RX
00C703  4               STDAT: JSR STAT ; STORE INDIRECT LOW-ORDER
00C703  4                 LDA R0H ; BYTE AND INCR RX. THEN
00C703  4                 STA (R0L,X) ; STORE HIGH-ORDER BYTE.
00C703  4                 JMP INR ; INCR RX AND RETURN
00C703  4               STPAT: JSR DCR ; DECR RX
00C703  4                 LDA R0L
00C703  4                 STA (R0L,X) ; STORE R0 LOW BYTE @RX
00C703  4                 JMP POP3 ; INDICATE R0 AS LAST RSLT REG
00C703  4               DCR: LDA R0L,X
00C703  4                 BNE DCR2 ; DECR RX
00C703  4                 DEC R0H,X
00C703  4               DCR2: DEC R0L,X
00C703  4                 RTS
00C703  4               SUB: LDY #$0 ; RESULT TO R0
00C703  4               CPR: SEC ; NOTE Y-REG = 13*2 FOR CPR
00C703  4                 LDA R0L
00C703  4                 SBC R0L,X
00C703  4                 STA R0L,Y ; R0-RX TO RY
00C703  4                 LDA R0H
00C703  4                 SBC R0H,X
00C703  4               SUB2: STA R0H,Y
00C703  4                 TYA ; LAST RESULT REG*2
00C703  4                 ADC #$0 ; CARRY TO LSB
00C703  4                 STA R14H
00C703  4                 RTS
00C703  4               ADD: LDA R0L
00C703  4                 ADC R0L,X
00C703  4                 STA R0L ; R0+RX TO R0
00C703  4                 LDA R0H
00C703  4                 ADC R0H,X
00C703  4                 LDY #$0 ; R0 FOR RESULT
00C703  4                 BEQ SUB2 ; FINISH ADD
00C703  4               BS: LDA R15L ; NOTE X-REG IS 12*2!
00C703  4                 JSR STAT2 ; PUSH LOW PC BYTE VIA R12
00C703  4                 LDA R15H
00C703  4                 JSR STAT2 ; PUSH HIGH-ORDER PC BYTE
00C703  4               BR: CLC
00C703  4               BNC: BCS BNC2 ; NO CARRY TEST
00C703  4               BR1: LDA (R15L),Y ; DISPLACEMENT BYTE
00C703  4                 BPL BR2
00C703  4                 DEY
00C703  4               BR2: ADC R15L ; ADD TO PC
00C703  4                 STA R15L
00C703  4                 TYA
00C703  4                 ADC R15H
00C703  4                 STA R15H
00C703  4               BNC2: RTS
00C703  4               BC: BCS BR
00C703  4                 RTS
00C703  4               BP: ASL A ; DOUBLE RESULT-REG INDEX
00C703  4                 TAX ; TO X REG FOR INDEXING
00C703  4                 LDA R0H,X ; TEST FOR PLUS
00C703  4                 BPL BR1 ; BRANCH IF SO
00C703  4                 RTS
00C703  4               BM: ASL A ; DOUBLE RESULT-REG INDEX
00C703  4                 TAX
00C703  4                 LDA R0H,X ; TEST FOR MINUS
00C703  4                 BMI BR1
00C703  4                 RTS
00C703  4               BZ: ASL A ; DOUBLE RESULT-REG INDEX
00C703  4                 TAX
00C703  4                 LDA R0L,X ; TEST FOR ZERO
00C703  4                 ORA R0H,X ; (BOTH BYTES)
00C703  4                 BEQ BR1 ; BRANCH IF SO
00C703  4                 RTS
00C703  4               BNZ: ASL A ; DOUBLE RESULT-REG INDEX
00C703  4                 TAX
00C703  4                 LDA R0L,X ; TEST FOR NON-ZERO
00C703  4                 ORA R0H,X ; (BOTH BYTES)
00C703  4                 BNE BR1 ; BRANCH IF SO
00C703  4                 RTS
00C703  4               BM1: ASL A ; DOUBLE RESULT-REG INDEX
00C703  4                 TAX
00C703  4                 LDA R0L,X ; CHECK BOTH BYTES
00C703  4                 AND R0H,X ; FOR $FF (MINUS 1)
00C703  4                 EOR #$FF
00C703  4                 BEQ BR1 ; BRANCH IF SO
00C703  4                 RTS
00C703  4               BNM1: ASL A ; DOUBLE RESULT-REG INDEX
00C703  4                 TAX
00C703  4                 LDA R0L,X
00C703  4                 AND R0H,X ; CHECK BOTH BYTES FOR NO $FF
00C703  4                 EOR #$FF
00C703  4                 BNE BR1 ; BRANCH IF NOT MINUS 1
00C703  4               NUL: RTS
00C703  4               RS: LDX #$18 ; 12*2 FOR R12 AS STACK POINTER
00C703  4                 JSR DCR ; DECR STACK POINTER
00C703  4                 LDA (R0L,X) ; POP HIGH RETURN ADDRESS TO PC
00C703  4                 STA R15H
00C703  4                 JSR DCR ; SAME FOR LOW-ORDER BYTE
00C703  4                 LDA (R0L,X)
00C703  4                 STA R15L
00C703  4                RTS
00C703  4               RTN: JMP RTNZ
00C703  4               
00C703  4               ; Padding bytes to make System Monitor start at $F800
00C703  4                 .byte 0,0,0
00C703  4               
00C703  4               ; The8BitEnthusiast: additional 13 bytes
00C703  4                 .byte 0,0,0,0,0,0,0,0,0,0,0,0,0
00C703  4               
00C703  4               .endif
00C703  4               
00C703  4               ; ***************************
00C703  4               ; *                         *
00C703  4               ; * APPLE II                *
00C703  4               ; * SYSTEM MONITOR          *
00C703  4               ; *                         *
00C703  4               ; * COPYRIGHT 1977 BY       *
00C703  4               ; * APPLE COMPUTER, INC.    *
00C703  4               ; *                         *
00C703  4               ; * ALL RIGHTS RESERVED     *
00C703  4               ; *                         *
00C703  4               ; * S. WOZNIAK              *
00C703  4               ; * A. BAUM                 *
00C703  4               ; *                         *
00C703  4               ; ***************************
00C703  4               ; TITLE "APPLE II SYSTEM MONITOR"
00C703  4               LOC0 = $00
00C703  4               LOC1 = $01
00C703  4               WNDLFT = $20
00C703  4               WNDWDTH = $21
00C703  4               WNDTOP = $22
00C703  4               WNDBTM = $23
00C703  4               CH = $24
00C703  4               CV = $25
00C703  4               GBASL = $26
00C703  4               GBASH = $27
00C703  4               BASL = $28
00C703  4               BASH = $29
00C703  4               BAS2L = $2A
00C703  4               BAS2H = $2B
00C703  4               H2 = $2C
00C703  4               LMNEM = $2C
00C703  4               RTNL = $2C
00C703  4               V2 = $2D
00C703  4               RMNEM = $2D
00C703  4               RTNH = $2D
00C703  4               MASK = $2E
00C703  4               CHKSUM = $2E
00C703  4               ; FORMAT = $2E
00C703  4               LASTIN = $2F
00C703  4               ; LENGTH = $2F
00C703  4               A2_SIGN = $2F
00C703  4               COLOR = $30
00C703  4               ; MODE = $31
00C703  4               INVFLG = $32
00C703  4               ; PROMPT = $33
00C703  4               ; YSAV = $34
00C703  4               YSAV1 = $35
00C703  4               CSWL = $36
00C703  4               CSWH = $37
00C703  4               KSWL = $38
00C703  4               KSWH = $39
00C703  4               ; PCL = $3A
00C703  4               ; PCH = $3B
00C703  4               XQT = $3C
00C703  4               A1L = $3C
00C703  4               ; A1H = $3D
00C703  4               ;A2L = $3E
00C703  4               ;A2H = $3F
00C703  4               A3L = $40
00C703  4               A3H = $41
00C703  4               ;A4L = $42
00C703  4               ;A4H = $43
00C703  4               A5L = $44
00C703  4               A5H = $45
00C703  4               ACC = $45
00C703  4               XREG = $46
00C703  4               YREG = $47
00C703  4               STATUS = $48
00C703  4               SPNT = $49
00C703  4               RNDL = $4E
00C703  4               RNDH = $4F
00C703  4               ACL = $50
00C703  4               ACH = $51
00C703  4               XTNDL = $52
00C703  4               XTNDH = $53
00C703  4               AUXL = $54
00C703  4               AUXH = $55
00C703  4               PICK = $95
00C703  4               ; IN = $0200
00C703  4               USRADR = $03F8
00C703  4               NMI = $03FB
00C703  4               IRQLOC = $03FE
00C703  4               IOADR = $C000
00C703  4               KBD = $C000
00C703  4               KBDSTRB = $C010
00C703  4               TAPEOUT = $C020
00C703  4               SPKR = $C030
00C703  4               TXTCLR = $C050
00C703  4               TXTSET = $C051
00C703  4               MIXCLR = $C052
00C703  4               MIXSET = $C053
00C703  4               LOWSCR = $C054
00C703  4               HISCR = $C055
00C703  4               LORES = $C056
00C703  4               HIRES = $C057
00C703  4               TAPEIN = $C060
00C703  4               PADDL0 = $C064
00C703  4               PTRIG = $C070
00C703  4               BASIC = $E000
00C703  4               .ifdef EATER
00C703  4               BASIC2 = $E2B3
00C703  4               .else
00C703  4               BASIC2 = $E003
00C703  4               .endif
00C703  4               ; ORG $F800 ROM START ADDRESS
00C703  4  4A           PLOT: LSR ; Y-COORD/2
00C704  4  08             PHP ; SAVE LSB IN CARRY
00C705  4  20 4A C7       JSR GBASCALC ; CALC BASE ADR IN GBASL,H
00C708  4  28             PLP ; RESTORE LSB FROM CARRY
00C709  4  A9 0F          LDA #$0F ; MASK $0F IF EVEN
00C70B  4  90 02          BCC RTMASK
00C70D  4  69 E0          ADC #$E0 ; MASK $F0 IF ODD
00C70F  4  85 2E        RTMASK: STA MASK
00C711  4  B1 26        PLOT1: LDA (GBASL),Y ; DATA
00C713  4  45 30          EOR COLOR ; EOR COLOR
00C715  4  25 2E          AND MASK ; AND MASK
00C717  4  51 26          EOR (GBASL),Y ; XOR DATA
00C719  4  91 26          STA (GBASL),Y ; TO DATA
00C71B  4  60             RTS
00C71C  4  20 03 C7     HLINE: JSR PLOT ; PLOT SQUARE
00C71F  4  C4 2C        HLINE1: CPY H2 ; DONE?
00C721  4  B0 11          BCS RTS1 ; YES, RETURN
00C723  4  C8             INY ; NO, INCR INDEX (X-COORD)
00C724  4  20 11 C7       JSR PLOT1 ; PLOT NEXT SQUARE
00C727  4  90 F6          BCC HLINE1 ; ALWAYS TAKEN
00C729  4  69 01        VLINEZ: ADC #$01 ; NEXT Y-COORD
00C72B  4  48           VLINE: PHA ; SAVE ON STACK
00C72C  4  20 03 C7       JSR PLOT ; PLOT SQUARE
00C72F  4  68             PLA
00C730  4  C5 2D          CMP V2 ; DONE?
00C732  4  90 F5          BCC VLINEZ ; NO, LOOP
00C734  4  60           RTS1: RTS
00C735  4  A0 2F        CLRSCR: LDY #$2F ; MAX Y, FULL SCRN CLR
00C737  4  D0 02          BNE CLRSC2 ; ALWAYS TAKEN
00C739  4  A0 27        CLRTOP: LDY #$27 ; MAX Y, TOP SCREEN CLR
00C73B  4  84 2D        CLRSC2: STY V2 ; STORE AS BOTTOM COORD
00C73D  4               ; FOR VLINE CALLS
00C73D  4  A0 27          LDY #$27 ; RIGHTMOST X-COORD (COLUMN)
00C73F  4  A9 00        CLRSC3: LDA #$00 ; TOP COORD FOR VLINE CALLS
00C741  4  85 30          STA COLOR ; CLEAR COLOR (BLACK)
00C743  4  20 2B C7       JSR VLINE ; DRAW VLINE
00C746  4  88             DEY ; NEXT LEFTMOST X-COORD
00C747  4  10 F6          BPL CLRSC3 ; LOOP UNTIL DONE
00C749  4  60             RTS
00C74A  4  48           GBASCALC: PHA ; FOR INPUT 000DEFGH
00C74B  4  4A             LSR
00C74C  4  29 03          AND #$03
00C74E  4  09 04          ORA #$04 ; GENERATE GBASH=000001FG
00C750  4  85 27          STA GBASH
00C752  4  68             PLA ; AND GBASL=HDEDE000
00C753  4  29 18          AND #$18
00C755  4  90 02          BCC GBCALC
00C757  4  69 7F          ADC #$7F
00C759  4  85 26        GBCALC: STA GBASL
00C75B  4  0A             ASL A
00C75C  4  0A             ASL A
00C75D  4  05 26          ORA GBASL
00C75F  4  85 26          STA GBASL
00C761  4  60             RTS
00C762  4  A5 30        NXTCOL: LDA COLOR ; INCREMENT COLOR BY 3
00C764  4  18             CLC
00C765  4  69 03          ADC #$03
00C767  4  29 0F        SETCOL: AND #$0F ; SETS COLOR=17*A MOD 16
00C769  4  85 30          STA COLOR
00C76B  4  0A             ASL A ; BOTH HALF BYTES OF COLOR EQUAL
00C76C  4  0A             ASL A
00C76D  4  0A             ASL A
00C76E  4  0A             ASL A
00C76F  4  05 30          ORA COLOR
00C771  4  85 30          STA COLOR
00C773  4  60             RTS
00C774  4  4A           SCRN: LSR A ; READ SCREEN Y-COORD/2
00C775  4  08             PHP ; SAVE LSB (CARRY)
00C776  4  20 4A C7       JSR GBASCALC ; CALC BASE ADDRESS
00C779  4  B1 26          LDA (GBASL),Y ; GET BYTE
00C77B  4  28             PLP ; RESTORE LSB FROM CARRY
00C77C  4  90 04        SCRN2: BCC RTMSKZ ; IF EVEN, USE LO H
00C77E  4  4A             LSR A
00C77F  4  4A             LSR A
00C780  4  4A             LSR A ; SHIFT HIGH HALF BYTE DOWN
00C781  4  4A             LSR A
00C782  4  29 0F        RTMSKZ: AND #$0F ; MASK 4-BITS
00C784  4  60             RTS
00C785  4  A6 3A        INSDS1: LDX PCL ; PRINT PCL,H
00C787  4  A4 3B          LDY PCH
00C789  4  20 96 CC       JSR PRYX2
00C78C  4  20 4B C8       JSR PRBLNK ; FOLLOWED BY A BLANK
00C78F  4               .ifdef EATER
00C78F  4  4C 69 C5       JMP L0
00C792  4  EA             NOP
00C793  4  EA             NOP
00C794  4  EA             NOP
00C795  4  EA             NOP
00C796  4               INSDS2:
00C796  4               .else
00C796  4                 LDA (PCL,X) ; GET OP CODE
00C796  4               INSDS2: TAY
00C796  4                 LSR A ; EVEN/ODD TEST
00C796  4                 BCC IEVEN
00C796  4                 ROR ; BIT 1 TEST
00C796  4               .endif
00C796  4  B0 10          BCS ERR1 ; XXXXXX11 INVALID OP
00C798  4  C9 A2          CMP #$A2
00C79A  4  F0 0C          BEQ ERR1 ; OPCODE $89 INVALID
00C79C  4  29 87          AND #$87 ; MASK BITS
00C79E  4  4A           IEVEN: LSR A ; LSB INTO CARRY FOR L/R TEST
00C79F  4  AA             TAX
00C7A0  4  BD 65 C8       LDA FMT1,X ; GET FORMAT INDEX BYTE
00C7A3  4  20 7C C7       JSR SCRN2 ; R/L H-BYTE ON CARRY
00C7A6  4  D0 04          BNE GETFMT
00C7A8  4  A0 80        ERR1: LDY #$80 ; SUBSTITUTE $80 FOR INVALID OPS
00C7AA  4  A9 00          LDA #$00 ; SET PRINT FORMAT INDEX TO 0
00C7AC  4  AA           GETFMT: TAX
00C7AD  4  BD A9 C8       LDA FMT2,X ; INDEX INTO PRINT FORMAT TABLE
00C7B0  4  85 2E          STA FORMAT ; SAVE FOR ADR FIELD FORMATTING
00C7B2  4  29 03          AND #$03 ; MASK FOR 2-BIT LENGTH (P=1 BYTE, 1=2 BYTE, 2=3 BYTE)
00C7B4  4  85 2F          STA LENGTH
00C7B6  4  98             TYA ; OPCODE
00C7B7  4  29 8F          AND #$8F ; MASK FOR 1XXX1010 TEST
00C7B9  4  AA             TAX ; SAVE IT
00C7BA  4  98             TYA ; OPCODE TO A AGAIN
00C7BB  4  A0 03          LDY #$03
00C7BD  4  E0 8A          CPX #$8A
00C7BF  4  F0 0B          BEQ MNNDX3
00C7C1  4  4A           MNNDX1: LSR A
00C7C2  4  90 08          BCC MNNDX3 ; FORM INDEX INTO MNEMONIC TABLE
00C7C4  4  4A             LSR A
00C7C5  4  4A           MNNDX2: LSR A ; 1) 1XXX1010->00101XXX
00C7C6  4  09 20          ORA #$20 ; 2) XXXYYY01->00111XXX
00C7C8  4  88             DEY ; 3) XXXYYY10->00110XXX
00C7C9  4  D0 FA          BNE MNNDX2 ; 4) XXXYY100->00100XXX
00C7CB  4  C8             INY ; 5) XXXXX000->000XXXXX
00C7CC  4  88           MNNDX3: DEY
00C7CD  4  D0 F2          BNE MNNDX1
00C7CF  4  60             RTS
00C7D0  4  FF FF FF       .BYTE $FF,$FF,$FF
00C7D3  4  20 85 C7     INSTDSP: JSR INSDS1 ; GEN FMT, LEN BYTES
00C7D6  4  48             PHA ; SAVE MNEMONIC TABLE INDEX
00C7D7  4  B1 3A        PRNTOP: LDA (PCL),Y
00C7D9  4  20 DA CC       JSR A2_PRBYTE
00C7DC  4  A2 01          LDX #$01 ; PRINT 2 BLANKS
00C7DE  4  20 4D C8     PRNTBL: JSR PRBL2
00C7E1  4  C4 2F          CPY LENGTH ; PRINT INST (1-3 BYTES)
00C7E3  4  C8             INY ; IN A 12 CHR FIELD
00C7E4  4  90 F1          BCC PRNTOP
00C7E6  4  A2 03          LDX #$03 ; CHAR COUNT FOR MNEMONIC PRINT
00C7E8  4  C0 04          CPY #$04
00C7EA  4  90 F2          BCC PRNTBL
00C7EC  4  68             PLA ; RECOVER MNEMONIC INDEX
00C7ED  4  A8             TAY
00C7EE  4  B9 C3 C8       LDA MNEML,Y
00C7F1  4  85 2C          STA LMNEM ; FETCH 3-CHAR MNEMONIC
00C7F3  4  B9 03 C9       LDA MNEMR,Y ; (PACKED IN 2-BYTES)
00C7F6  4  85 2D          STA RMNEM
00C7F8  4  A9 00        PRMN1: LDA #$00
00C7FA  4  A0 05          LDY #$05
00C7FC  4  06 2D        PRMN2: ASL RMNEM ; SHIFT 5 BITS OF
00C7FE  4  26 2C          ROL LMNEM ; CHARACTER INTO A
00C800  4  2A             ROL ; (CLEARS CARRY)
00C801  4  88             DEY
00C802  4  D0 F8          BNE PRMN2
00C804  4  69 BF          ADC #$BF ; ADD "?" OFFSET
00C806  4  20 ED CC       JSR COUT ; OUTPUT A CHAR OF MNEM
00C809  4  CA             DEX
00C80A  4  D0 EC          BNE PRMN1
00C80C  4  20 4B C8       JSR PRBLNK ; OUTPUT 3 BLANKS
00C80F  4  A4 2F          LDY LENGTH
00C811  4  A2 06          LDX #$06 ; CNT FOR 6 FORMAT BITS
00C813  4  E0 03        PRADR1: CPX #$03
00C815  4  F0 1C          BEQ PRADR5 ; IF X=3 THEN ADDR.
00C817  4  06 2E        PRADR2: ASL FORMAT
00C819  4  90 0E          BCC PRADR3
00C81B  4  BD B6 C8       LDA CHAR1-1,X
00C81E  4  20 ED CC       JSR COUT
00C821  4  BD BC C8       LDA CHAR2-1,X
00C824  4  F0 03          BEQ PRADR3
00C826  4  20 ED CC       JSR COUT
00C829  4  CA           PRADR3: DEX
00C82A  4  D0 E7          BNE PRADR1
00C82C  4  60             RTS
00C82D  4  88           PRADR4: DEY
00C82E  4  30 E7          BMI PRADR2
00C830  4  20 DA CC       JSR A2_PRBYTE
00C833  4  A5 2E        PRADR5: LDA FORMAT
00C835  4  C9 E8          CMP #$E8 ; HANDLE REL ADR MODE
00C837  4  B1 3A          LDA (PCL),Y ; SPECIAL (PRINT TARGET,
00C839  4  90 F2          BCC PRADR4 ; NOT OFFSET)
00C83B  4  20 59 C8     RELADR: JSR PCADJ3
00C83E  4  AA             TAX ; PCL,PCH+OFFSET+1 TO A,Y
00C83F  4  E8             INX
00C840  4  D0 01          BNE PRNTYX ; +1 TO Y,X
00C842  4  C8             INY
00C843  4  98           PRNTYX: TYA
00C844  4  20 DA CC     PRNTAX: JSR A2_PRBYTE ; OUTPUT TARGET ADR
00C847  4  8A           PRNTX: TXA ; OF BRANCH AND RETURN
00C848  4  4C DA CC       JMP A2_PRBYTE
00C84B  4  A2 03        PRBLNK: LDX #$03 ; BLANK COUNT
00C84D  4  A9 A0        PRBL2: LDA #$A0 ; LOAD A SPACE
00C84F  4  20 ED CC     PRBL3: JSR COUT ; OUTPUT A BLANK
00C852  4  CA             DEX
00C853  4  D0 F8          BNE PRBL2 ; LOOP UNTIL COUNT=0
00C855  4  60             RTS
00C856  4  38           PCADJ: SEC ; 0=1-BYTE, 1=2-BYTE
00C857  4  A5 2F        PCADJ2: LDA LENGTH ; 2=3-BYTE
00C859  4  A4 3B        PCADJ3: LDY PCH
00C85B  4  AA             TAX ; TEST DISPLACEMENT SIGN
00C85C  4  10 01          BPL PCADJ4 ; (FOR REL BRANCH)
00C85E  4  88             DEY ; EXTEND NEG BY DEC PCH
00C85F  4  65 3A        PCADJ4: ADC PCL
00C861  4  90 01          BCC RTS2 ; PCL+LENGTH(OR DISPL)+1 TO A
00C863  4  C8             INY ; CARRY INTO Y (PCH)
00C864  4  60           RTS2: RTS
00C865  4               ; FMT1 BYTES: XXXXXXY0 INSTRS
00C865  4               ; IF Y=0 THEN LEFT HALF BYTE
00C865  4               ; IF Y=1 THEN RIGHT HALF BYTE
00C865  4               ; (X=INDEX)
00C865  4  04 20 54 30  FMT1: .BYTE $04,$20,$54,$30,$0D
00C869  4  0D           
00C86A  4  80 04 90 03    .BYTE $80,$04,$90,$03,$22
00C86E  4  22           
00C86F  4  54 33 0D 80    .BYTE $54,$33,$0D,$80,$04
00C873  4  04           
00C874  4  90 04 20 54    .BYTE $90,$04,$20,$54,$33
00C878  4  33           
00C879  4  0D 80 04 90    .BYTE $0D,$80,$04,$90,$04
00C87D  4  04           
00C87E  4  20 54 3B 0D    .BYTE $20,$54,$3B,$0D,$80
00C882  4  80           
00C883  4  04 90 00 22    .BYTE $04,$90,$00,$22,$44
00C887  4  44           
00C888  4  33 0D C8 44    .BYTE $33,$0D,$C8,$44,$00
00C88C  4  00           
00C88D  4  11 22 44 33    .BYTE $11,$22,$44,$33,$0D
00C891  4  0D           
00C892  4  C8 44 A9 01    .BYTE $C8,$44,$A9,$01,$22
00C896  4  22           
00C897  4  44 33 0D 80    .BYTE $44,$33,$0D,$80,$04
00C89B  4  04           
00C89C  4  90 01 22 44    .BYTE $90,$01,$22,$44,$33
00C8A0  4  33           
00C8A1  4  0D 80 04 90    .BYTE $0D,$80,$04,$90
00C8A5  4  26 31 87 9A    .BYTE $26,$31,$87,$9A ; $ZZXXXY01 INSTR'S
00C8A9  4  00           FMT2: .BYTE $00 ; ERR
00C8AA  4  21             .BYTE $21 ; IMM
00C8AB  4  81             .BYTE $81 ; Z-PAGE
00C8AC  4  82             .BYTE $82 ; ABS
00C8AD  4  00             .BYTE $00 ; IMPLIED
00C8AE  4  00             .BYTE $00 ; ACCUMULATOR
00C8AF  4  59             .BYTE $59 ; (ZPAG,X)
00C8B0  4  4D             .BYTE $4D ; (ZPAG),Y
00C8B1  4  91             .BYTE $91 ; ZPAG,X
00C8B2  4  92             .BYTE $92 ; ABS,X
00C8B3  4  86             .BYTE $86 ; ABS,Y
00C8B4  4  4A             .BYTE $4A ; (ABS)
00C8B5  4  85             .BYTE $85 ; ZPAG,Y
00C8B6  4  9D             .BYTE $9D ; RELATIVE
00C8B7  4  AC A9 AC A3  CHAR1: Str ",),#($"
00C8BB  4  A8 A4        
00C8BD  4  D9 00 D8 A4  CHAR2: .BYTE $D9,$00,$D8,$A4,$A4,$00
00C8C1  4  A4 00        
00C8C3  4               ; CHAR2: "Y",0,"X$$",0
00C8C3  4               ; MNEML IS OF FORM:
00C8C3  4               ; (A) XXXXX000
00C8C3  4               ; (B) XXXYY100
00C8C3  4               ; (C) 1XXX1010
00C8C3  4               ; (D) XXXYYY10
00C8C3  4               ; (E) XXXYYY01
00C8C3  4               ; (X=INDEX)
00C8C3  4  1C 8A 1C 23  MNEML: .BYTE $1C,$8A,$1C,$23,$5D,$8B
00C8C7  4  5D 8B        
00C8C9  4  1B A1 9D 8A    .BYTE $1B,$A1,$9D,$8A,$1D,$23
00C8CD  4  1D 23        
00C8CF  4  9D 8B 1D A1    .BYTE $9D,$8B,$1D,$A1,$00,$29
00C8D3  4  00 29        
00C8D5  4  19 AE 69 A8    .BYTE $19,$AE,$69,$A8,$19,$23
00C8D9  4  19 23        
00C8DB  4  24 53 1B 23    .BYTE $24,$53,$1B,$23,$24,$53
00C8DF  4  24 53        
00C8E1  4  19 A1          .BYTE $19,$A1 ; (A) FORMAT ABOVE
00C8E3  4  00 1A 5B 5B    .BYTE $00,$1A,$5B,$5B,$A5,$69
00C8E7  4  A5 69        
00C8E9  4  24 24          .BYTE $24,$24 ; (B) FORMAT
00C8EB  4  AE AE A8 AD    .BYTE $AE,$AE,$A8,$AD,$29,$00
00C8EF  4  29 00        
00C8F1  4  7C 00          .BYTE $7C,$00 ; (C) FORMAT
00C8F3  4  15 9C 6D 9C    .BYTE $15,$9C,$6D,$9C,$A5,$69
00C8F7  4  A5 69        
00C8F9  4  29 53          .BYTE $29,$53 ; (D) FORMAT
00C8FB  4  84 13 34 11    .BYTE $84,$13,$34,$11,$A5,$69
00C8FF  4  A5 69        
00C901  4  23 A0          .BYTE $23,$A0 ; (E) FORMAT
00C903  4  D8 62 5A 48  MNEMR: .BYTE $D8,$62,$5A,$48,$26,$62
00C907  4  26 62        
00C909  4  94 88 54 44    .BYTE $94,$88,$54,$44,$C8,$54
00C90D  4  C8 54        
00C90F  4  68 44 E8 94    .BYTE $68,$44,$E8,$94,$00,$B4
00C913  4  00 B4        
00C915  4  08 84 74 B4    .BYTE $08,$84,$74,$B4,$28,$6E
00C919  4  28 6E        
00C91B  4  74 F4 CC 4A    .BYTE $74,$F4,$CC,$4A,$72,$F2
00C91F  4  72 F2        
00C921  4  A4 8A          .BYTE $A4,$8A ; (A) FORMAT
00C923  4  00 AA A2 A2    .BYTE $00,$AA,$A2,$A2,$74,$74
00C927  4  74 74        
00C929  4  74 72          .BYTE $74,$72 ; (B) FORMAT
00C92B  4  44 68 B2 32    .BYTE $44,$68,$B2,$32,$B2,$00
00C92F  4  B2 00        
00C931  4  22 00          .BYTE $22,$00 ; (C) FORMAT
00C933  4  1A 1A 26 26    .BYTE $1A,$1A,$26,$26,$72,$72
00C937  4  72 72        
00C939  4  88 C8          .BYTE $88,$C8 ; (D) FORMAT
00C93B  4  C4 CA 26 48    .BYTE $C4,$CA,$26,$48,$44,$44
00C93F  4  44 44        
00C941  4  A2 C8          .BYTE $A2,$C8 ; (E) FORMAT
00C943  4  FF FF FF       .BYTE $FF,$FF,$FF
00C946  4  20 D3 C7     A2_STEP: JSR INSTDSP ; DISASSEMBLE ONE INST
00C949  4  68             PLA ; AT (PCL,H)
00C94A  4  85 2C          STA RTNL ; ADJUST TO USER
00C94C  4  68             PLA ; STACK. SAVE
00C94D  4  85 2D          STA RTNH ; RTN ADR.
00C94F  4  A2 08          LDX #$08
00C951  4  BD 13 CA     XQINIT: LDA INITBL-1,X ; INIT XEQ AREA
00C954  4  95 3C          STA XQT,X
00C956  4  CA             DEX
00C957  4  D0 F8          BNE XQINIT
00C959  4  A1 3A          LDA (PCL,X) ; USER OPCODE BYTE
00C95B  4  F0 42          BEQ XBRK ; SPECIAL IF BREAK
00C95D  4  A4 2F          LDY LENGTH ; LEN FROM DISASSEMBLY
00C95F  4  C9 20          CMP #$20
00C961  4  F0 59          BEQ XJSR ; HANDLE JSR, RTS, JMP,
00C963  4  C9 60          CMP #$60 ; JMP (), RTI SPECIAL
00C965  4  F0 45          BEQ XRTS
00C967  4  C9 4C          CMP #$4C
00C969  4  F0 5C          BEQ XJMP
00C96B  4  C9 6C          CMP #$6C
00C96D  4  F0 59          BEQ XJMPAT
00C96F  4  C9 40          CMP #$40
00C971  4  F0 35          BEQ XRTI
00C973  4  29 1F          AND #$1F
00C975  4  49 14          EOR #$14
00C977  4  C9 04          CMP #$04 ; COPY USER INST TO XEQ AREA
00C979  4  F0 02          BEQ XQ2 ; WITH TRAILING NOPS
00C97B  4  B1 3A        XQ1: LDA (PCL),Y ; CHANGE REL BRANCH
00C97D  4  99 3C 00     XQ2: STA XQT,Y ; DISP TO 4 FOR
00C980  4  88             DEY ; JMP TO BRANCH OR
00C981  4  10 F8          BPL XQ1 ; NBRANCH FROM XEQ.
00C983  4  20 3F CE       JSR A2_RESTORE ; RESTORE USER REG CONTENTS.
00C986  4  4C 3C 00       JMP XQT ; XEQ USER OP FROM RAM
00C989  4  85 45        IRQ: STA ACC ; (RETURN TO NBRANCH)
00C98B  4  68             PLA
00C98C  4  48             PHA ; **IRQ HANDLER
00C98D  4  0A             ASL A
00C98E  4  0A             ASL A
00C98F  4  0A             ASL A
00C990  4  30 03          BMI BREAK ; TEST FOR BREAK
00C992  4  6C FE 03       JMP (IRQLOC) ; USER ROUTINE VECTOR IN RAM
00C995  4  28           BREAK: PLP
00C996  4  20 4C CE       JSR SAV1 ; SAVE REG'S ON BREAK
00C999  4  68             PLA ; INCLUDING PC
00C99A  4  85 3A          STA PCL
00C99C  4  68             PLA
00C99D  4  85 3B          STA PCH
00C99F  4  20 85 C7     XBRK: JSR INSDS1 ; PRINT USER PC.
00C9A2  4  20 DD C9       JSR RGDSP1 ; AND REG'S
00C9A5  4  4C 65 CE       JMP MON ; GO TO MONITOR
00C9A8  4  18           XRTI: CLC
00C9A9  4  68             PLA ; SIMULATE RTI BY EXPECTING
00C9AA  4  85 48          STA STATUS ; STATUS FROM STACK, THEN RTS
00C9AC  4  68           XRTS: PLA ; RTS SIMULATION
00C9AD  4  85 3A          STA PCL ; EXTRACT PC FROM STACK
00C9AF  4  68             PLA ; AND UPDATE PC BY 1 (LEN=0)
00C9B0  4  85 3B        PCINC2: STA PCH
00C9B2  4  A5 2F        PCINC3: LDA LENGTH ; UPDATE PC BY LEN
00C9B4  4  20 59 C8       JSR PCADJ3
00C9B7  4  84 3B          STY PCH
00C9B9  4  18             CLC
00C9BA  4  90 14          BCC NEWPCL
00C9BC  4  18           XJSR: CLC
00C9BD  4  20 57 C8       JSR PCADJ2 ; UPDATE PC AND PUSH
00C9C0  4  AA             TAX ; ONTO STACH FOR
00C9C1  4  98             TYA ; JSR SIMULATE
00C9C2  4  48             PHA
00C9C3  4  8A             TXA
00C9C4  4  48             PHA
00C9C5  4  A0 02          LDY #$02
00C9C7  4  18           XJMP: CLC
00C9C8  4  B1 3A        XJMPAT: LDA (PCL),Y
00C9CA  4  AA             TAX ; LOAD PC FOR JMP,
00C9CB  4  88             DEY ; (JMP) SIMULATE.
00C9CC  4  B1 3A          LDA (PCL),Y
00C9CE  4  86 3B          STX PCH
00C9D0  4  85 3A        NEWPCL: STA PCL
00C9D2  4  B0 F3          BCS XJMP
00C9D4  4  A5 2D        RTNJMP: LDA RTNH
00C9D6  4  48             PHA
00C9D7  4  A5 2C          LDA RTNL
00C9D9  4  48             PHA
00C9DA  4  20 8E CC     REGDSP: JSR CROUT ; DISPLAY USER REG
00C9DD  4  A9 45        RGDSP1: LDA #ACC ; CONTENTS WITH
00C9DF  4  85 40          STA A3L ; LABELS
00C9E1  4  A9 00          LDA #ACC/256
00C9E3  4  85 41          STA A3H
00C9E5  4  A2 FB          LDX #$FB
00C9E7  4  A9 A0        RDSP1: LDA #$A0
00C9E9  4  20 ED CC       JSR COUT
00C9EC  4  BD 21 C9       LDA RTBL-$FB,X
00C9EF  4  20 ED CC       JSR COUT
00C9F2  4  A9 BD          LDA #$BD
00C9F4  4  20 ED CC       JSR COUT
00C9F7  4  B5 4A          LDA ACC+5,X
00C9F9  4  20 DA CC       JSR A2_PRBYTE
00C9FC  4  E8             INX
00C9FD  4  30 E8          BMI RDSP1
00C9FF  4  60             RTS
00CA00  4  18           BRANCH: CLC ; BRANCH TAKEN,
00CA01  4  A0 01          LDY #$01 ; ADD LEN+2 TO PC
00CA03  4  B1 3A          LDA (PCL),Y
00CA05  4  20 59 C8       JSR PCADJ3
00CA08  4  85 3A          STA PCL
00CA0A  4  98             TYA
00CA0B  4  38             SEC
00CA0C  4  B0 A2          BCS PCINC2
00CA0E  4  20 4A CE     NBRNCH: JSR A2_SAVE ; NORMAL RETURN AFTER
00CA11  4  38             SEC ; XEQ USER OF
00CA12  4  B0 9E          BCS PCINC3 ; GO UPDATE PC
00CA14  4  EA           INITBL: NOP
00CA15  4  EA             NOP ; DUMMY FILL FOR
00CA16  4  4C 0E CA       JMP NBRNCH ; XEQ AREA
00CA19  4  4C 00 CA       JMP BRANCH
00CA1C  4  C1           RTBL: .BYTE $C1
00CA1D  4  D8             .BYTE $D8
00CA1E  4  D9             .BYTE $D9
00CA1F  4  D0             .BYTE $D0
00CA20  4  D3             .BYTE $D3
00CA21  4  AD 70 C0     PREAD: LDA PTRIG ; TRIGGER PADDLES
00CA24  4  A0 00          LDY #$00 ; INIT COUNT
00CA26  4  EA             NOP ; COMPENSATE FOR 1ST COUNT
00CA27  4  EA             NOP
00CA28  4  BD 64 C0     PREAD2: LDA PADDL0,X ; COUNT Y-REG EVERY
00CA2B  4  10 04          BPL RTS2D ; 12 USEC
00CA2D  4  C8             INY
00CA2E  4  D0 F8          BNE PREAD2 ; EXIT AT 255 MAX
00CA30  4  88             DEY
00CA31  4  60           RTS2D: RTS
00CA32  4  A9 00        INIT: LDA #$00 ; CLR STATUS FOR DEBUG
00CA34  4  85 48          STA STATUS ; SOFTWARE
00CA36  4  AD 56 C0       LDA LORES
00CA39  4  AD 54 C0       LDA LOWSCR ; INIT VIDEO MODE
00CA3C  4  AD 51 C0     SETTXT: LDA TXTSET ; SET FOR TEXT MODE
00CA3F  4  A9 00          LDA #$00 ; FULL SCREEN WINDOW
00CA41  4  F0 0B          BEQ SETWND
00CA43  4  AD 50 C0     SETGR: LDA TXTCLR ; SET FOR GRAPHICS MODE
00CA46  4  AD 53 C0       LDA MIXSET ; LOWER 4 LINES AS
00CA49  4  20 39 C7       JSR CLRTOP ; TEXT WINDOW
00CA4C  4  A9 14          LDA #$14
00CA4E  4  85 22        SETWND: STA WNDTOP ; SET FOR 40 COL WINDOW
00CA50  4  A9 00          LDA #$00 ; TOP IN A-REG,
00CA52  4  85 20          STA WNDLFT ; BTTM AT LINE 24
00CA54  4  A9 28          LDA #$28
00CA56  4  85 21          STA WNDWDTH
00CA58  4  A9 18          LDA #$18
00CA5A  4  85 23          STA WNDBTM ; VTAB TO ROW 23
00CA5C  4  A9 17          LDA #$17
00CA5E  4  85 25        TABV: STA CV ; VTABS TO ROW IN A-REG
00CA60  4  4C 25 CB       JMP VTAB
00CA63  4  20 A7 CA     MULPM: JSR MD1 ; ABS VAL OF AC AUX
00CA66  4  A0 10        MUL: LDY #$10 ; INDEX FOR 16 BITS
00CA68  4  A5 50        MUL2: LDA ACL ; ACX * AUX + XTND
00CA6A  4  4A             LSR A ; TO AC, XTND
00CA6B  4  90 0C          BCC MUL4 ; IF NO CARRY,
00CA6D  4  18             CLC ; NO PARTIAL PROD.
00CA6E  4  A2 FE          LDX #$FE
00CA70  4  B5 54        MUL3: LDA XTNDL+2,X ; ADD MPLCND (AUX)
00CA72  4  75 56          ADC AUXL+2,X ; TO PARTIAL PROD
00CA74  4  95 54          STA XTNDL+2,X ; (XTND)
00CA76  4  E8             INX
00CA77  4  D0 F7          BNE MUL3
00CA79  4  A2 03        MUL4: LDX #$03
00CA7B  4  76           MUL5: .BYTE $76
00CA7C  4  50             .BYTE $50
00CA7D  4  CA             DEX
00CA7E  4  10 FB          BPL MUL5
00CA80  4  88             DEY
00CA81  4  D0 E5          BNE MUL2
00CA83  4  60             RTS
00CA84  4  20 A7 CA     DIVPM: JSR MD1 ; ABS VAL OF AC, AUX.
00CA87  4  A0 10        A2_DIV: LDY #$10 ; INDEX FOR 16 BITS
00CA89  4  06 50        DIV2: ASL ACL
00CA8B  4  26 51          ROL ACH
00CA8D  4  26 52          ROL XTNDL ; XTND/AUX
00CA8F  4  26 53          ROL XTNDH ; TO AC.
00CA91  4  38             SEC
00CA92  4  A5 52          LDA XTNDL
00CA94  4  E5 54          SBC AUXL ; MOD TO XTND.
00CA96  4  AA             TAX
00CA97  4  A5 53          LDA XTNDH
00CA99  4  E5 55          SBC AUXH
00CA9B  4  90 06          BCC DIV3
00CA9D  4  86 52          STX XTNDL
00CA9F  4  85 53          STA XTNDH
00CAA1  4  E6 50          INC ACL
00CAA3  4  88           DIV3: DEY
00CAA4  4  D0 E3          BNE DIV2
00CAA6  4  60             RTS
00CAA7  4  A0 00        MD1: LDY #$00 ; ABS VAL OF AC, AUX
00CAA9  4  84 2F          STY A2_SIGN ; WITH RESULT SIGN
00CAAB  4  A2 54          LDX #AUXL ; IN LSB OF SIGN.
00CAAD  4  20 B2 CA       JSR MD3
00CAB0  4  A2 50          LDX #ACL
00CAB2  4  B5 01        MD3: LDA LOC1,X ; X SPECIFIES AC OR AUX
00CAB4  4  10 0D          BPL MDRTS
00CAB6  4  38             SEC
00CAB7  4  98             TYA
00CAB8  4  F5 00          SBC LOC0,X ; COMPL SPECIFIED REG
00CABA  4  95 00          STA LOC0,X ; IF NEG.
00CABC  4  98             TYA
00CABD  4  F5 01          SBC LOC1,X
00CABF  4  95 01          STA LOC1,X
00CAC1  4  E6 2F          INC A2_SIGN
00CAC3  4  60           MDRTS: RTS
00CAC4  4  48           BASCALC: PHA ; CALC BASE ADR IN BASL,H
00CAC5  4  4A             LSR A ; FOR GIVEN LINE NO
00CAC6  4  29 03          AND #$03 ; 0<=LINE NO.<=$17
00CAC8  4  09 04          ORA #$04 ; ARG=000ABCDE, GENERATE
00CACA  4  85 29          STA BASH ; BASH=000001CD
00CACC  4  68             PLA ; AND
00CACD  4  29 18          AND #$18 ; BASL=EABAB000
00CACF  4  90 02          BCC BSCLC2
00CAD1  4  69 7F          ADC #$7F
00CAD3  4  85 28        BSCLC2: STA BASL
00CAD5  4  0A             ASL
00CAD6  4  0A             ASL
00CAD7  4  05 28          ORA BASL
00CAD9  4  85 28          STA BASL
00CADB  4  60             RTS
00CADC  4  C9 87        BELL1: CMP #$87 ; BELL CHAR? (CNTRL-G)
00CADE  4  D0 12          BNE RTS2B ; NO, RETURN
00CAE0  4  A9 40          LDA #$40 ; DELAY .01 SECONDS
00CAE2  4  20 AB CB       JSR A2_WAIT
00CAE5  4  A0 C0          LDY #$C0
00CAE7  4  A9 0C        BELL2: LDA #$0C ; TOGGLE SPEAKER AT
00CAE9  4  20 AB CB       JSR A2_WAIT ; 1 KHZ FOR .1 SEC.
00CAEC  4  AD 30 C0       LDA SPKR
00CAEF  4  88             DEY
00CAF0  4  D0 F5          BNE BELL2
00CAF2  4  60           RTS2B: RTS
00CAF3  4  A4 24        STOADV: LDY CH ; CURSOR H INDEX TO Y-REG
00CAF5  4               .ifdef EATER
00CAF5  4  EA             NOP
00CAF6  4  EA             NOP
00CAF7  4               .else
00CAF7  4                 STA (BASL),Y ; STORE CHAR IN LINE
00CAF7  4               .endif
00CAF7  4  E6 24        ADVANCE: INC CH ; INCREMENT CURSOR H INDEX
00CAF9  4  A5 24          LDA CH ; (MOVE RIGHT)
00CAFB  4  C5 21          CMP WNDWDTH ; BEYOND WINDOW WIDTH?
00CAFD  4  B0 66          BCS A2_CR ; YES CR TO NEXT LINE
00CAFF  4  60           A2_RTS3: RTS ; NO,RETURN
00CB00  4  C9 A0        VIDOUT: CMP #$A0 ; CONTROL CHAR?
00CB02  4  B0 EF          BCS STOADV ; NO,OUTPUT IT.
00CB04  4  A8             TAY ; INVERSE VIDEO?
00CB05  4  10 EC          BPL STOADV ; YES, OUTPUT IT.
00CB07  4  C9 8D          CMP #$8D ; CR?
00CB09  4  F0 5A          BEQ A2_CR ; YES.
00CB0B  4  C9 8A          CMP #$8A ; LINE FEED?
00CB0D  4  F0 5A          BEQ A2_LF ; IF SO, DO IT.
00CB0F  4  C9 88          CMP #$88 ; BACK SPACE? (CNTRL-H)
00CB11  4  D0 C9          BNE BELL1 ; NO, CHECK FOR BELL.
00CB13  4  C6 24        BS1: DEC CH ; DECREMENT CURSOR H INDEX
00CB15  4  10 E8          BPL A2_RTS3 ; IF POS, OK. ELSE MOVE UP
00CB17  4  A5 21          LDA WNDWDTH ; SET CH TO WNDWDTH-1
00CB19  4  85 24          STA CH
00CB1B  4  C6 24         DEC CH ; (RIGHTMOST SCREEN POS)
00CB1D  4  A5 22        UP: LDA WNDTOP ; CURSOR V INDEX
00CB1F  4  C5 25          CMP CV
00CB21  4  B0 0B          BCS RTS4 ; IF TOP LINE THEN RETURN
00CB23  4  C6 25          DEC CV ; DEC CURSOR V-INDEX
00CB25  4  A5 25        VTAB: LDA CV ; GET CURSOR V-INDEX
00CB27  4  20 C4 CA     VTABZ: JSR BASCALC ; GENERATE BASE ADR
00CB2A  4  65 20          ADC WNDLFT ; ADD WINDOW LEFT INDEX
00CB2C  4  85 28          STA BASL ; TO BASL
00CB2E  4  60           RTS4: RTS
00CB2F  4  49 C0        ESC1: EOR #$C0 ; ESC?
00CB31  4  F0 28          BEQ HOME ; IF SO, DO HOME AND CLEAR
00CB33  4  69 FD          ADC #$FD ; ESC-A OR B CHECK
00CB35  4  90 C0          BCC ADVANCE ; A, ADVANCE
00CB37  4  F0 DA          BEQ BS1 ; B, BACKSPACE
00CB39  4  69 FD          ADC #$FD ; ESC-C OR D CHECK
00CB3B  4  90 2C          BCC A2_LF ; C, DOWN
00CB3D  4  F0 DE          BEQ UP ; D, GO UP
00CB3F  4  69 FD          ADC #$FD ; ESC-E OR F CHECK
00CB41  4  90 5C          BCC CLREOL ; E, CLEAR TO END OF LINE
00CB43  4  D0 E9          BNE RTS4 ; NOT F, RETURN
00CB45  4  A4 24        CLREOP: LDY CH ; CURSOR H TO Y INDEX
00CB47  4  A5 25          LDA CV ; CURSOR V TO A-REGISTER
00CB49  4  48           CLEOP1: PHA ; SAVE CURRENT LINE ON STK
00CB4A  4  20 27 CB       JSR VTABZ ; CALC BASE ADDRESS
00CB4D  4  20 A1 CB       JSR CLEOLZ ; CLEAR TO EOL, SET CARRY
00CB50  4  A0 00          LDY #$00 ; CLEAR FROM H INDEX=0 FOR REST
00CB52  4  68             PLA ; INCREMENT CURRENT LINE
00CB53  4  69 00          ADC #$00 ; (CARRY IS SET)
00CB55  4  C5 23          CMP WNDBTM ; DONE TO BOTTOM OF WINDOW?
00CB57  4  90 F0          BCC CLEOP1 ; NO, KEEP CLEARING LINES
00CB59  4  B0 CA          BCS VTAB ; YES, TAB TO CURRENT LINE
00CB5B  4  A5 22        HOME: LDA WNDTOP ; INIT CURSOR V
00CB5D  4  85 25          STA CV ; AND H-INDICES
00CB5F  4  A0 00          LDY #$00
00CB61  4  84 24          STY CH ; THEN CLEAR TO END OF PAGE
00CB63  4  F0 E4          BEQ CLEOP1
00CB65  4  A9 00        A2_CR: LDA #$00 ; CURSOR TO LEFT OF INDEX
00CB67  4  85 24          STA CH ; (RET CURSOR H=0)
00CB69  4  E6 25        A2_LF: INC CV ; INCR CURSOR V(DOWN 1 LINE)
00CB6B  4  A5 25          LDA CV
00CB6D  4  C5 23          CMP WNDBTM ; OFF SCREEN?
00CB6F  4  90 B6          BCC VTABZ ; NO, SET BASE ADDR
00CB71  4  C6 25          DEC CV ; DECR CURSOR V (BACK TO BOTTOM)
00CB73  4  A5 22        SCROLL: LDA WNDTOP ; START AT TOP OF SCRL WNDW
00CB75  4  48             PHA
00CB76  4  20 27 CB       JSR VTABZ ; GENERATE BASE ADR
00CB79  4  A5 28        SCRL1: LDA BASL ; COPY BASL,H
00CB7B  4  85 2A          STA BAS2L ; TO BAS2L,H
00CB7D  4  A5 29          LDA BASH
00CB7F  4  85 2B          STA BAS2H
00CB81  4  A4 21          LDY WNDWDTH ; INIT Y TO RIGHTMOST INDEX
00CB83  4  88             DEY ; OF SCROLLING WINDOW
00CB84  4  68             PLA
00CB85  4  69 01          ADC #$01 ; INCR LINE NUMBER
00CB87  4  C5 23          CMP WNDBTM ; DONE?
00CB89  4  B0 0D          BCS SCRL3 ; YES, FINISH
00CB8B  4  48             PHA
00CB8C  4  20 27 CB       JSR VTABZ ; FORM BASL,H (BASE ADDR)
00CB8F  4  B1 28        SCRL2: LDA (BASL),Y ; MOVE A CHR UP ON LINE
00CB91  4               .ifdef EATER
00CB91  4  EA             NOP
00CB92  4  EA             NOP
00CB93  4               .else
00CB93  4                 STA (BAS2L),Y
00CB93  4               .endif
00CB93  4  88             DEY ; NEXT CHAR OF LINE
00CB94  4  10 F9          BPL SCRL2
00CB96  4  30 E1          BMI SCRL1 ; NEXT LINE (ALWAYS TAKEN)
00CB98  4  A0 00        SCRL3: LDY #$00 ; CLEAR BOTTOM LINE
00CB9A  4  20 A1 CB       JSR CLEOLZ ; GET BASE ADDR FOR BOTTOM LINE
00CB9D  4  B0 86          BCS VTAB ; CARRY IS SET
00CB9F  4  A4 24        CLREOL: LDY CH ; CURSOR H INDEX
00CBA1  4  A9 A0        CLEOLZ: LDA #$A0
00CBA3  4               CLEOL2:
00CBA3  4               .ifdef EATER
00CBA3  4  EA             NOP
00CBA4  4  EA             NOP
00CBA5  4               .else
00CBA5  4                 STA (BASL),Y ; STORE BLANKS FROM 'HERE'
00CBA5  4               .endif
00CBA5  4  C8             INY ; TO END OF LINES (WNDWDTH)
00CBA6  4  C4 21          CPY WNDWDTH
00CBA8  4  90 F9          BCC CLEOL2
00CBAA  4  60             RTS
00CBAB  4  38           A2_WAIT: SEC
00CBAC  4  48           WAIT2: PHA
00CBAD  4  E9 01        WAIT3: SBC #$01
00CBAF  4  D0 FC          BNE WAIT3 ; 1.0204 USEC
00CBB1  4  68             PLA ; (13+27/2*A+5/2*A*A)
00CBB2  4  E9 01          SBC #$01
00CBB4  4  D0 F6          BNE WAIT2
00CBB6  4  60             RTS
00CBB7  4  E6 42        NXTA4: INC A4L ; INCR 2-BYTE A4
00CBB9  4  D0 02          BNE NXTA1 ; AND A1
00CBBB  4  E6 43          INC A4H
00CBBD  4  A5 3C        NXTA1: LDA A1L ; INCR 2-BYTE A1.
00CBBF  4  C5 3E          CMP A2L
00CBC1  4  A5 3D          LDA A1H ; AND COMPARE TO A2
00CBC3  4  E5 3F          SBC A2H
00CBC5  4  E6 3C          INC A1L ; (CARRY SET IF >=)
00CBC7  4  D0 02          BNE RTS4B
00CBC9  4  E6 3D          INC A1H
00CBCB  4  60           RTS4B: RTS
00CBCC  4               .ifdef EATER
00CBCC  4  A0 48        HEADR: LDY #$48 ; WRITE A*256 'LONG 1'
00CBCE  4               .else
00CBCE  4               HEADR: LDY #$4B ; WRITE A*256 'LONG 1'
00CBCE  4               .endif
00CBCE  4  20 DE CB       JSR ZERDLY ; HALF CYCLES
00CBD1  4  D0 F9          BNE HEADR ; (650 USEC EACH)
00CBD3  4  69 FE          ADC #$FE
00CBD5  4  B0 F5          BCS HEADR ; THEN A 'SHORT 0'
00CBD7  4  A0 21          LDY #$21 ; (400 USEC)
00CBD9  4  20 DE CB     WRBIT: JSR ZERDLY ; WRITE TWO HALF CYCLES
00CBDC  4  C8             INY ; OF 250 USEC ('0')
00CBDD  4  C8             INY ; OR 500 USEC ('0')
00CBDE  4  88           ZERDLY: DEY
00CBDF  4  D0 FD          BNE ZERDLY
00CBE1  4  90 05          BCC WRTAPE ; Y IS COUNT FOR
00CBE3  4  A0 32          LDY #$32 ; TIMING LOOP
00CBE5  4  88           ONEDLY: DEY
00CBE6  4  D0 FD          BNE ONEDLY
00CBE8  4               .ifdef EATER
00CBE8  4  BC 00 C0     WRTAPE: LDY IOADR,X
00CBEB  4  A0 2C          LDY #$2C
00CBED  4  CA             DEX
00CBEE  4               .else
00CBEE  4               WRTAPE: LDY TAPEOUT
00CBEE  4                 LDY  #$2C
00CBEE  4                 DEX
00CBEE  4               .endif
00CBEE  4  60             RTS
00CBEF  4  A2 08        RDBYTE: LDX #$08 ; 8 BITS TO READ
00CBF1  4  48           RDBYT2: PHA ; READ TWO TRANSITIONS
00CBF2  4  20 FD CB       JSR RD2BIT ; (FIND EDGE)
00CBF5  4  68             PLA
00CBF6  4  2A             ROL ; NEXT BIT
00CBF7  4  A0 3A          LDY #$3A ; COUNT FOR SAMPLES
00CBF9  4  CA             DEX
00CBFA  4  D0 F5          BNE RDBYT2
00CBFC  4  60             RTS
00CBFD  4  20 00 CC     RD2BIT: JSR RDBIT
00CC00  4  88           RDBIT: DEY ; DECR Y UNTIL
00CC01  4               .ifdef EATER
00CC01  4  AD 81 C0       LDA $C081 ; TAPE TRANSITION
00CC04  4  C5 2F          CMP LASTIN
00CC06  4  F0 F8          BEQ RDBIT
00CC08  4  85 2F          STA LASTIN
00CC0A  4  C0 80          CPY #$80 ; SET CARRY ON Y
00CC0C  4  60             RTS
00CC0D  4  EA             NOP
00CC0E  4  EA             NOP
00CC0F  4               .else
00CC0F  4                 LDA TAPEIN ; TAPE TRANSITION
00CC0F  4                 EOR LASTIN
00CC0F  4                 BPL RDBIT
00CC0F  4                 EOR LASTIN
00CC0F  4                 STA LASTIN
00CC0F  4                 CPY #$80 ; SET CARRY ON Y
00CC0F  4                 RTS
00CC0F  4               .endif
00CC0F  4  A4 24        RDKEY: LDY CH
00CC11  4  B1 28          LDA (BASL),Y ; SET SCREEN TO FLASH
00CC13  4  48             PHA
00CC14  4  29 3F          AND #$3F
00CC16  4  09 40          ORA #$40
00CC18  4               .ifdef EATER
00CC18  4  EA             NOP
00CC19  4  EA             NOP
00CC1A  4               .else
00CC1A  4                 STA (BASL),Y
00CC1A  4               .endif
00CC1A  4  68             PLA
00CC1B  4               .ifdef EATER
00CC1B  4  EA             NOP
00CC1C  4  EA             NOP
00CC1D  4  EA             NOP
00CC1E  4               .else
00CC1E  4                 JMP (KSWL) ; GO TO USER KEY-IN
00CC1E  4               .endif
00CC1E  4  E6 4E        KEYIN: INC RNDL
00CC20  4  D0 02          BNE KEYIN2 ; INCR RND NUMBER
00CC22  4  E6 4F          INC RNDH
00CC24  4               KEYIN2:
00CC24  4               .ifdef EATER
00CC24  4  20 rr rr       JSR CHRIN
00CC27  4  90 F5          BCC KEYIN
00CC29  4               ;  LDA     ACE_LSR        ; Check status.
00CC29  4               ;  AND     #$01           ; Key ready?
00CC29  4               
00CC29  4                 ; LDA $D011
00CC29  4               .else
00CC29  4                 BIT KBD ; KEY DOWN?
00CC29  4                 BEQ KEYIN
00CC29  4               .endif
00CC29  4                 ; BPL KEYIN ; LOOP
00CC29  4                 ;BEQ KEYIN     ; no key, loop
00CC29  4               .ifdef EATER
00CC29  4  EA             NOP
00CC2A  4  EA             NOP
00CC2B  4               .else
00CC2B  4                 STA (BASL),Y ; REPLACE FLASHING SCREEN
00CC2B  4               .endif
00CC2B  4               .ifdef EATER
00CC2B  4                 ; LDA $D010 ; GET KEYCODE
00CC2B  4                 ; LDA ACE_DATA
00CC2B  4                 ; LDA ACIA_DATA
00CC2B  4  4C 86 C5       JMP L7
00CC2E  4  EA             NOP
00CC2F  4               .else
00CC2F  4                 LDA KBD
00CC2F  4                 BIT KBDSTRB ; CLR KEY STROBE
00CC2F  4                 RTS
00CC2F  4               .endif
00CC2F  4  20 0F CC     ESC: JSR RDKEY ; GET KEYCODE
00CC32  4  20 2F CB       JSR ESC1 ; HANDLE ESC FUNC.
00CC35  4  20 0F CC     RDCHAR: JSR RDKEY ; READ KEY
00CC38  4  C9 9B          CMP #$9B ; ESC?
00CC3A  4  F0 F3          BEQ ESC ; YES, DON'T RETURN
00CC3C  4  60             RTS
00CC3D  4  A5 32        A2_NOTCR: LDA INVFLG
00CC3F  4  48             PHA
00CC40  4  A9 FF          LDA #$FF
00CC42  4  85 32          STA INVFLG ; ECHO USER LINE
00CC44  4  BD 00 02       LDA A2_IN,X ; NON INVERSE
00CC47  4               .ifdef EATER
00CC47  4  EA             NOP
00CC48  4  EA             NOP
00CC49  4  EA             NOP
00CC4A  4               .else
00CC4A  4                 JSR COUT
00CC4A  4               .endif
00CC4A  4  68             PLA
00CC4B  4  85 32          STA INVFLG
00CC4D  4  BD 00 02       LDA A2_IN,X
00CC50  4               .ifdef EATER
00CC50  4  C9 DF          CMP #$DF ; CHECK FOR EDIT KEYS
00CC52  4               .else
00CC52  4                 CMP #$88 ; CHECK FOR EDIT KEYS
00CC52  4               .endif
00CC52  4  F0 1D          BEQ BCKSPC ; BS, CTRL-X
00CC54  4  C9 98          CMP #$98
00CC56  4  F0 0A          BEQ CANCEL
00CC58  4  E0 F8          CPX #$F8 ; MARGIN?
00CC5A  4  90 03          BCC NOTCR1
00CC5C  4  20 3A CE       JSR BELL ; YES, SOUND BELL
00CC5F  4  E8           NOTCR1: INX ; ADVANCE INPUT INDEX
00CC60  4  D0 13          BNE NXTCHAR
00CC62  4  A9 DC        CANCEL: LDA #$DC ; BACKSLASH AFTER CANCELLED LINE
00CC64  4  20 ED CC       JSR COUT
00CC67  4  20 8E CC     GETLNZ: JSR CROUT ; OUTPUT CR
00CC6A  4  A5 33        A2_GETLN: LDA PROMPT
00CC6C  4  20 ED CC       JSR COUT ; OUTPUT PROMPT CHAR
00CC6F  4  A2 01          LDX #$01 ; INIT INPUT INDEX
00CC71  4  8A           BCKSPC: TXA ; WILL BACKSPACE TO 0
00CC72  4  F0 F3          BEQ GETLNZ
00CC74  4  CA             DEX
00CC75  4  20 35 CC     NXTCHAR: JSR RDCHAR
00CC78  4  C9 95          CMP #PICK ; USE SCREEN CHAR
00CC7A  4  D0 02          BNE CAPTST ; FOR CTRL-U
00CC7C  4  B1 28          LDA (BASL),Y
00CC7E  4  C9 E0        CAPTST: CMP #$E0
00CC80  4  90 02          BCC ADDINP ; CONVERT TO CAPS
00CC82  4  29 DF          AND #$DF
00CC84  4  9D 00 02     ADDINP: STA A2_IN,X ; ADD TO INPUT BUF
00CC87  4  C9 8D          CMP #$8D
00CC89  4  D0 B2          BNE A2_NOTCR
00CC8B  4  20 9F CB       JSR CLREOL ; CLR TO EOL IF CR
00CC8E  4  A9 8D        CROUT: LDA #$8D
00CC90  4  D0 5B          BNE COUT
00CC92  4  A4 3D        PRA1: LDY A1H ; PRINT CR,A1 IN HEX
00CC94  4  A6 3C          LDX A1L
00CC96  4  20 8E CC     PRYX2: JSR CROUT
00CC99  4  20 43 C8       JSR PRNTYX
00CC9C  4  A0 00          LDY #$00
00CC9E  4  A9 AD          LDA #$AD ; PRINT '-'
00CCA0  4  4C ED CC       JMP COUT
00CCA3  4  A5 3C        XAM8: LDA A1L
00CCA5  4  09 07          ORA #$07 ; SET TO FINISH AT
00CCA7  4  85 3E          STA A2L ; MOD 8=7
00CCA9  4  A5 3D          LDA A1H
00CCAB  4  85 3F          STA A2H
00CCAD  4  A5 3C        MODSCHK: LDA A1L
00CCAF  4  29 07          AND #$07
00CCB1  4  D0 03          BNE DATAOUT
00CCB3  4  20 92 CC     XAM: JSR PRA1
00CCB6  4  A9 A0        DATAOUT: LDA #$A0
00CCB8  4  20 ED CC       JSR COUT ; OUTPUT BLANK
00CCBB  4  B1 3C          LDA (A1L),Y
00CCBD  4  20 DA CC       JSR A2_PRBYTE ; OUTPUT BYTE IN HEX
00CCC0  4  20 BD CB       JSR NXTA1
00CCC3  4  90 E8          BCC MODSCHK ; CHECK IF TIME TO,
00CCC5  4  60           RTS4C: RTS ; PRINT ADDR
00CCC6  4  4A           XAMPM: LSR A ; DETERMINE IF MON
00CCC7  4  90 EA          BCC XAM ; MODE IS XAM
00CCC9  4  4A             LSR A ; ADD, OR SUB
00CCCA  4  4A             LSR A
00CCCB  4  A5 3E          LDA A2L
00CCCD  4  90 02          BCC @ADD
00CCCF  4  49 FF          EOR #$FF ; SUB: FORM 2'S COMPLEMENT
00CCD1  4  65 3C        @ADD: ADC A1L
00CCD3  4  48             PHA
00CCD4  4  A9 BD          LDA #$BD
00CCD6  4  20 ED CC       JSR COUT ; PRINT '=', THEN RESULT
00CCD9  4  68             PLA
00CCDA  4  48           A2_PRBYTE: PHA ; PRINT BYTE AS 2 HEX
00CCDB  4  4A             LSR A ; DIGITS, DESTROYS A-REG
00CCDC  4  4A             LSR A
00CCDD  4  4A             LSR A
00CCDE  4  4A             LSR A
00CCDF  4  20 E5 CC       JSR PRHEXZ
00CCE2  4  68             PLA
00CCE3  4  29 0F        A2_PRHEX: AND #$0F ; PRINT HEX DIG IN A-REG
00CCE5  4  09 B0        PRHEXZ: ORA #$B0 ; LSB'S
00CCE7  4  C9 BA          CMP #$BA
00CCE9  4  90 02          BCC COUT
00CCEB  4  69 06          ADC #$06
00CCED  4               COUT:
00CCED  4               .ifdef EATER
00CCED  4  20 79 C5       JSR L3
00CCF0  4               .else
00CCF0  4                JMP (CSWL) ; VECTOR TO USER OUTPUT ROUTINE
00CCF0  4               .endif
00CCF0  4  C9 A0        COUT1: CMP #$A0
00CCF2  4  90 02          BCC COUTZ ; DON'T OUTPUT CTRL'S INVERSE
00CCF4  4  25 32          AND INVFLG ; MASK WITH INVERSE FLAG
00CCF6  4  84 35        COUTZ: STY YSAV1 ; SAV Y-REG
00CCF8  4  48             PHA ; SAV A-REG
00CCF9  4  20 00 CB       JSR VIDOUT ; OUTPUT A-REG AS ASCII
00CCFC  4  68             PLA ; RESTORE A-REG
00CCFD  4  A4 35          LDY YSAV1 ; AND Y-REG
00CCFF  4  60             RTS ; THEN RETURN
00CD00  4  C6 34        BL1: DEC A2_YSAV
00CD02  4  F0 9F          BEQ XAM8
00CD04  4  CA           BLANK: DEX ; BLANK TO MON
00CD05  4  D0 16          BNE SETMDZ ; AFTER BLANK
00CD07  4  C9 BA          CMP #$BA ; DATA STORE MODE?
00CD09  4  D0 BB          BNE XAMPM ; NO, XAM, ADD, OR SUB
00CD0B  4  85 31        STOR: STA A2_MODE ; KEEP IN STORE MODE
00CD0D  4  A5 3E          LDA A2L
00CD0F  4  91 40          STA (A3L),Y ; STORE AS LOW BYTE AS (A3)
00CD11  4  E6 40          INC A3L
00CD13  4  D0 02          BNE RTS5 ; INCR A3, RETURN
00CD15  4  E6 41          INC A3H
00CD17  4  60           RTS5: RTS
00CD18  4  A4 34        A2_SETMODE: LDY A2_YSAV ; SAVE CONVERTED ':', '+',
00CD1A  4  B9 FF 01       LDA A2_IN-1,Y ; '-', '.' AS MODE.
00CD1D  4  85 31        SETMDZ: STA A2_MODE
00CD1F  4  60             RTS
00CD20  4  A2 01        LT: LDX #$01
00CD22  4  B5 3E        LT2: LDA A2L,X ; COPY A2 (2 BYTES) TO
00CD24  4  95 42          STA A4L,X ; A4 AND A5
00CD26  4  95 44          STA A5L,X
00CD28  4  CA             DEX
00CD29  4  10 F7          BPL LT2
00CD2B  4  60             RTS
00CD2C  4  B1 3C        MOVE: LDA (A1L),Y ; MOVE (A1 TO A2) TO
00CD2E  4  91 42          STA (A4L),Y ; (A4)
00CD30  4  20 B7 CB       JSR NXTA4
00CD33  4  90 F7          BCC MOVE
00CD35  4  60             RTS
00CD36  4  B1 3C        VFY: LDA (A1L),Y ; VERIFY (A1 TO A2) WITH
00CD38  4  D1 42          CMP (A4L),Y ; (A4)
00CD3A  4  F0 1C          BEQ VFYOK
00CD3C  4  20 92 CC       JSR PRA1
00CD3F  4  B1 3C          LDA (A1L),Y
00CD41  4  20 DA CC       JSR A2_PRBYTE
00CD44  4  A9 A0          LDA #$A0
00CD46  4  20 ED CC       JSR COUT
00CD49  4  A9 A8          LDA #$A8
00CD4B  4  20 ED CC       JSR COUT
00CD4E  4  B1 42          LDA (A4L),Y
00CD50  4  20 DA CC       JSR A2_PRBYTE
00CD53  4  A9 A9          LDA #$A9
00CD55  4  20 ED CC       JSR COUT
00CD58  4  20 B7 CB     VFYOK: JSR NXTA4
00CD5B  4  90 D9          BCC VFY
00CD5D  4  60             RTS
00CD5E  4  20 75 CD     A2_LIST: JSR A1PC ; MOVE A1 (2 BYTES) TO
00CD61  4  A9 14          LDA #$14 ; PC IF SPEC'D AND
00CD63  4  48           LIST2: PHA ; DISEMBLE 20 INSTRS
00CD64  4  20 D3 C7       JSR INSTDSP
00CD67  4  20 56 C8       JSR PCADJ ; ADJUST PC EACH INSTR
00CD6A  4  85 3A          STA PCL
00CD6C  4  84 3B          STY PCH
00CD6E  4  68             PLA
00CD6F  4  38             SEC
00CD70  4  E9 01          SBC #$01 ; NEXT OF 20 INSTRS
00CD72  4  D0 EF          BNE LIST2
00CD74  4  60             RTS
00CD75  4  8A           A1PC: TXA ; IF USER SPEC'D ADR
00CD76  4  F0 07          BEQ A1PCRTS ; COPY FROM A1 TO PC
00CD78  4  B5 3C        A1PCLP: LDA A1L,X
00CD7A  4  95 3A          STA PCL,X
00CD7C  4  CA             DEX
00CD7D  4  10 F9          BPL A1PCLP
00CD7F  4  60           A1PCRTS: RTS
00CD80  4  A0 3F        SETINV: LDY #$3F ; SET FOR INVERSE VID
00CD82  4  D0 02          BNE SETIFLG ; VIA COUT1
00CD84  4  A0 FF        SETNORM: LDY #$FF ; SET FOR NORMAL VID
00CD86  4  84 32        SETIFLG: STY INVFLG
00CD88  4  60             RTS
00CD89  4  A9 00        SETKBD: LDA #$00 ; SIMULATE PORT #0 INPUT
00CD8B  4  85 3E        INPORT: STA A2L ; SPECIFIED (KEYIN ROUTINE)
00CD8D  4  A2 38        A2_INPRT: LDX #KSWL
00CD8F  4  A0 1E          LDY #<KEYIN
00CD91  4  D0 08          BNE IOPRT
00CD93  4  A9 00        SETVID: LDA #$00 ; SIMULATE PORT #0 OUTPUT
00CD95  4  85 3E        OUTPORT: STA A2L ; SPECIFIED (COUT1 ROUTINE)
00CD97  4  A2 36        OUTPRT: LDX #CSWL
00CD99  4  A0 F0          LDY #<COUT1
00CD9B  4  A5 3E        IOPRT: LDA A2L ; SET RAM IN/OUT VECTORS
00CD9D  4  29 0F          AND #$0F
00CD9F  4  F0 06          BEQ IOPRT1
00CDA1  4  09 C0          ORA #>IOADR
00CDA3  4  A0 00          LDY #$00
00CDA5  4  F0 02          BEQ IOPRT2
00CDA7  4               .ifdef EATER
00CDA7  4  A9 FD        IOPRT1: LDA #$FD
00CDA9  4               .else
00CDA9  4               IOPRT1: LDA #>COUT1
00CDA9  4               .endif
00CDA9  4  94 00        IOPRT2: STY LOC0,X
00CDAB  4  95 01          STA LOC1,X
00CDAD  4  60             RTS
00CDAE  4  EA             NOP
00CDAF  4  EA             NOP
00CDB0  4  4C 00 E0     XBASIC: JMP BASIC ; TO BASIC WITH SCRATCH
00CDB3  4  4C B3 E2     BASCONT: JMP BASIC2 ; CONTINUE BASIC
00CDB6  4  20 75 CD     GO: JSR A1PC ; ADR TO PC IF SPEC'D
00CDB9  4  20 3F CE       JSR A2_RESTORE ; RESTORE META REGS
00CDBC  4  6C 3A 00       JMP (PCL) ; GO TO USER SUBR
00CDBF  4  4C DA C9     REGZ: JMP REGDSP ; TO REG DISPLAY
00CDC2  4  C6 34        TRACE: DEC A2_YSAV
00CDC4  4  20 75 CD     STEPZ: JSR A1PC ; ADR TO PC IF SPEC'D
00CDC7  4  4C 46 C9       JMP A2_STEP ; TAKE ONE STEP
00CDCA  4  4C F8 03     A2_USR: JMP USRADR ; TO USR SUBR AT USRADR
00CDCD  4  A9 40        WRITE: LDA #$40
00CDCF  4  20 CC CB       JSR HEADR ; WRITE 10-SEC HEADER
00CDD2  4  A0 27          LDY #$27
00CDD4  4  A2 00        WR1: LDX #$00
00CDD6  4  41 3C          EOR (A1L,X)
00CDD8  4  48             PHA
00CDD9  4  A1 3C          LDA (A1L,X)
00CDDB  4  20 ED CD       JSR WRBYTE
00CDDE  4  20 BD CB       JSR NXTA1
00CDE1  4  A0 1D          LDY #$1D
00CDE3  4  68             PLA
00CDE4  4  90 EE          BCC WR1
00CDE6  4  A0 22          LDY #$22
00CDE8  4  20 ED CD       JSR WRBYTE
00CDEB  4  F0 4D          BEQ BELL
00CDED  4  A2 10        WRBYTE: LDX #$10
00CDEF  4  0A           WRBYT2: ASL A
00CDF0  4  20 D9 CB       JSR WRBIT
00CDF3  4  D0 FA          BNE WRBYT2
00CDF5  4  60             RTS
00CDF6  4  20 00 CD     CRMON: JSR BL1 ; HANDLE A CR AS BLANK
00CDF9  4  68             PLA ; THEN POP STACK
00CDFA  4  68             PLA ; AND RTN TO MON
00CDFB  4  D0 6C          BNE MONZ
00CDFD  4  20 FD CB     A2_READ: JSR RD2BIT ; FIND TAPEIN EDGE
00CE00  4  A9 16          LDA #$16
00CE02  4  20 CC CB       JSR HEADR ; DELAY 3.5 SECONDS
00CE05  4  85 2E          STA CHKSUM ; INIT CHKSUM=$FF
00CE07  4  20 FD CB       JSR RD2BIT ; FIND TAPEIN EDGE
00CE0A  4  A0 24        RD2: LDY #$24 ; LOOK FOR SYNC BIT
00CE0C  4  20 00 CC       JSR RDBIT ; (SHORT 0)
00CE0F  4  B0 F9          BCS RD2 ; LOOP UNTIL FOUND
00CE11  4  20 00 CC       JSR RDBIT ; SKIP SECOND SYNC H-CYCLE
00CE14  4  A0 3B          LDY #$3B ; INDEX FOR 0/1 TEST
00CE16  4  20 EF CB     RD3: JSR RDBYTE ; READ A BYTE
00CE19  4  81 3C          STA (A1L,X) ; STORE AT (A1)
00CE1B  4  45 2E          EOR CHKSUM
00CE1D  4  85 2E          STA CHKSUM ; UPDATE RUNNING CHKSUM
00CE1F  4  20 BD CB       JSR NXTA1 ; INC A1, COMPARE TO A2
00CE22  4  A0 35          LDY #$35 ; COMPENSATE 0/1 INDEX
00CE24  4  90 F0          BCC RD3 ; LOOP UNTIL DONE
00CE26  4  20 EF CB       JSR RDBYTE ; READ CHKSUM BYTE
00CE29  4  C5 2E          CMP CHKSUM
00CE2B  4  F0 0D          BEQ BELL ; GOOD, SOUND BELL AND RETURN
00CE2D  4  A9 C5        PRERR: LDA #$C5
00CE2F  4  20 ED CC       JSR COUT ; PRINT "ERR", THEN BELL
00CE32  4  A9 D2          LDA #$D2
00CE34  4  20 ED CC       JSR COUT
00CE37  4  20 ED CC       JSR COUT
00CE3A  4  A9 87        BELL: LDA #$87 ; OUTPUT BELL AND RETURN
00CE3C  4  4C ED CC       JMP COUT
00CE3F  4  A5 48        A2_RESTORE: LDA STATUS ; RESTORE 6502 REG CONTENTS
00CE41  4  48             PHA ; USED BY DEBUG SOFTWARE
00CE42  4  A5 45          LDA ACC
00CE44  4  A6 46        RESTR1: LDX XREG
00CE46  4  A4 47          LDY YREG
00CE48  4  28             PLP
00CE49  4  60             RTS
00CE4A  4  85 45        A2_SAVE: STA ACC ; SAVE 6502 REG CONTENTS
00CE4C  4  86 46        SAV1: STX XREG
00CE4E  4  84 47          STY YREG
00CE50  4  08             PHP
00CE51  4  68             PLA
00CE52  4  85 48          STA STATUS
00CE54  4  BA             TSX
00CE55  4  86 49          STX SPNT
00CE57  4  D8             CLD
00CE58  4  60             RTS
00CE59  4               .ifdef EATER
00CE59  4  20 78 C5     A2_RESET: JSR L8 ; SET SCREEN MODE
00CE5C  4               .else
00CE5C  4               A2_RESET: JSR SETNORM ; SET SCREEN MODE
00CE5C  4               .endif
00CE5C  4  20 32 CA       JSR INIT ; AND INIT KBD/SCREEN
00CE5F  4               .ifdef EATER
00CE5F  4  20 84 CD       JSR SETNORM ; AS I/O DEV'S
00CE62  4               .else
00CE62  4                 JSR SETVID ; AS I/O DEV'S
00CE62  4               .endif
00CE62  4  20 89 CD       JSR SETKBD
00CE65  4  D8           MON: CLD ; MUST SET HEX MODE!
00CE66  4  20 3A CE       JSR BELL
00CE69  4  A9 AA        MONZ: LDA #$AA ; '*' PROMPT FOR MON
00CE6B  4  85 33          STA PROMPT
00CE6D  4  20 67 CC       JSR GETLNZ ; READ A LINE
00CE70  4  20 C7 CE       JSR ZMODE ; CLEAR MON MODE, SCAN IDX
00CE73  4  20 A7 CE     NXTITM: JSR GETNUM ; GET ITEM, NON-HEX
00CE76  4  84 34          STY A2_YSAV ; CHAR IN A-REG
00CE78  4  A0 17          LDY #$17 ; X-REG=0 IF NO HEX INPUT
00CE7A  4  88           CHRSRCH: DEY
00CE7B  4  30 E8          BMI MON ; NOT FOUND, GO TO MON
00CE7D  4  D9 CC CE       CMP CHRTBL,Y ; FIND CMND CHAR IN TEL
00CE80  4  D0 F8          BNE CHRSRCH
00CE82  4  20 BE CE       JSR TOSUB ; FOUND, CALL CORRESPONDING
00CE85  4  A4 34          LDY A2_YSAV ; SUBROUTINE
00CE87  4  4C 73 CE       JMP NXTITM
00CE8A  4  A2 03        A2_DIG: LDX #$03
00CE8C  4  0A             ASL A
00CE8D  4  0A             ASL A ; GOT HEX DIG,
00CE8E  4  0A             ASL A ; SHIFT INTO A2
00CE8F  4  0A             ASL A
00CE90  4  0A           NXTBIT: ASL A
00CE91  4  26 3E          ROL A2L
00CE93  4  26 3F          ROL A2H
00CE95  4  CA             DEX ; LEAVE X=$FF IF DIG
00CE96  4  10 F8          BPL NXTBIT
00CE98  4  A5 31        NXTBAS: LDA A2_MODE
00CE9A  4  D0 06          BNE NXTBS2 ; IF MODE IS ZERO
00CE9C  4  B5 3F          LDA A2H,X ; THEN COPY A2 TO
00CE9E  4  95 3D          STA A1H,X ; A1 AND A3
00CEA0  4  95 41          STA A3H,X
00CEA2  4  E8           NXTBS2: INX
00CEA3  4  F0 F3          BEQ NXTBAS
00CEA5  4  D0 06          BNE NXTCHR
00CEA7  4  A2 00        GETNUM: LDX #$00 ; CLEAR A2
00CEA9  4  86 3E          STX A2L
00CEAB  4  86 3F          STX A2H
00CEAD  4  B9 00 02     NXTCHR: LDA A2_IN,Y ; GET CHAR
00CEB0  4  C8             INY
00CEB1  4  49 B0          EOR #$B0
00CEB3  4  C9 0A          CMP #$0A
00CEB5  4  90 D3          BCC A2_DIG ; IF HEX DIG, THEN
00CEB7  4  69 88          ADC #$88
00CEB9  4  C9 FA          CMP #$FA
00CEBB  4  B0 CD          BCS A2_DIG
00CEBD  4  60             RTS
00CEBE  4  A9 CD        TOSUB: LDA #>GO ; PUSH HIGH-ORDER
00CEC0  4  48             PHA ; SUBR ADR ON STK
00CEC1  4  B9 E3 CE       LDA SUBTBL,Y ; PUSH LOW-ORDER
00CEC4  4  48             PHA ; SUBR ADR ON STK
00CEC5  4  A5 31          LDA A2_MODE
00CEC7  4  A0 00        ZMODE: LDY #$00 ; CLR MODE, OLD MODE
00CEC9  4  84 31           STY A2_MODE ; TO A-REG
00CECB  4  60              RTS ; GO TO SUBR VIA RTS
00CECC  4  BC           CHRTBL: .BYTE $BC ; F("CTRL-C")
00CECD  4  B2             .BYTE $B2 ; F("CTRL-Y")
00CECE  4  BE             .BYTE $BE ; F("CTRL-E")
00CECF  4  ED             .BYTE $ED ; F("T")
00CED0  4  EF             .BYTE $EF ; F("V")
00CED1  4  C4             .BYTE $C4 ; F("CTRL-K")
00CED2  4  EC             .BYTE $EC ; F("S")
00CED3  4  A9             .BYTE $A9 ; F("CTRL-P")
00CED4  4  BB             .BYTE $BB ; F("CTRL-B")
00CED5  4  A6             .BYTE $A6 ; F("-")
00CED6  4  A4             .BYTE $A4 ; F("+")
00CED7  4  06             .BYTE $06 ; F("M") (F=EX-OR $B0+$89)
00CED8  4  95             .BYTE $95 ; F("<")
00CED9  4  07             .BYTE $07 ; F("N")
00CEDA  4  02             .BYTE $02 ; F("I")
00CEDB  4  05             .BYTE $05 ; F("L")
00CEDC  4  F0             .BYTE $F0 ; F("W")
00CEDD  4  00             .BYTE $00 ; F("G")
00CEDE  4  EB             .BYTE $EB ; F("R")
00CEDF  4  93             .BYTE $93 ; F(":")
00CEE0  4  A7             .BYTE $A7 ; F(".")
00CEE1  4  C6             .BYTE $C6 ; F("CR")
00CEE2  4  99             .BYTE $99 ; F(BLANK)
00CEE3  4               
00CEE3  4  B2           SUBTBL: .BYTE <BASCONT-1
00CEE4  4  C9             .BYTE <A2_USR-1
00CEE5  4  BE             .BYTE <REGZ-1
00CEE6  4  C1             .BYTE <TRACE-1
00CEE7  4  35             .BYTE <VFY-1
00CEE8  4  8C             .BYTE <A2_INPRT-1
00CEE9  4  C3             .BYTE <STEPZ-1
00CEEA  4  96             .BYTE <OUTPRT-1
00CEEB  4  AF             .BYTE <XBASIC-1
00CEEC  4  17             .BYTE <A2_SETMODE-1
00CEED  4  17             .BYTE <A2_SETMODE-1
00CEEE  4  2B             .BYTE <MOVE-1
00CEEF  4  1F             .BYTE <LT-1
00CEF0  4  83             .BYTE <SETNORM-1
00CEF1  4  7F             .BYTE <SETINV-1
00CEF2  4  5D             .BYTE <A2_LIST-1
00CEF3  4  CC             .BYTE <WRITE-1
00CEF4  4  B5             .BYTE <GO-1
00CEF5  4  FC             .BYTE <A2_READ-1
00CEF6  4  17             .BYTE <A2_SETMODE-1
00CEF7  4  17             .BYTE <A2_SETMODE-1
00CEF8  4  F5             .BYTE <CRMON-1
00CEF9  4  03             .BYTE <BLANK-1
00CEFA  4               
00CEFA  4               XQTNZ = $3C
00CEFA  4               
00CEFA  4               
00CEFA  3               .include "wozmon.s"
00CEFA  4               .setcpu "65C02"
00CEFA  4               .segment "WOZMON"
000000r 4               .org $FE00
00FE00  4               
00FE00  4               XAML            = $24                   ; Last "opened" location Low
00FE00  4               XAMH            = $25                   ; Last "opened" location High
00FE00  4               STL             = $26                   ; Store address Low
00FE00  4               STH             = $27                   ; Store address High
00FE00  4               L               = $28                   ; Hex value parsing Low
00FE00  4               H               = $29                   ; Hex value parsing High
00FE00  4               YSAV            = $2A                   ; Used to see if hex value is given
00FE00  4               MODE            = $2B                   ; $00=XAM, $7F=STOR, $AE=BLOCK XAM
00FE00  4               
00FE00  4               IN              = $0200                 ; Input buffer
00FE00  4               
00FE00  4               RESET:
00FE00  4  D8                           CLD                     ; Clear decimal arithmetic mode.
00FE01  4  20 rr rr                     JSR     INIT_BUFFER
00FE04  4  58                           CLI
00FE05  4  A9 1F                        LDA     #$1F            ; 8-N-1, 19200 bps
00FE07  4  8D 03 50                     STA     ACIA_CTRL
00FE0A  4  A0 89                        LDY     #$89            ; No parity, no echo, rx interrupts.
00FE0C  4  8C 02 50                     STY     ACIA_CMD
00FE0F  4               
00FE0F  4               NOTCR:
00FE0F  4  C9 08                        CMP     #$08            ; Backspace key?
00FE11  4  F0 18                        BEQ     BACKSPACE       ; Yes.
00FE13  4  C9 1B                        CMP     #$1B            ; ESC?
00FE15  4  F0 03                        BEQ     ESCAPE          ; Yes.
00FE17  4  C8                           INY                     ; Advance text index.
00FE18  4  10 14                        BPL     NEXTCHAR        ; Auto ESC if line longer than 127.
00FE1A  4               
00FE1A  4               ESCAPE:
00FE1A  4  A9 5C                        LDA     #$5C            ; "\".
00FE1C  4  20 F4 FE                     JSR     ECHO            ; Output it.
00FE1F  4               
00FE1F  4               GETLINE:
00FE1F  4  A9 0D                        LDA     #$0D            ; Send CR
00FE21  4  20 F4 FE                     JSR     ECHO
00FE24  4  A9 0A                        LDA     #$0A            ; Send LF
00FE26  4  20 F4 FE                     JSR     ECHO
00FE29  4               
00FE29  4  A0 01                        LDY     #$01            ; Initialize text index.
00FE2B  4  88           BACKSPACE:      DEY                     ; Back up text index.
00FE2C  4  30 F1                        BMI     GETLINE         ; Beyond start of line, reinitialize.
00FE2E  4               
00FE2E  4               NEXTCHAR:
00FE2E  4  20 rr rr                     JSR     CHRIN
00FE31  4  90 FB                        BCC     NEXTCHAR
00FE33  4  99 00 02                     STA     IN,Y            ; Add to text buffer.
00FE36  4  C9 0D                        CMP     #$0D            ; CR?
00FE38  4  D0 D5                        BNE     NOTCR           ; No.
00FE3A  4               
00FE3A  4  A0 FF                        LDY     #$FF            ; Reset text index.
00FE3C  4  A9 00                        LDA     #$00            ; For XAM mode.
00FE3E  4  AA                           TAX                     ; X=0.
00FE3F  4               SETBLOCK:
00FE3F  4  0A                           ASL
00FE40  4               SETSTOR:
00FE40  4  0A                           ASL                     ; Leaves $7B if setting STOR mode.
00FE41  4               SETMODE:
00FE41  4  85 2B                        STA     MODE            ; $00 = XAM, $74 = STOR, $B8 = BLOK XAM.
00FE43  4               BLSKIP:
00FE43  4  C8                           INY                     ; Advance text index.
00FE44  4               NEXTITEM:
00FE44  4  B9 00 02                     LDA     IN,Y            ; Get character.
00FE47  4  C9 0D                        CMP     #$0D            ; CR?
00FE49  4  F0 D4                        BEQ     GETLINE         ; Yes, done this line.
00FE4B  4  C9 2E                        CMP     #$2E            ; "."?
00FE4D  4  90 F4                        BCC     BLSKIP          ; Skip delimiter.
00FE4F  4  F0 EE                        BEQ     SETBLOCK        ; Set BLOCK XAM mode.
00FE51  4  C9 3A                        CMP     #$3A            ; ":"?
00FE53  4  F0 EB                        BEQ     SETSTOR         ; Yes, set STOR mode.
00FE55  4  C9 52                        CMP     #$52            ; "R"?
00FE57  4  F0 3B                        BEQ     RUNPROG         ; Yes, run user program.
00FE59  4  86 28                        STX     L               ; $00 -> L.
00FE5B  4  86 29                        STX     H               ;    and H.
00FE5D  4  84 2A                        STY     YSAV            ; Save Y for comparison
00FE5F  4               
00FE5F  4               NEXTHEX:
00FE5F  4  B9 00 02                     LDA     IN,Y            ; Get character for hex test.
00FE62  4  49 30                        EOR     #$30            ; Map digits to $0-9.
00FE64  4  C9 0A                        CMP     #$0A            ; Digit?
00FE66  4  90 06                        BCC     DIG             ; Yes.
00FE68  4  69 88                        ADC     #$88            ; Map letter "A"-"F" to $FA-FF.
00FE6A  4  C9 FA                        CMP     #$FA            ; Hex letter?
00FE6C  4  90 11                        BCC     NOTHEX          ; No, character not hex.
00FE6E  4               DIG:
00FE6E  4  0A                           ASL
00FE6F  4  0A                           ASL                     ; Hex digit to MSD of A.
00FE70  4  0A                           ASL
00FE71  4  0A                           ASL
00FE72  4               
00FE72  4  A2 04                        LDX     #$04            ; Shift count.
00FE74  4               HEXSHIFT:
00FE74  4  0A                           ASL                     ; Hex digit left, MSB to carry.
00FE75  4  26 28                        ROL     L               ; Rotate into LSD.
00FE77  4  26 29                        ROL     H               ; Rotate into MSD's.
00FE79  4  CA                           DEX                     ; Done 4 shifts?
00FE7A  4  D0 F8                        BNE     HEXSHIFT        ; No, loop.
00FE7C  4  C8                           INY                     ; Advance text index.
00FE7D  4  D0 E0                        BNE     NEXTHEX         ; Always taken. Check next character for hex.
00FE7F  4               
00FE7F  4               NOTHEX:
00FE7F  4  C4 2A                        CPY     YSAV            ; Check if L, H empty (no hex digits).
00FE81  4  F0 97                        BEQ     ESCAPE          ; Yes, generate ESC sequence.
00FE83  4               
00FE83  4  24 2B                        BIT     MODE            ; Test MODE byte.
00FE85  4  50 10                        BVC     NOTSTOR         ; B6=0 is STOR, 1 is XAM and BLOCK XAM.
00FE87  4               
00FE87  4  A5 28                        LDA     L               ; LSD's of hex data.
00FE89  4  81 26                        STA     (STL,X)         ; Store current 'store index'.
00FE8B  4  E6 26                        INC     STL             ; Increment store index.
00FE8D  4  D0 B5                        BNE     NEXTITEM        ; Get next item (no carry).
00FE8F  4  E6 27                        INC     STH             ; Add carry to 'store index' high order.
00FE91  4  4C 44 FE     TONEXTITEM:     JMP     NEXTITEM        ; Get next command item.
00FE94  4               
00FE94  4               RUNPROG:
00FE94  4  6C 24 00                     JMP     (XAML)          ; Run at current XAM index.
00FE97  4               
00FE97  4               NOTSTOR:
00FE97  4  30 30                        BMI     XAMNEXT         ; B7 = 0 for XAM, 1 for BLOCK XAM.
00FE99  4               
00FE99  4  A2 02                        LDX     #$02            ; Byte count.
00FE9B  4  B5 27        SETADR:         LDA     L-1,X           ; Copy hex data to
00FE9D  4  95 25                        STA     STL-1,X         ;  'store index'.
00FE9F  4  95 23                        STA     XAML-1,X        ; And to 'XAM index'.
00FEA1  4  CA                           DEX                     ; Next of 2 bytes.
00FEA2  4  D0 F7                        BNE     SETADR          ; Loop unless X = 0.
00FEA4  4               
00FEA4  4               NXTPRNT:
00FEA4  4  D0 19                        BNE     PRDATA          ; NE means no address to print.
00FEA6  4  A9 0D                        LDA     #$0D            ; CR.
00FEA8  4  20 F4 FE                     JSR     ECHO            ; Output it.
00FEAB  4  A9 0A                        LDA     #$0A            ; LF.
00FEAD  4  20 F4 FE                     JSR     ECHO            ; Output it.
00FEB0  4  A5 25                        LDA     XAMH            ; 'Examine index' high-order byte.
00FEB2  4  20 E1 FE                     JSR     PRBYTE          ; Output it in hex format.
00FEB5  4  A5 24                        LDA     XAML            ; Low-order 'examine index' byte.
00FEB7  4  20 E1 FE                     JSR     PRBYTE          ; Output it in hex format.
00FEBA  4  A9 3A                        LDA     #$3A            ; ":".
00FEBC  4  20 F4 FE                     JSR     ECHO            ; Output it.
00FEBF  4               
00FEBF  4               PRDATA:
00FEBF  4  A9 20                        LDA     #$20            ; Blank.
00FEC1  4  20 F4 FE                     JSR     ECHO            ; Output it.
00FEC4  4  A1 24                        LDA     (XAML,X)        ; Get data byte at 'examine index'.
00FEC6  4  20 E1 FE                     JSR     PRBYTE          ; Output it in hex format.
00FEC9  4  86 2B        XAMNEXT:        STX     MODE            ; 0 -> MODE (XAM mode).
00FECB  4  A5 24                        LDA     XAML
00FECD  4  C5 28                        CMP     L               ; Compare 'examine index' to hex data.
00FECF  4  A5 25                        LDA     XAMH
00FED1  4  E5 29                        SBC     H
00FED3  4  B0 BC                        BCS     TONEXTITEM      ; Not less, so no more data to output.
00FED5  4               
00FED5  4  E6 24                        INC     XAML
00FED7  4  D0 02                        BNE     MOD8CHK         ; Increment 'examine index'.
00FED9  4  E6 25                        INC     XAMH
00FEDB  4               
00FEDB  4               MOD8CHK:
00FEDB  4  A5 24                        LDA     XAML            ; Check low-order 'examine index' byte
00FEDD  4  29 07                        AND     #$07            ; For MOD 8 = 0
00FEDF  4  10 C3                        BPL     NXTPRNT         ; Always taken.
00FEE1  4               
00FEE1  4               PRBYTE:
00FEE1  4  48                           PHA                     ; Save A for LSD.
00FEE2  4  4A                           LSR
00FEE3  4  4A                           LSR
00FEE4  4  4A                           LSR                     ; MSD to LSD position.
00FEE5  4  4A                           LSR
00FEE6  4  20 EA FE                     JSR     PRHEX           ; Output hex digit.
00FEE9  4  68                           PLA                     ; Restore A.
00FEEA  4               
00FEEA  4               PRHEX:
00FEEA  4  29 0F                        AND     #$0F            ; Mask LSD for hex print.
00FEEC  4  09 30                        ORA     #$30            ; Add "0".
00FEEE  4  C9 3A                        CMP     #$3A            ; Digit?
00FEF0  4  90 02                        BCC     ECHO            ; Yes, output it.
00FEF2  4  69 06                        ADC     #$06            ; Add offset for letter.
00FEF4  4               
00FEF4  4               ECHO:
00FEF4  4  8D 00 50                     STA     ACIA_DATA       ; Output character.
00FEF7  4  48                           PHA                     ; Save A.
00FEF8  4  A9 01                        LDA     #DELAY            ; Initialize delay loop.
00FEFA  4  3A           TXDELAY:        DEC                     ; Decrement A.
00FEFB  4  D0 FD                        BNE     TXDELAY         ; Until A gets to 0.
00FEFD  4  68                           PLA                     ; Restore A.
00FEFE  4  60                           RTS                     ; Return.
00FEFF  4               
00FEFF  4               
00FEFF  4               
00FEFF  3               
00FEFF  3               .segment "RESETVEC"
000000r 3  00 0F                        .word   $0F00           ; NMI vector
000002r 3  00 FE                        .word   RESET           ; RESET vector
000004r 3  rr rr                        .word   IRQ_HANDLER     ; IRQ vector
000006r 3               
000006r 3               
000006r 2               .endif
000006r 2               
000006r 1               .include "lcd.s"
000006r 2               .segment "CODE"
001C9Ar 2               .ifdef EATER
001C9Ar 2               PORTB = $6000
001C9Ar 2               DDRB = $6002
001C9Ar 2               E  = %01000000
001C9Ar 2               RW = %00100000
001C9Ar 2               RS = %00010000
001C9Ar 2               
001C9Ar 2               lcd_wait:
001C9Ar 2  48             pha
001C9Br 2  A9 F0          lda #%11110000  ; LCD data is input
001C9Dr 2  8D 02 60       sta DDRB
001CA0r 2               lcdbusy:
001CA0r 2  A9 20          lda #RW
001CA2r 2  8D 00 60       sta PORTB
001CA5r 2  A9 60          lda #(RW | E)
001CA7r 2  8D 00 60       sta PORTB
001CAAr 2  AD 00 60       lda PORTB       ; Read high nibble
001CADr 2  48             pha             ; and put on stack since it has the busy flag
001CAEr 2  A9 20          lda #RW
001CB0r 2  8D 00 60       sta PORTB
001CB3r 2  A9 60          lda #(RW | E)
001CB5r 2  8D 00 60       sta PORTB
001CB8r 2  AD 00 60       lda PORTB       ; Read low nibble
001CBBr 2  68             pla             ; Get high nibble off stack
001CBCr 2  29 08          and #%00001000
001CBEr 2  D0 E0          bne lcdbusy
001CC0r 2               
001CC0r 2  A9 20          lda #RW
001CC2r 2  8D 00 60       sta PORTB
001CC5r 2  A9 FF          lda #%11111111  ; LCD data is output
001CC7r 2  8D 02 60       sta DDRB
001CCAr 2  68             pla
001CCBr 2  60             rts
001CCCr 2               
001CCCr 2               LCDINIT:
001CCCr 2  A9 FF          lda #$ff ; Set all pins on port B to output
001CCEr 2  8D 02 60       sta DDRB
001CD1r 2               
001CD1r 2  A9 03          lda #%00000011 ; Set 8-bit mode
001CD3r 2  8D 00 60       sta PORTB
001CD6r 2  09 40          ora #E
001CD8r 2  8D 00 60       sta PORTB
001CDBr 2  29 0F          and #%00001111
001CDDr 2  8D 00 60       sta PORTB
001CE0r 2               
001CE0r 2  A9 03          lda #%00000011 ; Set 8-bit mode
001CE2r 2  8D 00 60       sta PORTB
001CE5r 2  09 40          ora #E
001CE7r 2  8D 00 60       sta PORTB
001CEAr 2  29 0F          and #%00001111
001CECr 2  8D 00 60       sta PORTB
001CEFr 2               
001CEFr 2  A9 03          lda #%00000011 ; Set 8-bit mode
001CF1r 2  8D 00 60       sta PORTB
001CF4r 2  09 40          ora #E
001CF6r 2  8D 00 60       sta PORTB
001CF9r 2  29 0F          and #%00001111
001CFBr 2  8D 00 60       sta PORTB
001CFEr 2               
001CFEr 2                 ; Okay, now we're really in 8-bit mode.
001CFEr 2                 ; Command to get to 4-bit mode ought to work now
001CFEr 2  A9 02          lda #%00000010 ; Set 4-bit mode
001D00r 2  8D 00 60       sta PORTB
001D03r 2  09 40          ora #E
001D05r 2  8D 00 60       sta PORTB
001D08r 2  29 0F          and #%00001111
001D0Ar 2  8D 00 60       sta PORTB
001D0Dr 2               
001D0Dr 2  A9 28          lda #%00101000 ; Set 4-bit mode; 2-line display; 5x8 font
001D0Fr 2  20 rr rr       jsr lcd_instruction
001D12r 2  A9 0E          lda #%00001110 ; Display on; cursor on; blink off
001D14r 2  20 rr rr       jsr lcd_instruction
001D17r 2  A9 06          lda #%00000110 ; Increment and shift cursor; don't shift display
001D19r 2  20 rr rr       jsr lcd_instruction
001D1Cr 2  A9 01          lda #%00000001 ; Clear display
001D1Er 2  20 rr rr       jsr lcd_instruction
001D21r 2  60             rts
001D22r 2               
001D22r 2               
001D22r 2               LCDCMD:
001D22r 2  20 rr rr       jsr GETBYT
001D25r 2  8A             txa
001D26r 2               lcd_instruction:
001D26r 2  20 rr rr       jsr lcd_wait
001D29r 2  48             pha
001D2Ar 2  4A             lsr
001D2Br 2  4A             lsr
001D2Cr 2  4A             lsr
001D2Dr 2  4A             lsr            ; Send high 4 bits
001D2Er 2  8D 00 60       sta PORTB
001D31r 2  09 40          ora #E         ; Set E bit to send instruction
001D33r 2  8D 00 60       sta PORTB
001D36r 2  49 40          eor #E         ; Clear E bit
001D38r 2  8D 00 60       sta PORTB
001D3Br 2  68             pla
001D3Cr 2  29 0F          and #%00001111 ; Send low 4 bits
001D3Er 2  8D 00 60       sta PORTB
001D41r 2  09 40          ora #E         ; Set E bit to send instruction
001D43r 2  8D 00 60       sta PORTB
001D46r 2  49 40          eor #E         ; Clear E bit
001D48r 2  8D 00 60       sta PORTB
001D4Br 2  60             rts
001D4Cr 2               
001D4Cr 2               LCDPRINT:
001D4Cr 2  20 rr rr       jsr GETBYT
001D4Fr 2  8A             txa
001D50r 2  20 rr rr       jsr lcd_wait
001D53r 2  48             pha
001D54r 2  4A             lsr
001D55r 2  4A             lsr
001D56r 2  4A             lsr
001D57r 2  4A             lsr             ; Send high 4 bits
001D58r 2  09 10          ora #RS         ; Set RS
001D5Ar 2  8D 00 60       sta PORTB
001D5Dr 2  09 40          ora #E          ; Set E bit to send instruction
001D5Fr 2  8D 00 60       sta PORTB
001D62r 2  49 40          eor #E          ; Clear E bit
001D64r 2  8D 00 60       sta PORTB
001D67r 2  68             pla
001D68r 2  29 0F          and #%00001111  ; Send low 4 bits
001D6Ar 2  09 10          ora #RS         ; Set RS
001D6Cr 2  8D 00 60       sta PORTB
001D6Fr 2  09 40          ora #E          ; Set E bit to send instruction
001D71r 2  8D 00 60       sta PORTB
001D74r 2  49 40          eor #E          ; Clear E bit
001D76r 2  8D 00 60       sta PORTB
001D79r 2  60             rts
001D7Ar 2               
001D7Ar 2               .endif
001D7Ar 2               
001D7Ar 1               
