ca65 V2.19 - Git 3dfe03300
Main file   : appleiimonitor-serial.s
Current file: appleiimonitor-serial.s

000000r 1               .segment "APPLE2_MON"
000000r 1               ; Port of Apple II monitor to Apple 1
000000r 1               ;
000000r 1               ; Original port by Winston Gayler with additional adaptations by
000000r 1               ; Wendell Sander. Source code reverse-engineered and ported to CA65
000000r 1               ; assembler by Jeff Tranter <tranter@pobox.com>.
000000r 1               
000000r 1               ; Define to get Apple 1 version, otherwise generates original Apple II
000000r 1               ; code.
000000r 1               APPLE1 = 1
000000r 1               ACE_DATA  = $A000   ; Serial data register
000000r 1               ACE_LSR   = $A005   ; Line status register
000000r 1               
000000r 1               ; Define if you want the Apple 1 Woz Monitor included in the build. Only
000000r 1               ; works if start address is $F400.
000000r 1               ;WOZMON = 1
000000r 1               
000000r 1               ; Macro to define a string in ASCII with high bit set on each character.
000000r 1               .macro Str Arg
000000r 1                   .repeat .strlen(Arg), I
000000r 1                   .byte   .strat(Arg, I) | $80
000000r 1                   .endrep
000000r 1               .endmacro
000000r 1               
000000r 1               ; ***********************
000000r 1               ; *                     *
000000r 1               ; * APPLE-II            *
000000r 1               ; * MINI-ASSEMBLER      *
000000r 1               ; *                     *
000000r 1               ; * COPYRIGHT 1977 BY   *
000000r 1               ; * APPLE COMPUTER INC. *
000000r 1               ; *                     *
000000r 1               ; * ALL RIGHTS RESERVED *
000000r 1               ; *                     *
000000r 1               ; * S. WOZNIAK          *
000000r 1               ; * A. BAUM             *
000000r 1               ; ***********************
000000r 1               ; TITLE "APPLE-II MINI-ASSEMBLER"
000000r 1               FORMAT = $2E
000000r 1               LENGTH = $2F
000000r 1               MODE =   $31
000000r 1               PROMPT = $33
000000r 1               YSAV =   $34
000000r 1               L =      $35
000000r 1               PCL =    $3A
000000r 1               PCH =    $3B
000000r 1               A1H =    $3D
000000r 1               A2L =    $3E
000000r 1               A2H =    $3F
000000r 1               A4L =    $42
000000r 1               A4H =    $43
000000r 1               FMT =    $44
000000r 1               IN =     $200
000000r 1               ; INSDS2 = $F88E
000000r 1               ; INSTDSP = $F8D0
000000r 1               ; PRBL2 =  $F94A
000000r 1               ; PCADJ =  $F953
000000r 1               ; CHAR1 =  $F9B4
000000r 1               ; CHAR2 =  $F9BA
000000r 1               ; MNEML =  $F9C0
000000r 1               ; MNEMR =  $FA00
000000r 1               CURSUP = $FC1A
000000r 1               ; GETLNZ = $FD67
000000r 1               ; COUT =   $FDED
000000r 1               ; BL1 =    $FE00
000000r 1               ; A1PCLP = $FE78
000000r 1               ; BELL =   $FF3A
000000r 1               ; GETNUM = $FFA7
000000r 1               ; TOSUB =  $FFBE
000000r 1               ; ZMODE =  $FFC7
000000r 1               ; CHRTBL = $FFCC
000000r 1               
000000r 1               .ifdef APPLE1
000000r 1               ;  .org $3500
000000r 1               ;  .org $6500
000000r 1               ;  .org $7500
000000r 1               ;  .org $B500
000000r 1               ;  .org $F400
000000r 1                  .org $C400
00C400  1               .else
00C400  1                 .org $F500
00C400  1               .endif
00C400  1               
00C400  1                 .export MON
00C400  1                 .export REL
00C400  1               
00C400  1  E9 81        REL: SBC #$81 ; IS FMT COMPATIBLE
00C402  1  4A             LSR ; WITH RELATIVE MODE?
00C403  1  D0 14          BNE ERR3 ; NO.
00C405  1  A4 3F          LDY A2H
00C407  1  A6 3E          LDX A2L ; DOUBLE DECREMENT
00C409  1  D0 01          BNE REL2
00C40B  1  88             DEY
00C40C  1  CA           REL2: DEX
00C40D  1  8A             TXA
00C40E  1  18             CLC
00C40F  1  E5 3A          SBC PCL ; FORM ADDR-PC-2
00C411  1  85 3E          STA A2L
00C413  1  10 01          BPL REL3
00C415  1  C8             INY
00C416  1  98           REL3: TYA
00C417  1  E5 3B          SBC PCH
00C419  1  D0 6B        ERR3: BNE ERR ; ERROR IF >1-BYTE BRANCH
00C41B  1  A4 2F        FINDOP: LDY LENGTH
00C41D  1  B9 3D 00     FNDOP2: LDA A1H,Y ; MOVE INST TO (PC)
00C420  1  91 3A          STA (PCL),Y
00C422  1  88             DEY
00C423  1  10 F8          BPL FNDOP2
00C425  1  EA             NOP
00C426  1  EA             NOP
00C427  1  EA             NOP
00C428  1  EA             NOP
00C429  1  EA             NOP
00C42A  1  EA             NOP
00C42B  1               ; JSR CURSUP
00C42B  1               ; JSR CURSUP ; RESTORE CURSOR
00C42B  1  20 CE C7       JSR INSTDSP ; TYPE FORMATTED LINE
00C42E  1  20 51 C8       JSR PCADJ ; UPDATE PC
00C431  1  84 3B          STY PCH
00C433  1  85 3A          STA PCL
00C435  1  4C 95 C4       JMP NXTLINE ; GET NEXT LINE
00C438  1  20 BE CE     FAKEMON3: JSR TOSUB ; GO TO DELIM HANDLER
00C43B  1  A4 34          LDY YSAV ; RESTORE Y-INDEX
00C43D  1  20 A7 CE     FAKEMON: JSR GETNUM ; READ PARAM
00C440  1  84 34          STY YSAV ; SAVE Y-INDEX
00C442  1  A0 17          LDY #$17 ; INIT DELIMITER INDEX
00C444  1  88           FAKEMON2: DEY ; CHECK NEXT DELIM
00C445  1  30 4B          BMI RESETZ ; ERR IF UNRECOGNIZED DELIM
00C447  1  D9 CC CE       CMP CHRTBL,Y ; COMPARE WITH DELIM TABLE
00C44A  1  D0 F8          BNE FAKEMON2 ; NO MATCH
00C44C  1  C0 15          CPY #$15 ; MATCH, IS IT CR
00C44E  1  D0 E8          BNE FAKEMON3 ; NO, HANDLE IT IN MONITOR
00C450  1  A5 31          LDA MODE
00C452  1  A0 00          LDY #$0
00C454  1  C6 34          DEC YSAV
00C456  1  20 00 CD       JSR BL1 ; HANDLE CR OUTSIDE MONITOR
00C459  1  4C 95 C4       JMP NXTLINE
00C45C  1  A5 3D        TRYNEXT: LDA A1H ; GET TRIAL OPCODE
00C45E  1               .ifdef APPLE1
00C45E  1  20 6B C5       JSR L6 ; GET FMT+LENGTH FOR OPCODE
00C461  1               .else
00C461  1                 JSR INSDS2 ; GET FMT+LENGTH FOR OPCODE
00C461  1               .endif
00C461  1  AA             TAX
00C462  1  BD FE C8       LDA MNEMR,X ; GET LOWER MNEMONIC BYTE
00C465  1  C5 42          CMP A4L ; MATCH?
00C467  1  D0 13          BNE NEXTOP ; NO, TRY NEXT OPCODE.
00C469  1  BD BE C8       LDA MNEML,X ; GET UPPER MNEMONIC BYTE
00C46C  1  C5 43          CMP A4H ; MATCH?
00C46E  1  D0 0C          BNE NEXTOP ; NO, TRY NEXT OPCODE
00C470  1  A5 44          LDA FMT
00C472  1  A4 2E          LDY FORMAT ; GET TRIAL FORMAT
00C474  1  C0 9D          CPY #$9D ; TRIAL FORMAT RELATIVE?
00C476  1  F0 88          BEQ REL ; YES.
00C478  1  C5 2E        NREL: CMP FORMAT ; SAME FORMAT?
00C47A  1  F0 9F          BEQ FINDOP ; YES.
00C47C  1  C6 3D        NEXTOP: DEC A1H ; NO, TRY NEXT OPCODE
00C47E  1  D0 DC          BNE TRYNEXT
00C480  1  E6 44          INC FMT ; NO MORE, TRY WITH LEN=2
00C482  1  C6 35          DEC L ; WAS L=2 ALREADY?
00C484  1  F0 D6          BEQ TRYNEXT ; NO.
00C486  1  A4 34        ERR: LDY YSAV ; YES, UNRECOGNIZED INST.
00C488  1  98           ERR2: TYA
00C489  1  AA             TAX
00C48A  1  20 48 C8       JSR PRBL2 ; PRINT ^ UNDER LAST READ
00C48D  1  A9 DE          LDA #$DE ; CHAR TO INDICATE ERROR
00C48F  1  20 ED CC       JSR COUT ; POSITION.
00C492  1  20 3A CE     RESETZ: JSR BELL
00C495  1  A9 A1        NXTLINE: LDA #$A1 ; '!'
00C497  1  85 33          STA PROMPT ; INITIALIZE PROMPT
00C499  1  20 67 CC       JSR GETLNZ ; GET LINE.
00C49C  1  20 C7 CE       JSR ZMODE ; INIT SCREEN STUFF
00C49F  1  AD 00 02       LDA IN ; GET CHAR
00C4A2  1  C9 A0          CMP #$A0 ; ASCII BLANK?
00C4A4  1  F0 13          BEQ SPACE ; YES
00C4A6  1  C8             INY
00C4A7  1  C9 A4          CMP #$A4 ; ASCII '$' IN COL 1?
00C4A9  1  F0 92          BEQ FAKEMON ; YES, SIMULATE MONITOR
00C4AB  1  88             DEY ; NO, BACKUP A CHAR
00C4AC  1  20 A7 CE       JSR GETNUM ; GET A NUMBER
00C4AF  1  C9 93          CMP #$93 ; ':' TERMINATOR?
00C4B1  1  D0 D5        ERR4: BNE ERR2 ; NO, ERR.
00C4B3  1  8A             TXA
00C4B4  1  F0 D2          BEQ ERR2 ; NO ADR PRECEDING COLON.
00C4B6  1  20 78 CD       JSR A1PCLP ; MOVE ADR TO PCL, PCH.
00C4B9  1  A9 03        SPACE: LDA #$3 ; COUNT OF CHARS IN MNEMONIC
00C4BB  1  85 3D          STA A1H
00C4BD  1  20 34 C5     NXTMN: JSR GETNSP ; GET FIRST MNEM CHAR.
00C4C0  1  0A           NXTM: ASL A
00C4C1  1  E9 BE          SBC #$BE ; SUBTRACT OFFSET
00C4C3  1  C9 C2          CMP #$C2 ; LEGAL CHAR?
00C4C5  1  90 C1          BCC ERR2 ; NO.
00C4C7  1  0A             ASL A ; COMPRESS-LEFT JUSTIFY
00C4C8  1  0A             ASL A
00C4C9  1  A2 04          LDX #$4
00C4CB  1  0A           NXTM2: ASL A ; DO 5 TRIPLE WORD SHIFTS
00C4CC  1  26 42          ROL A4L
00C4CE  1  26 43          ROL A4H
00C4D0  1  CA             DEX
00C4D1  1  10 F8          BPL NXTM2
00C4D3  1  C6 3D          DEC A1H ; DONE WITH 3 CHARS?
00C4D5  1  F0 F4          BEQ NXTM2 ; YES, BUT DO 1 MORE SHIFT
00C4D7  1  10 E4          BPL NXTMN ; NO
00C4D9  1  A2 05        FORM1: LDX #$5 ; 5 CHARS IN ADDR MODE
00C4DB  1  20 34 C5     FORM2: JSR GETNSP ; GET FIRST CHAR OF ADDR
00C4DE  1  84 34          STY YSAV
00C4E0  1  DD B2 C8       CMP CHAR1,X ; FIRST CHAR MATCH PATTERN?
00C4E3  1  D0 13          BNE FORM3 ; NO
00C4E5  1  20 34 C5       JSR GETNSP ; YES, GET SECOND CHAR
00C4E8  1  DD B8 C8       CMP CHAR2,X ; MATCHES SECOND HALF?
00C4EB  1  F0 0D          BEQ FORM5 ; YES.
00C4ED  1  BD B8 C8       LDA CHAR2,X ; NO, IS SECOND HALF ZERO?
00C4F0  1  F0 07          BEQ FORM4 ; YES.
00C4F2  1  C9 A4          CMP #$A4 ; NO,SECOND HALF OPTIONAL?
00C4F4  1  F0 03          BEQ FORM4 ; YES.
00C4F6  1  A4 34          LDY YSAV
00C4F8  1  18           FORM3: CLC ; CLEAR BIT-NO MATCH
00C4F9  1  88           FORM4: DEY ; BACK UP 1 CHAR
00C4FA  1  26 44        FORM5: ROL FMT ; FORM FORMAT BYTE
00C4FC  1  E0 03          CPX #$3 ; TIME TO CHECK FOR ADDR.
00C4FE  1  D0 0D          BNE FORM7 ; NO
00C500  1  20 A7 CE       JSR GETNUM ; YES
00C503  1  A5 3F          LDA A2H
00C505  1  F0 01          BEQ FORM6 ; HIGH-ORDER BYTE ZERO
00C507  1  E8             INX ; NO, INCR FOR 2-BYTE
00C508  1  86 35        FORM6: STX L ; STORE LENGTH
00C50A  1  A2 03          LDX #$3 ; RELOAD FORMAT INDEX
00C50C  1  88             DEY ; BACKUP A CHAR
00C50D  1  86 3D        FORM7: STX A1H ; SAVE INDEX
00C50F  1  CA             DEX ; DONE WITH FORMAT CHECK?
00C510  1  10 C9          BPL FORM2 ; NO.
00C512  1  A5 44          LDA FMT ; YES, PUT LENGTH
00C514  1  0A             ASL A ; IN LOW BITS
00C515  1  0A             ASL A
00C516  1  05 35          ORA L
00C518  1  C9 20          CMP #$20
00C51A  1  B0 06          BCS FORM8 ; ADD "$" IF NONZERO LENGTH
00C51C  1  A6 35          LDX L ; AND DON'T ALREADY HAVE IT
00C51E  1  F0 02          BEQ FORM8
00C520  1  09 80          ORA #$80
00C522  1  85 44        FORM8: STA FMT
00C524  1  84 34          STY YSAV
00C526  1  B9 00 02       LDA IN,Y ; GET NEXT NONBLANK
00C529  1  C9 BB          CMP #$BB ; '' START OF COMMENT?
00C52B  1  F0 04          BEQ FORM9 ; YES
00C52D  1  C9 8D          CMP #$8D ; CARRIAGE RETURN?
00C52F  1  D0 80          BNE ERR4 ; NO, ERR.
00C531  1  4C 5C C4     FORM9: JMP TRYNEXT
00C534  1  B9 00 02     GETNSP: LDA IN,Y
00C537  1  C8             INY
00C538  1  C9 A0          CMP #$A0 ; GET NEXT NON BLANK CHAR
00C53A  1  F0 F8          BEQ GETNSP
00C53C  1  60             RTS
00C53D  1               
00C53D  1               ; Add filler bytes so that the Mini-Assembler starts at the documented
00C53D  1               ; entry point at address $F666
00C53D  1  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C541  1  FF FF FF FF  
00C545  1  FF FF FF FF  
00C54D  1  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C551  1  FF FF FF FF  
00C555  1  FF FF FF FF  
00C55D  1  FF           .byte $FF
00C55E  1               
00C55E  1               .ifndef APPLE1
00C55E  1               
00C55E  1               .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00C55E  1               
00C55E  1               MINIASM:  JMP   RESETZ
00C55E  1               .endif
00C55E  1               
00C55E  1               ; Apple 1 specific code
00C55E  1               .ifdef APPLE1
00C55E  1  A1 3A          LDA   ($3A,X)
00C560  1  A8             TAY
00C561  1  4A             LSR
00C562  1  90 06          BCC   L0+1
00C564  1  4A             LSR
00C565  1  09             .BYTE $09 ; ORA #
00C566  1  4C 92 C4     MINIASM:  JMP   RESETZ
00C569  1  A1 3A        L0: LDA ($3A,X)
00C56B  1  A8           L6: TAY
00C56C  1  4A             LSR A
00C56D  1  90 06          BCC L1
00C56F  1  4A             LSR A
00C570  1  09 80          ORA #$80
00C572  1  4C 91 C7       JMP   INSDS2
00C575  1  4C 99 C7     L1: JMP   IEVEN
00C578  1               L8:
00C578  1                 ;LDA   #$7F ; Initialize 6820
00C578  1                 ;STA   $D012
00C578  1                 ;LDX   #$A7
00C578  1                 ;STX   $D011
00C578  1                 ;STX   $D013
00C578  1                 ;LDX   #$8B ; Initialize Serial Card 300 Baud
00C578  1                 ;STX   $D004
00C578  1                 ;LDX   #$96
00C578  1                 ;STX   $D005
00C578  1  60             RTS
00C579  1               L3: ; BIT   $D012 ; Character Out
00C579  1  48             PHA                    ; Save A.
00C57A  1               TX_WAIT:
00C57A  1  AD 05 A0       LDA     ACE_LSR
00C57D  1  29 20          AND     #$20           ; Is TX buffer empty?
00C57F  1  F0 F9          BEQ     TX_WAIT        ; Yes, wait for TX buffer to be empty
00C581  1               
00C581  1  68             PLA
00C582  1  29 7F          AND     #$7F            ; Clear high bit
00C584  1  8D 00 A0       STA     ACE_DATA       ; Output character.
00C587  1               
00C587  1               ; L2: BMI   L3
00C587  1               ;  STA   $D012
00C587  1  60             RTS
00C588  1               L7:
00C588  1  09 80          ORA   #$80 ; Set high bit
00C58A  1  C9 9B          CMP   #$9B ; Use Esc for line kill
00C58C  1  D0 02          BNE   L4
00C58E  1  A9 98          LDA   #$98
00C590  1  C9 88        L4: CMP   #$88 ; Use Control h for Backspace
00C592  1  D0 02          BNE   L5
00C594  1  A9 DF          LDA   #$DF ; Underscore out
00C596  1               .ifdef WOZMON
00C596  1                 CMP #$91   ; Control-Q typed?
00C596  1                 BNE L5     ; If so, jump to WozMon
00C596  1                 JMP RESET
00C596  1               .endif
00C596  1  60           L5:  RTS
00C597  1               .ifdef WOZMON
00C597  1                 NOP
00C597  1                 NOP
00C597  1                 NOP
00C597  1               .endif
00C597  1               
00C597  1               ; 346 filler bytes in place of SWEET16 code
00C597  1               
00C597  1               .ifndef WOZMON
00C597  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C59B  1  00 00 00 00  
00C59F  1  00 00        
00C5A1  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C5A5  1  00 00 00 00  
00C5A9  1  00 00        
00C5AB  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C5AF  1  00 00 00 00  
00C5B3  1  00 00        
00C5B5  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C5B9  1  00 00 00 00  
00C5BD  1  00 00        
00C5BF  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C5C3  1  00 00 00 00  
00C5C7  1  00 00        
00C5C9  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C5CD  1  00 00 00 00  
00C5D1  1  00 00        
00C5D3  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C5D7  1  00 00 00 00  
00C5DB  1  00 00        
00C5DD  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C5E1  1  00 00 00 00  
00C5E5  1  00 00        
00C5E7  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C5EB  1  00 00 00 00  
00C5EF  1  00 00        
00C5F1  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C5F5  1  00 00 00 00  
00C5F9  1  00 00        
00C5FB  1               
00C5FB  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C5FF  1  00 00 00 00  
00C603  1  00 00        
00C605  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C609  1  00 00 00 00  
00C60D  1  00 00        
00C60F  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C613  1  00 00 00 00  
00C617  1  00 00        
00C619  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C61D  1  00 00 00 00  
00C621  1  00 00        
00C623  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C627  1  00 00 00 00  
00C62B  1  00 00        
00C62D  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C631  1  00 00 00 00  
00C635  1  00 00        
00C637  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C63B  1  00 00 00 00  
00C63F  1  00 00        
00C641  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C645  1  00 00 00 00  
00C649  1  00 00        
00C64B  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C64F  1  00 00 00 00  
00C653  1  00 00        
00C655  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C659  1  00 00 00 00  
00C65D  1  00 00        
00C65F  1               
00C65F  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C663  1  00 00 00 00  
00C667  1  00 00        
00C669  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C66D  1  00 00 00 00  
00C671  1  00 00        
00C673  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C677  1  00 00 00 00  
00C67B  1  00 00        
00C67D  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C681  1  00 00 00 00  
00C685  1  00 00        
00C687  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C68B  1  00 00 00 00  
00C68F  1  00 00        
00C691  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C695  1  00 00 00 00  
00C699  1  00 00        
00C69B  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C69F  1  00 00 00 00  
00C6A3  1  00 00        
00C6A5  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C6A9  1  00 00 00 00  
00C6AD  1  00 00        
00C6AF  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C6B3  1  00 00 00 00  
00C6B7  1  00 00        
00C6B9  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C6BD  1  00 00 00 00  
00C6C1  1  00 00        
00C6C3  1               
00C6C3  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C6C7  1  00 00 00 00  
00C6CB  1  00 00        
00C6CD  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C6D1  1  00 00 00 00  
00C6D5  1  00 00        
00C6D7  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C6DB  1  00 00 00 00  
00C6DF  1  00 00        
00C6E1  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00C6E5  1  00 00 00 00  
00C6E9  1  00 00        
00C6EB  1  00 00 00 00  .byte 0,0,0,0,0,0
00C6EF  1  00 00        
00C6F1  1               
00C6F1  1               ; The8BitEnthusiast: additional 15 bytes
00C6F1  1  00 00 00 00    .byte 0,0,0,0,0,0,0,0,0,0,0,0,0
00C6F5  1  00 00 00 00  
00C6F9  1  00 00 00 00  
00C6FE  1               
00C6FE  1               
00C6FE  1               
00C6FE  1               .else
00C6FE  1               
00C6FE  1               ; 336 filler bytes in place of SWEET16 code
00C6FE  1               
00C6FE  1               .byte 0,0,0,0,0,0,0,0,0,0
00C6FE  1               .byte 0,0,0,0,0,0,0,0,0,0
00C6FE  1               .byte 0,0,0,0,0,0,0,0,0,0
00C6FE  1               .byte 0,0,0,0,0,0,0,0,0,0
00C6FE  1               .byte 0,0,0,0,0,0,0,0,0,0
00C6FE  1               .byte 0,0,0,0,0,0,0,0,0,0
00C6FE  1               .byte 0,0,0,0,0,0,0,0,0,0
00C6FE  1               .byte 0,0,0,0,0,0,0,0,0,0
00C6FE  1               .byte 0,0,0,0,0,0,0,0,0,0
00C6FE  1               .byte 0,0,0,0,0,0,0,0,0,0
00C6FE  1               
00C6FE  1               .byte 0,0,0,0,0,0,0,0,0,0
00C6FE  1               .byte 0,0,0,0,0,0,0,0,0,0
00C6FE  1               .byte 0,0,0,0,0,0,0,0,0,0
00C6FE  1               .byte 0,0,0,0,0,0,0,0,0,0
00C6FE  1               .byte 0,0,0,0,0,0,0,0,0,0
00C6FE  1               .byte 0,0,0,0,0,0,0,0,0,0
00C6FE  1               .byte 0,0,0,0,0,0,0,0,0,0
00C6FE  1               .byte 0,0,0,0,0,0,0,0,0,0
00C6FE  1               .byte 0,0,0,0,0,0,0,0,0,0
00C6FE  1               .byte 0,0,0,0,0,0,0,0,0,0
00C6FE  1               
00C6FE  1               .byte 0,0,0,0,0,0,0,0,0,0
00C6FE  1               .byte 0,0,0,0,0,0,0,0,0,0
00C6FE  1               .byte 0,0,0,0,0,0,0,0,0,0
00C6FE  1               .byte 0,0,0,0,0,0,0,0,0,0
00C6FE  1               .byte 0,0,0,0,0,0,0,0,0,0
00C6FE  1               .byte 0,0,0,0,0,0,0,0,0,0
00C6FE  1               .byte 0,0,0,0,0,0,0,0,0,0
00C6FE  1               .byte 0,0,0,0,0,0,0,0,0,0
00C6FE  1               .byte 0,0,0,0,0,0,0,0,0,0
00C6FE  1               .byte 0,0,0,0,0,0,0,0,0,0
00C6FE  1               
00C6FE  1               .byte 0,0,0,0,0,0,0,0,0,0
00C6FE  1               .byte 0,0,0,0,0,0,0,0,0,0
00C6FE  1               .byte 0,0,0,0,0,0,0,0,0,0
00C6FE  1               .byte 0,0,0,0,0,0
00C6FE  1               
00C6FE  1               .endif
00C6FE  1               
00C6FE  1               .else
00C6FE  1               
00C6FE  1               ; Add filler bytes up to documented SWEET16 entry point at
00C6FE  1               ; address $X689
00C6FE  1               .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
00C6FE  1               .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
00C6FE  1               
00C6FE  1               ; ***********************
00C6FE  1               ; *                     *
00C6FE  1               ; * APPLE-II PSEUDO     *
00C6FE  1               ; * MACHINE INTERPRETER *
00C6FE  1               ; *                     *
00C6FE  1               ; * COPYRIGHT 1977      *
00C6FE  1               ; * APPLE COMPUTER INC  *
00C6FE  1               ; *                     *
00C6FE  1               ; * ALL RIGHTS RESERVED *
00C6FE  1               ; * S. WOZNIAK          *
00C6FE  1               ; *                     *
00C6FE  1               ; ***********************
00C6FE  1               ; TITLE "SWEET16 INTERPRETER"
00C6FE  1               R0L = $0
00C6FE  1               R0H = $1
00C6FE  1               R14H = $1D
00C6FE  1               R15L = $1E
00C6FE  1               R15H = $1F
00C6FE  1               SW16PAG = $F7
00C6FE  1               ; SAVE = $FF4A
00C6FE  1               ; RESTORE = $FF3F
00C6FE  1               ;  .ORG $F689
00C6FE  1               SW16: JSR SAVE ; PRESERVE 6502 REG CONTENTS
00C6FE  1                 PLA
00C6FE  1                 STA R15L ; INIT SWEET16 PC
00C6FE  1                 PLA ; FROM RETURN
00C6FE  1                 STA R15H ; ADDRESS
00C6FE  1               SW16B: JSR SW16C ; INTERPRET AND EXECUTE
00C6FE  1                 JMP SW16B ; ONE SWEET16 INSTR.
00C6FE  1               SW16C: INC R15L
00C6FE  1                 BNE SW16D ; INCR SWEET16 PC FOR FETCH
00C6FE  1                 INC R15H
00C6FE  1               SW16D: LDA #SW16PAG
00C6FE  1                 PHA ; PUSH ON STACK FOR RTS
00C6FE  1                 LDY #$0
00C6FE  1                 LDA (R15L),Y ; FETCH INSTR
00C6FE  1                 AND #$F ; MASK REG SPECIFICATION
00C6FE  1                 ASL A ; DOUBLE FOR TWO BYTE REGISTERS
00C6FE  1                 TAX ; TO X REG FOR INDEXING
00C6FE  1                 LSR A
00C6FE  1                 EOR (R15L),Y ; NOW HAVE OPCODE
00C6FE  1                 BEQ TOBR ; IF ZERO THEN NON-REG OP
00C6FE  1                 STX R14H ; INDICATE'PRIOR RESULT REG'
00C6FE  1                 LSR A
00C6FE  1                 LSR A ; OPCODE*2 TO LSB'S
00C6FE  1                 LSR A
00C6FE  1                 TAY ; TO Y REG FOR INDEXING
00C6FE  1                 LDA OPTBL-2,Y ; LOW ORDER ADR BYTE
00C6FE  1                 PHA ; ONTO STACK
00C6FE  1                 RTS ; GOTO REG-OP ROUTINE
00C6FE  1               TOBR: INC R15L
00C6FE  1                 BNE TOBR2 ; INCR PC
00C6FE  1                 INC R15H
00C6FE  1               TOBR2: LDA BRTBL,X ; LOW ORDER ADR BYTE
00C6FE  1                 PHA ; ONTO STACK FOR NON-REG OP
00C6FE  1                 LDA R14H ; 'PRIOR RESULT REG' INDEX
00C6FE  1                 LSR A ; PREPARE CARRY FOR BC, BNC.
00C6FE  1                 RTS ; GOTO NON-REG OP ROUTINE
00C6FE  1               RTNZ: PLA ; POP RETURN ADDRESS
00C6FE  1                 PLA
00C6FE  1                 JSR RESTORE ; RESTORE 6502 REG CONTENTS
00C6FE  1                 JMP (R15L) ; RETURN TO 6502 CODE VIA PC
00C6FE  1               SETZ: LDA (R15L),Y ; HIGH-ORDER BYTE OF CONSTANT
00C6FE  1                 STA R0H,X
00C6FE  1                 DEY
00C6FE  1                 LDA (R15L),Y ; LOW-ORDER BYTE OF CONSTANT
00C6FE  1                 STA R0L,X
00C6FE  1                 TYA ; Y-REG CONTAINS 1
00C6FE  1                 SEC
00C6FE  1                 ADC R15L ; ADD 2 TO PC
00C6FE  1                 STA R15L
00C6FE  1                 BCC SET2
00C6FE  1                 INC R15H
00C6FE  1               SET2: RTS
00C6FE  1               OPTBL: .BYTE <SET-1 ; 1X
00C6FE  1               BRTBL: .BYTE <RTN-1 ; 0
00C6FE  1                 .BYTE <LD-1 ; 2X
00C6FE  1                 .BYTE <BR-1 ; 1
00C6FE  1                 .BYTE <ST-1 ; 3X
00C6FE  1                 .BYTE <BNC-1 ; 2
00C6FE  1                 .BYTE <LDAT-1 ; 4X
00C6FE  1                 .BYTE <BC-1 ; 3
00C6FE  1                 .BYTE <STAT-1 ; 5X
00C6FE  1                 .BYTE <BP-1 ; 4
00C6FE  1                 .BYTE <LDDAT-1 ; 6X
00C6FE  1                 .BYTE <BM-1 ; 5
00C6FE  1                 .BYTE <STDAT-1 ; 7X
00C6FE  1                 .BYTE <BZ-1 ; 6
00C6FE  1                 .BYTE <POP-1 ; 8X
00C6FE  1                 .BYTE <BNZ-1 ; 7
00C6FE  1                 .BYTE <STPAT-1 ; 9X
00C6FE  1                 .BYTE <BM1-1 ; 8
00C6FE  1                 .BYTE <ADD-1 ; AX
00C6FE  1                 .BYTE <BNM1-1 ; 9
00C6FE  1                 .BYTE <SUB-1 ; BX
00C6FE  1                 .BYTE <BK-1 ; A
00C6FE  1                 .BYTE <POPD-1 ; CX
00C6FE  1                 .BYTE <RS-1 ; B
00C6FE  1                 .BYTE <CPR-1 ; DX
00C6FE  1                 .BYTE <BS-1 ; C
00C6FE  1                 .BYTE <INR-1 ; EX
00C6FE  1                 .BYTE <NUL-1 ; D
00C6FE  1                 .BYTE <DCR-1 ; FX
00C6FE  1                 .BYTE <NUL-1 ; E
00C6FE  1                 .BYTE <NUL-1 ; UNUSED
00C6FE  1                 .BYTE <NUL-1 ; F
00C6FE  1               SET: BPL SETZ ; ALWAYS TAKEN
00C6FE  1               LD: LDA R0L,X
00C6FE  1               BK = LD+1
00C6FE  1                 STA R0L
00C6FE  1                 LDA R0H,X ; MOVE RX TO R0
00C6FE  1                 STA R0H
00C6FE  1                 RTS
00C6FE  1               ST: LDA R0L
00C6FE  1                 STA R0L,X ; MOVE R0 TO RX
00C6FE  1                 LDA R0H
00C6FE  1                 STA R0H,X
00C6FE  1                 RTS
00C6FE  1               STAT: LDA R0L
00C6FE  1               STAT2: STA (R0L,X) ; STORE BYTE INDIRECT
00C6FE  1                 LDY #$0
00C6FE  1               STAT3: STY R14H ; INDICATE R0 IS RESULT NEG
00C6FE  1               INR: INC R0L,X
00C6FE  1                 BNE INR2 ; INCR RX
00C6FE  1                 INC R0H,X
00C6FE  1               INR2: RTS
00C6FE  1               LDAT: LDA (R0L,X) ; LOAD INDIRECT (RX)
00C6FE  1                 STA R0L ; TO R0
00C6FE  1                 LDY #$0
00C6FE  1                 STY R0H ; ZERO HIGH-ORDER R0 BYTE
00C6FE  1                 BEQ STAT3 ; ALWAYS TAKEN
00C6FE  1               POP: LDY #$0 ; HIGH ORDER BYTE = 0
00C6FE  1                 BEQ POP2 ; ALWAYS TAKEN
00C6FE  1               POPD: JSR DCR ; DECR RX
00C6FE  1                 LDA (R0L,X) ; POP HIGH ORDER BYTE @RX
00C6FE  1                 TAY ; SAVE IN Y-REG
00C6FE  1               POP2: JSR DCR ; DECR RX
00C6FE  1                 LDA (R0L,X) ; LOW-ORDER BYTE
00C6FE  1                 STA R0L ; TO R0
00C6FE  1                 STY R0H
00C6FE  1               POP3: LDY #$0 ; INDICATE R0 AS LAST RESULT REG
00C6FE  1                 STY R14H
00C6FE  1                 RTS
00C6FE  1               LDDAT: JSR LDAT ; LOW-ORDER BYTE TO R0, INCR RX
00C6FE  1                 LDA (R0L,X) ; HIGH-ORDER BYTE TO R0
00C6FE  1                 STA R0H
00C6FE  1                 JMP INR ; INCR RX
00C6FE  1               STDAT: JSR STAT ; STORE INDIRECT LOW-ORDER
00C6FE  1                 LDA R0H ; BYTE AND INCR RX. THEN
00C6FE  1                 STA (R0L,X) ; STORE HIGH-ORDER BYTE.
00C6FE  1                 JMP INR ; INCR RX AND RETURN
00C6FE  1               STPAT: JSR DCR ; DECR RX
00C6FE  1                 LDA R0L
00C6FE  1                 STA (R0L,X) ; STORE R0 LOW BYTE @RX
00C6FE  1                 JMP POP3 ; INDICATE R0 AS LAST RSLT REG
00C6FE  1               DCR: LDA R0L,X
00C6FE  1                 BNE DCR2 ; DECR RX
00C6FE  1                 DEC R0H,X
00C6FE  1               DCR2: DEC R0L,X
00C6FE  1                 RTS
00C6FE  1               SUB: LDY #$0 ; RESULT TO R0
00C6FE  1               CPR: SEC ; NOTE Y-REG = 13*2 FOR CPR
00C6FE  1                 LDA R0L
00C6FE  1                 SBC R0L,X
00C6FE  1                 STA R0L,Y ; R0-RX TO RY
00C6FE  1                 LDA R0H
00C6FE  1                 SBC R0H,X
00C6FE  1               SUB2: STA R0H,Y
00C6FE  1                 TYA ; LAST RESULT REG*2
00C6FE  1                 ADC #$0 ; CARRY TO LSB
00C6FE  1                 STA R14H
00C6FE  1                 RTS
00C6FE  1               ADD: LDA R0L
00C6FE  1                 ADC R0L,X
00C6FE  1                 STA R0L ; R0+RX TO R0
00C6FE  1                 LDA R0H
00C6FE  1                 ADC R0H,X
00C6FE  1                 LDY #$0 ; R0 FOR RESULT
00C6FE  1                 BEQ SUB2 ; FINISH ADD
00C6FE  1               BS: LDA R15L ; NOTE X-REG IS 12*2!
00C6FE  1                 JSR STAT2 ; PUSH LOW PC BYTE VIA R12
00C6FE  1                 LDA R15H
00C6FE  1                 JSR STAT2 ; PUSH HIGH-ORDER PC BYTE
00C6FE  1               BR: CLC
00C6FE  1               BNC: BCS BNC2 ; NO CARRY TEST
00C6FE  1               BR1: LDA (R15L),Y ; DISPLACEMENT BYTE
00C6FE  1                 BPL BR2
00C6FE  1                 DEY
00C6FE  1               BR2: ADC R15L ; ADD TO PC
00C6FE  1                 STA R15L
00C6FE  1                 TYA
00C6FE  1                 ADC R15H
00C6FE  1                 STA R15H
00C6FE  1               BNC2: RTS
00C6FE  1               BC: BCS BR
00C6FE  1                 RTS
00C6FE  1               BP: ASL A ; DOUBLE RESULT-REG INDEX
00C6FE  1                 TAX ; TO X REG FOR INDEXING
00C6FE  1                 LDA R0H,X ; TEST FOR PLUS
00C6FE  1                 BPL BR1 ; BRANCH IF SO
00C6FE  1                 RTS
00C6FE  1               BM: ASL A ; DOUBLE RESULT-REG INDEX
00C6FE  1                 TAX
00C6FE  1                 LDA R0H,X ; TEST FOR MINUS
00C6FE  1                 BMI BR1
00C6FE  1                 RTS
00C6FE  1               BZ: ASL A ; DOUBLE RESULT-REG INDEX
00C6FE  1                 TAX
00C6FE  1                 LDA R0L,X ; TEST FOR ZERO
00C6FE  1                 ORA R0H,X ; (BOTH BYTES)
00C6FE  1                 BEQ BR1 ; BRANCH IF SO
00C6FE  1                 RTS
00C6FE  1               BNZ: ASL A ; DOUBLE RESULT-REG INDEX
00C6FE  1                 TAX
00C6FE  1                 LDA R0L,X ; TEST FOR NON-ZERO
00C6FE  1                 ORA R0H,X ; (BOTH BYTES)
00C6FE  1                 BNE BR1 ; BRANCH IF SO
00C6FE  1                 RTS
00C6FE  1               BM1: ASL A ; DOUBLE RESULT-REG INDEX
00C6FE  1                 TAX
00C6FE  1                 LDA R0L,X ; CHECK BOTH BYTES
00C6FE  1                 AND R0H,X ; FOR $FF (MINUS 1)
00C6FE  1                 EOR #$FF
00C6FE  1                 BEQ BR1 ; BRANCH IF SO
00C6FE  1                 RTS
00C6FE  1               BNM1: ASL A ; DOUBLE RESULT-REG INDEX
00C6FE  1                 TAX
00C6FE  1                 LDA R0L,X
00C6FE  1                 AND R0H,X ; CHECK BOTH BYTES FOR NO $FF
00C6FE  1                 EOR #$FF
00C6FE  1                 BNE BR1 ; BRANCH IF NOT MINUS 1
00C6FE  1               NUL: RTS
00C6FE  1               RS: LDX #$18 ; 12*2 FOR R12 AS STACK POINTER
00C6FE  1                 JSR DCR ; DECR STACK POINTER
00C6FE  1                 LDA (R0L,X) ; POP HIGH RETURN ADDRESS TO PC
00C6FE  1                 STA R15H
00C6FE  1                 JSR DCR ; SAME FOR LOW-ORDER BYTE
00C6FE  1                 LDA (R0L,X)
00C6FE  1                 STA R15L
00C6FE  1                RTS
00C6FE  1               RTN: JMP RTNZ
00C6FE  1               
00C6FE  1               ; Padding bytes to make System Monitor start at $F800
00C6FE  1                 .byte 0,0,0
00C6FE  1               
00C6FE  1               ; The8BitEnthusiast: additional 13 bytes
00C6FE  1                 .byte 0,0,0,0,0,0,0,0,0,0,0,0,0
00C6FE  1               
00C6FE  1               .endif
00C6FE  1               
00C6FE  1               ; ***************************
00C6FE  1               ; *                         *
00C6FE  1               ; * APPLE II                *
00C6FE  1               ; * SYSTEM MONITOR          *
00C6FE  1               ; *                         *
00C6FE  1               ; * COPYRIGHT 1977 BY       *
00C6FE  1               ; * APPLE COMPUTER, INC.    *
00C6FE  1               ; *                         *
00C6FE  1               ; * ALL RIGHTS RESERVED     *
00C6FE  1               ; *                         *
00C6FE  1               ; * S. WOZNIAK              *
00C6FE  1               ; * A. BAUM                 *
00C6FE  1               ; *                         *
00C6FE  1               ; ***************************
00C6FE  1               ; TITLE "APPLE II SYSTEM MONITOR"
00C6FE  1               LOC0 = $00
00C6FE  1               LOC1 = $01
00C6FE  1               WNDLFT = $20
00C6FE  1               WNDWDTH = $21
00C6FE  1               WNDTOP = $22
00C6FE  1               WNDBTM = $23
00C6FE  1               CH = $24
00C6FE  1               CV = $25
00C6FE  1               GBASL = $26
00C6FE  1               GBASH = $27
00C6FE  1               BASL = $28
00C6FE  1               BASH = $29
00C6FE  1               BAS2L = $2A
00C6FE  1               BAS2H = $2B
00C6FE  1               H2 = $2C
00C6FE  1               LMNEM = $2C
00C6FE  1               RTNL = $2C
00C6FE  1               V2 = $2D
00C6FE  1               RMNEM = $2D
00C6FE  1               RTNH = $2D
00C6FE  1               MASK = $2E
00C6FE  1               CHKSUM = $2E
00C6FE  1               ; FORMAT = $2E
00C6FE  1               LASTIN = $2F
00C6FE  1               ; LENGTH = $2F
00C6FE  1               SIGN = $2F
00C6FE  1               COLOR = $30
00C6FE  1               ; MODE = $31
00C6FE  1               INVFLG = $32
00C6FE  1               ; PROMPT = $33
00C6FE  1               ; YSAV = $34
00C6FE  1               YSAV1 = $35
00C6FE  1               CSWL = $36
00C6FE  1               CSWH = $37
00C6FE  1               KSWL = $38
00C6FE  1               KSWH = $39
00C6FE  1               ; PCL = $3A
00C6FE  1               ; PCH = $3B
00C6FE  1               XQT = $3C
00C6FE  1               A1L = $3C
00C6FE  1               ; A1H = $3D
00C6FE  1               ;A2L = $3E
00C6FE  1               ;A2H = $3F
00C6FE  1               A3L = $40
00C6FE  1               A3H = $41
00C6FE  1               ;A4L = $42
00C6FE  1               ;A4H = $43
00C6FE  1               A5L = $44
00C6FE  1               A5H = $45
00C6FE  1               ACC = $45
00C6FE  1               XREG = $46
00C6FE  1               YREG = $47
00C6FE  1               STATUS = $48
00C6FE  1               SPNT = $49
00C6FE  1               RNDL = $4E
00C6FE  1               RNDH = $4F
00C6FE  1               ACL = $50
00C6FE  1               ACH = $51
00C6FE  1               XTNDL = $52
00C6FE  1               XTNDH = $53
00C6FE  1               AUXL = $54
00C6FE  1               AUXH = $55
00C6FE  1               PICK = $95
00C6FE  1               ; IN = $0200
00C6FE  1               USRADR = $03F8
00C6FE  1               NMI = $03FB
00C6FE  1               IRQLOC = $03FE
00C6FE  1               IOADR = $C000
00C6FE  1               KBD = $C000
00C6FE  1               KBDSTRB = $C010
00C6FE  1               TAPEOUT = $C020
00C6FE  1               SPKR = $C030
00C6FE  1               TXTCLR = $C050
00C6FE  1               TXTSET = $C051
00C6FE  1               MIXCLR = $C052
00C6FE  1               MIXSET = $C053
00C6FE  1               LOWSCR = $C054
00C6FE  1               HISCR = $C055
00C6FE  1               LORES = $C056
00C6FE  1               HIRES = $C057
00C6FE  1               TAPEIN = $C060
00C6FE  1               PADDL0 = $C064
00C6FE  1               PTRIG = $C070
00C6FE  1               BASIC = $E000
00C6FE  1               .ifdef APPLE1
00C6FE  1               BASIC2 = $E2B3
00C6FE  1               .else
00C6FE  1               BASIC2 = $E003
00C6FE  1               .endif
00C6FE  1               ; ORG $F800 ROM START ADDRESS
00C6FE  1  4A           PLOT: LSR ; Y-COORD/2
00C6FF  1  08             PHP ; SAVE LSB IN CARRY
00C700  1  20 45 C7       JSR GBASCALC ; CALC BASE ADR IN GBASL,H
00C703  1  28             PLP ; RESTORE LSB FROM CARRY
00C704  1  A9 0F          LDA #$0F ; MASK $0F IF EVEN
00C706  1  90 02          BCC RTMASK
00C708  1  69 E0          ADC #$E0 ; MASK $F0 IF ODD
00C70A  1  85 2E        RTMASK: STA MASK
00C70C  1  B1 26        PLOT1: LDA (GBASL),Y ; DATA
00C70E  1  45 30          EOR COLOR ; EOR COLOR
00C710  1  25 2E          AND MASK ; AND MASK
00C712  1  51 26          EOR (GBASL),Y ; XOR DATA
00C714  1  91 26          STA (GBASL),Y ; TO DATA
00C716  1  60             RTS
00C717  1  20 FE C6     HLINE: JSR PLOT ; PLOT SQUARE
00C71A  1  C4 2C        HLINE1: CPY H2 ; DONE?
00C71C  1  B0 11          BCS RTS1 ; YES, RETURN
00C71E  1  C8             INY ; NO, INCR INDEX (X-COORD)
00C71F  1  20 0C C7       JSR PLOT1 ; PLOT NEXT SQUARE
00C722  1  90 F6          BCC HLINE1 ; ALWAYS TAKEN
00C724  1  69 01        VLINEZ: ADC #$01 ; NEXT Y-COORD
00C726  1  48           VLINE: PHA ; SAVE ON STACK
00C727  1  20 FE C6       JSR PLOT ; PLOT SQUARE
00C72A  1  68             PLA
00C72B  1  C5 2D          CMP V2 ; DONE?
00C72D  1  90 F5          BCC VLINEZ ; NO, LOOP
00C72F  1  60           RTS1: RTS
00C730  1  A0 2F        CLRSCR: LDY #$2F ; MAX Y, FULL SCRN CLR
00C732  1  D0 02          BNE CLRSC2 ; ALWAYS TAKEN
00C734  1  A0 27        CLRTOP: LDY #$27 ; MAX Y, TOP SCREEN CLR
00C736  1  84 2D        CLRSC2: STY V2 ; STORE AS BOTTOM COORD
00C738  1               ; FOR VLINE CALLS
00C738  1  A0 27          LDY #$27 ; RIGHTMOST X-COORD (COLUMN)
00C73A  1  A9 00        CLRSC3: LDA #$00 ; TOP COORD FOR VLINE CALLS
00C73C  1  85 30          STA COLOR ; CLEAR COLOR (BLACK)
00C73E  1  20 26 C7       JSR VLINE ; DRAW VLINE
00C741  1  88             DEY ; NEXT LEFTMOST X-COORD
00C742  1  10 F6          BPL CLRSC3 ; LOOP UNTIL DONE
00C744  1  60             RTS
00C745  1  48           GBASCALC: PHA ; FOR INPUT 000DEFGH
00C746  1  4A             LSR
00C747  1  29 03          AND #$03
00C749  1  09 04          ORA #$04 ; GENERATE GBASH=000001FG
00C74B  1  85 27          STA GBASH
00C74D  1  68             PLA ; AND GBASL=HDEDE000
00C74E  1  29 18          AND #$18
00C750  1  90 02          BCC GBCALC
00C752  1  69 7F          ADC #$7F
00C754  1  85 26        GBCALC: STA GBASL
00C756  1  0A             ASL A
00C757  1  0A             ASL A
00C758  1  05 26          ORA GBASL
00C75A  1  85 26          STA GBASL
00C75C  1  60             RTS
00C75D  1  A5 30        NXTCOL: LDA COLOR ; INCREMENT COLOR BY 3
00C75F  1  18             CLC
00C760  1  69 03          ADC #$03
00C762  1  29 0F        SETCOL: AND #$0F ; SETS COLOR=17*A MOD 16
00C764  1  85 30          STA COLOR
00C766  1  0A             ASL A ; BOTH HALF BYTES OF COLOR EQUAL
00C767  1  0A             ASL A
00C768  1  0A             ASL A
00C769  1  0A             ASL A
00C76A  1  05 30          ORA COLOR
00C76C  1  85 30          STA COLOR
00C76E  1  60             RTS
00C76F  1  4A           SCRN: LSR A ; READ SCREEN Y-COORD/2
00C770  1  08             PHP ; SAVE LSB (CARRY)
00C771  1  20 45 C7       JSR GBASCALC ; CALC BASE ADDRESS
00C774  1  B1 26          LDA (GBASL),Y ; GET BYTE
00C776  1  28             PLP ; RESTORE LSB FROM CARRY
00C777  1  90 04        SCRN2: BCC RTMSKZ ; IF EVEN, USE LO H
00C779  1  4A             LSR A
00C77A  1  4A             LSR A
00C77B  1  4A             LSR A ; SHIFT HIGH HALF BYTE DOWN
00C77C  1  4A             LSR A
00C77D  1  29 0F        RTMSKZ: AND #$0F ; MASK 4-BITS
00C77F  1  60             RTS
00C780  1  A6 3A        INSDS1: LDX PCL ; PRINT PCL,H
00C782  1  A4 3B          LDY PCH
00C784  1  20 96 CC       JSR PRYX2
00C787  1  20 46 C8       JSR PRBLNK ; FOLLOWED BY A BLANK
00C78A  1               .ifdef APPLE1
00C78A  1  4C 69 C5       JMP L0
00C78D  1  EA             NOP
00C78E  1  EA             NOP
00C78F  1  EA             NOP
00C790  1  EA             NOP
00C791  1               INSDS2:
00C791  1               .else
00C791  1                 LDA (PCL,X) ; GET OP CODE
00C791  1               INSDS2: TAY
00C791  1                 LSR A ; EVEN/ODD TEST
00C791  1                 BCC IEVEN
00C791  1                 ROR ; BIT 1 TEST
00C791  1               .endif
00C791  1  B0 10          BCS ERR1 ; XXXXXX11 INVALID OP
00C793  1  C9 A2          CMP #$A2
00C795  1  F0 0C          BEQ ERR1 ; OPCODE $89 INVALID
00C797  1  29 87          AND #$87 ; MASK BITS
00C799  1  4A           IEVEN: LSR A ; LSB INTO CARRY FOR L/R TEST
00C79A  1  AA             TAX
00C79B  1  BD 60 C8       LDA FMT1,X ; GET FORMAT INDEX BYTE
00C79E  1  20 77 C7       JSR SCRN2 ; R/L H-BYTE ON CARRY
00C7A1  1  D0 04          BNE GETFMT
00C7A3  1  A0 80        ERR1: LDY #$80 ; SUBSTITUTE $80 FOR INVALID OPS
00C7A5  1  A9 00          LDA #$00 ; SET PRINT FORMAT INDEX TO 0
00C7A7  1  AA           GETFMT: TAX
00C7A8  1  BD A4 C8       LDA FMT2,X ; INDEX INTO PRINT FORMAT TABLE
00C7AB  1  85 2E          STA FORMAT ; SAVE FOR ADR FIELD FORMATTING
00C7AD  1  29 03          AND #$03 ; MASK FOR 2-BIT LENGTH (P=1 BYTE, 1=2 BYTE, 2=3 BYTE)
00C7AF  1  85 2F          STA LENGTH
00C7B1  1  98             TYA ; OPCODE
00C7B2  1  29 8F          AND #$8F ; MASK FOR 1XXX1010 TEST
00C7B4  1  AA             TAX ; SAVE IT
00C7B5  1  98             TYA ; OPCODE TO A AGAIN
00C7B6  1  A0 03          LDY #$03
00C7B8  1  E0 8A          CPX #$8A
00C7BA  1  F0 0B          BEQ MNNDX3
00C7BC  1  4A           MNNDX1: LSR A
00C7BD  1  90 08          BCC MNNDX3 ; FORM INDEX INTO MNEMONIC TABLE
00C7BF  1  4A             LSR A
00C7C0  1  4A           MNNDX2: LSR A ; 1) 1XXX1010->00101XXX
00C7C1  1  09 20          ORA #$20 ; 2) XXXYYY01->00111XXX
00C7C3  1  88             DEY ; 3) XXXYYY10->00110XXX
00C7C4  1  D0 FA          BNE MNNDX2 ; 4) XXXYY100->00100XXX
00C7C6  1  C8             INY ; 5) XXXXX000->000XXXXX
00C7C7  1  88           MNNDX3: DEY
00C7C8  1  D0 F2          BNE MNNDX1
00C7CA  1  60             RTS
00C7CB  1  FF FF FF       .BYTE $FF,$FF,$FF
00C7CE  1  20 80 C7     INSTDSP: JSR INSDS1 ; GEN FMT, LEN BYTES
00C7D1  1  48             PHA ; SAVE MNEMONIC TABLE INDEX
00C7D2  1  B1 3A        PRNTOP: LDA (PCL),Y
00C7D4  1  20 DA CC       JSR PRBYTE
00C7D7  1  A2 01          LDX #$01 ; PRINT 2 BLANKS
00C7D9  1  20 48 C8     PRNTBL: JSR PRBL2
00C7DC  1  C4 2F          CPY LENGTH ; PRINT INST (1-3 BYTES)
00C7DE  1  C8             INY ; IN A 12 CHR FIELD
00C7DF  1  90 F1          BCC PRNTOP
00C7E1  1  A2 03          LDX #$03 ; CHAR COUNT FOR MNEMONIC PRINT
00C7E3  1  C0 04          CPY #$04
00C7E5  1  90 F2          BCC PRNTBL
00C7E7  1  68             PLA ; RECOVER MNEMONIC INDEX
00C7E8  1  A8             TAY
00C7E9  1  B9 BE C8       LDA MNEML,Y
00C7EC  1  85 2C          STA LMNEM ; FETCH 3-CHAR MNEMONIC
00C7EE  1  B9 FE C8       LDA MNEMR,Y ; (PACKED IN 2-BYTES)
00C7F1  1  85 2D          STA RMNEM
00C7F3  1  A9 00        PRMN1: LDA #$00
00C7F5  1  A0 05          LDY #$05
00C7F7  1  06 2D        PRMN2: ASL RMNEM ; SHIFT 5 BITS OF
00C7F9  1  26 2C          ROL LMNEM ; CHARACTER INTO A
00C7FB  1  2A             ROL ; (CLEARS CARRY)
00C7FC  1  88             DEY
00C7FD  1  D0 F8          BNE PRMN2
00C7FF  1  69 BF          ADC #$BF ; ADD "?" OFFSET
00C801  1  20 ED CC       JSR COUT ; OUTPUT A CHAR OF MNEM
00C804  1  CA             DEX
00C805  1  D0 EC          BNE PRMN1
00C807  1  20 46 C8       JSR PRBLNK ; OUTPUT 3 BLANKS
00C80A  1  A4 2F          LDY LENGTH
00C80C  1  A2 06          LDX #$06 ; CNT FOR 6 FORMAT BITS
00C80E  1  E0 03        PRADR1: CPX #$03
00C810  1  F0 1C          BEQ PRADR5 ; IF X=3 THEN ADDR.
00C812  1  06 2E        PRADR2: ASL FORMAT
00C814  1  90 0E          BCC PRADR3
00C816  1  BD B1 C8       LDA CHAR1-1,X
00C819  1  20 ED CC       JSR COUT
00C81C  1  BD B7 C8       LDA CHAR2-1,X
00C81F  1  F0 03          BEQ PRADR3
00C821  1  20 ED CC       JSR COUT
00C824  1  CA           PRADR3: DEX
00C825  1  D0 E7          BNE PRADR1
00C827  1  60             RTS
00C828  1  88           PRADR4: DEY
00C829  1  30 E7          BMI PRADR2
00C82B  1  20 DA CC       JSR PRBYTE
00C82E  1  A5 2E        PRADR5: LDA FORMAT
00C830  1  C9 E8          CMP #$E8 ; HANDLE REL ADR MODE
00C832  1  B1 3A          LDA (PCL),Y ; SPECIAL (PRINT TARGET,
00C834  1  90 F2          BCC PRADR4 ; NOT OFFSET)
00C836  1  20 54 C8     RELADR: JSR PCADJ3
00C839  1  AA             TAX ; PCL,PCH+OFFSET+1 TO A,Y
00C83A  1  E8             INX
00C83B  1  D0 01          BNE PRNTYX ; +1 TO Y,X
00C83D  1  C8             INY
00C83E  1  98           PRNTYX: TYA
00C83F  1  20 DA CC     PRNTAX: JSR PRBYTE ; OUTPUT TARGET ADR
00C842  1  8A           PRNTX: TXA ; OF BRANCH AND RETURN
00C843  1  4C DA CC       JMP PRBYTE
00C846  1  A2 03        PRBLNK: LDX #$03 ; BLANK COUNT
00C848  1  A9 A0        PRBL2: LDA #$A0 ; LOAD A SPACE
00C84A  1  20 ED CC     PRBL3: JSR COUT ; OUTPUT A BLANK
00C84D  1  CA             DEX
00C84E  1  D0 F8          BNE PRBL2 ; LOOP UNTIL COUNT=0
00C850  1  60             RTS
00C851  1  38           PCADJ: SEC ; 0=1-BYTE, 1=2-BYTE
00C852  1  A5 2F        PCADJ2: LDA LENGTH ; 2=3-BYTE
00C854  1  A4 3B        PCADJ3: LDY PCH
00C856  1  AA             TAX ; TEST DISPLACEMENT SIGN
00C857  1  10 01          BPL PCADJ4 ; (FOR REL BRANCH)
00C859  1  88             DEY ; EXTEND NEG BY DEC PCH
00C85A  1  65 3A        PCADJ4: ADC PCL
00C85C  1  90 01          BCC RTS2 ; PCL+LENGTH(OR DISPL)+1 TO A
00C85E  1  C8             INY ; CARRY INTO Y (PCH)
00C85F  1  60           RTS2: RTS
00C860  1               ; FMT1 BYTES: XXXXXXY0 INSTRS
00C860  1               ; IF Y=0 THEN LEFT HALF BYTE
00C860  1               ; IF Y=1 THEN RIGHT HALF BYTE
00C860  1               ; (X=INDEX)
00C860  1  04 20 54 30  FMT1: .BYTE $04,$20,$54,$30,$0D
00C864  1  0D           
00C865  1  80 04 90 03    .BYTE $80,$04,$90,$03,$22
00C869  1  22           
00C86A  1  54 33 0D 80    .BYTE $54,$33,$0D,$80,$04
00C86E  1  04           
00C86F  1  90 04 20 54    .BYTE $90,$04,$20,$54,$33
00C873  1  33           
00C874  1  0D 80 04 90    .BYTE $0D,$80,$04,$90,$04
00C878  1  04           
00C879  1  20 54 3B 0D    .BYTE $20,$54,$3B,$0D,$80
00C87D  1  80           
00C87E  1  04 90 00 22    .BYTE $04,$90,$00,$22,$44
00C882  1  44           
00C883  1  33 0D C8 44    .BYTE $33,$0D,$C8,$44,$00
00C887  1  00           
00C888  1  11 22 44 33    .BYTE $11,$22,$44,$33,$0D
00C88C  1  0D           
00C88D  1  C8 44 A9 01    .BYTE $C8,$44,$A9,$01,$22
00C891  1  22           
00C892  1  44 33 0D 80    .BYTE $44,$33,$0D,$80,$04
00C896  1  04           
00C897  1  90 01 22 44    .BYTE $90,$01,$22,$44,$33
00C89B  1  33           
00C89C  1  0D 80 04 90    .BYTE $0D,$80,$04,$90
00C8A0  1  26 31 87 9A    .BYTE $26,$31,$87,$9A ; $ZZXXXY01 INSTR'S
00C8A4  1  00           FMT2: .BYTE $00 ; ERR
00C8A5  1  21             .BYTE $21 ; IMM
00C8A6  1  81             .BYTE $81 ; Z-PAGE
00C8A7  1  82             .BYTE $82 ; ABS
00C8A8  1  00             .BYTE $00 ; IMPLIED
00C8A9  1  00             .BYTE $00 ; ACCUMULATOR
00C8AA  1  59             .BYTE $59 ; (ZPAG,X)
00C8AB  1  4D             .BYTE $4D ; (ZPAG),Y
00C8AC  1  91             .BYTE $91 ; ZPAG,X
00C8AD  1  92             .BYTE $92 ; ABS,X
00C8AE  1  86             .BYTE $86 ; ABS,Y
00C8AF  1  4A             .BYTE $4A ; (ABS)
00C8B0  1  85             .BYTE $85 ; ZPAG,Y
00C8B1  1  9D             .BYTE $9D ; RELATIVE
00C8B2  1  AC A9 AC A3  CHAR1: Str ",),#($"
00C8B6  1  A8 A4        
00C8B8  1  D9 00 D8 A4  CHAR2: .BYTE $D9,$00,$D8,$A4,$A4,$00
00C8BC  1  A4 00        
00C8BE  1               ; CHAR2: "Y",0,"X$$",0
00C8BE  1               ; MNEML IS OF FORM:
00C8BE  1               ; (A) XXXXX000
00C8BE  1               ; (B) XXXYY100
00C8BE  1               ; (C) 1XXX1010
00C8BE  1               ; (D) XXXYYY10
00C8BE  1               ; (E) XXXYYY01
00C8BE  1               ; (X=INDEX)
00C8BE  1  1C 8A 1C 23  MNEML: .BYTE $1C,$8A,$1C,$23,$5D,$8B
00C8C2  1  5D 8B        
00C8C4  1  1B A1 9D 8A    .BYTE $1B,$A1,$9D,$8A,$1D,$23
00C8C8  1  1D 23        
00C8CA  1  9D 8B 1D A1    .BYTE $9D,$8B,$1D,$A1,$00,$29
00C8CE  1  00 29        
00C8D0  1  19 AE 69 A8    .BYTE $19,$AE,$69,$A8,$19,$23
00C8D4  1  19 23        
00C8D6  1  24 53 1B 23    .BYTE $24,$53,$1B,$23,$24,$53
00C8DA  1  24 53        
00C8DC  1  19 A1          .BYTE $19,$A1 ; (A) FORMAT ABOVE
00C8DE  1  00 1A 5B 5B    .BYTE $00,$1A,$5B,$5B,$A5,$69
00C8E2  1  A5 69        
00C8E4  1  24 24          .BYTE $24,$24 ; (B) FORMAT
00C8E6  1  AE AE A8 AD    .BYTE $AE,$AE,$A8,$AD,$29,$00
00C8EA  1  29 00        
00C8EC  1  7C 00          .BYTE $7C,$00 ; (C) FORMAT
00C8EE  1  15 9C 6D 9C    .BYTE $15,$9C,$6D,$9C,$A5,$69
00C8F2  1  A5 69        
00C8F4  1  29 53          .BYTE $29,$53 ; (D) FORMAT
00C8F6  1  84 13 34 11    .BYTE $84,$13,$34,$11,$A5,$69
00C8FA  1  A5 69        
00C8FC  1  23 A0          .BYTE $23,$A0 ; (E) FORMAT
00C8FE  1  D8 62 5A 48  MNEMR: .BYTE $D8,$62,$5A,$48,$26,$62
00C902  1  26 62        
00C904  1  94 88 54 44    .BYTE $94,$88,$54,$44,$C8,$54
00C908  1  C8 54        
00C90A  1  68 44 E8 94    .BYTE $68,$44,$E8,$94,$00,$B4
00C90E  1  00 B4        
00C910  1  08 84 74 B4    .BYTE $08,$84,$74,$B4,$28,$6E
00C914  1  28 6E        
00C916  1  74 F4 CC 4A    .BYTE $74,$F4,$CC,$4A,$72,$F2
00C91A  1  72 F2        
00C91C  1  A4 8A          .BYTE $A4,$8A ; (A) FORMAT
00C91E  1  00 AA A2 A2    .BYTE $00,$AA,$A2,$A2,$74,$74
00C922  1  74 74        
00C924  1  74 72          .BYTE $74,$72 ; (B) FORMAT
00C926  1  44 68 B2 32    .BYTE $44,$68,$B2,$32,$B2,$00
00C92A  1  B2 00        
00C92C  1  22 00          .BYTE $22,$00 ; (C) FORMAT
00C92E  1  1A 1A 26 26    .BYTE $1A,$1A,$26,$26,$72,$72
00C932  1  72 72        
00C934  1  88 C8          .BYTE $88,$C8 ; (D) FORMAT
00C936  1  C4 CA 26 48    .BYTE $C4,$CA,$26,$48,$44,$44
00C93A  1  44 44        
00C93C  1  A2 C8          .BYTE $A2,$C8 ; (E) FORMAT
00C93E  1  FF FF FF       .BYTE $FF,$FF,$FF
00C941  1  20 CE C7     STEP: JSR INSTDSP ; DISASSEMBLE ONE INST
00C944  1  68             PLA ; AT (PCL,H)
00C945  1  85 2C          STA RTNL ; ADJUST TO USER
00C947  1  68             PLA ; STACK. SAVE
00C948  1  85 2D          STA RTNH ; RTN ADR.
00C94A  1  A2 08          LDX #$08
00C94C  1  BD 0E CA     XQINIT: LDA INITBL-1,X ; INIT XEQ AREA
00C94F  1  95 3C          STA XQT,X
00C951  1  CA             DEX
00C952  1  D0 F8          BNE XQINIT
00C954  1  A1 3A          LDA (PCL,X) ; USER OPCODE BYTE
00C956  1  F0 42          BEQ XBRK ; SPECIAL IF BREAK
00C958  1  A4 2F          LDY LENGTH ; LEN FROM DISASSEMBLY
00C95A  1  C9 20          CMP #$20
00C95C  1  F0 59          BEQ XJSR ; HANDLE JSR, RTS, JMP,
00C95E  1  C9 60          CMP #$60 ; JMP (), RTI SPECIAL
00C960  1  F0 45          BEQ XRTS
00C962  1  C9 4C          CMP #$4C
00C964  1  F0 5C          BEQ XJMP
00C966  1  C9 6C          CMP #$6C
00C968  1  F0 59          BEQ XJMPAT
00C96A  1  C9 40          CMP #$40
00C96C  1  F0 35          BEQ XRTI
00C96E  1  29 1F          AND #$1F
00C970  1  49 14          EOR #$14
00C972  1  C9 04          CMP #$04 ; COPY USER INST TO XEQ AREA
00C974  1  F0 02          BEQ XQ2 ; WITH TRAILING NOPS
00C976  1  B1 3A        XQ1: LDA (PCL),Y ; CHANGE REL BRANCH
00C978  1  99 3C 00     XQ2: STA XQT,Y ; DISP TO 4 FOR
00C97B  1  88             DEY ; JMP TO BRANCH OR
00C97C  1  10 F8          BPL XQ1 ; NBRANCH FROM XEQ.
00C97E  1  20 3F CE       JSR RESTORE ; RESTORE USER REG CONTENTS.
00C981  1  4C 3C 00       JMP XQT ; XEQ USER OP FROM RAM
00C984  1  85 45        IRQ: STA ACC ; (RETURN TO NBRANCH)
00C986  1  68             PLA
00C987  1  48             PHA ; **IRQ HANDLER
00C988  1  0A             ASL A
00C989  1  0A             ASL A
00C98A  1  0A             ASL A
00C98B  1  30 03          BMI BREAK ; TEST FOR BREAK
00C98D  1  6C FE 03       JMP (IRQLOC) ; USER ROUTINE VECTOR IN RAM
00C990  1  28           BREAK: PLP
00C991  1  20 4C CE       JSR SAV1 ; SAVE REG'S ON BREAK
00C994  1  68             PLA ; INCLUDING PC
00C995  1  85 3A          STA PCL
00C997  1  68             PLA
00C998  1  85 3B          STA PCH
00C99A  1  20 80 C7     XBRK: JSR INSDS1 ; PRINT USER PC.
00C99D  1  20 D8 C9       JSR RGDSP1 ; AND REG'S
00C9A0  1  4C 65 CE       JMP MON ; GO TO MONITOR
00C9A3  1  18           XRTI: CLC
00C9A4  1  68             PLA ; SIMULATE RTI BY EXPECTING
00C9A5  1  85 48          STA STATUS ; STATUS FROM STACK, THEN RTS
00C9A7  1  68           XRTS: PLA ; RTS SIMULATION
00C9A8  1  85 3A          STA PCL ; EXTRACT PC FROM STACK
00C9AA  1  68             PLA ; AND UPDATE PC BY 1 (LEN=0)
00C9AB  1  85 3B        PCINC2: STA PCH
00C9AD  1  A5 2F        PCINC3: LDA LENGTH ; UPDATE PC BY LEN
00C9AF  1  20 54 C8       JSR PCADJ3
00C9B2  1  84 3B          STY PCH
00C9B4  1  18             CLC
00C9B5  1  90 14          BCC NEWPCL
00C9B7  1  18           XJSR: CLC
00C9B8  1  20 52 C8       JSR PCADJ2 ; UPDATE PC AND PUSH
00C9BB  1  AA             TAX ; ONTO STACH FOR
00C9BC  1  98             TYA ; JSR SIMULATE
00C9BD  1  48             PHA
00C9BE  1  8A             TXA
00C9BF  1  48             PHA
00C9C0  1  A0 02          LDY #$02
00C9C2  1  18           XJMP: CLC
00C9C3  1  B1 3A        XJMPAT: LDA (PCL),Y
00C9C5  1  AA             TAX ; LOAD PC FOR JMP,
00C9C6  1  88             DEY ; (JMP) SIMULATE.
00C9C7  1  B1 3A          LDA (PCL),Y
00C9C9  1  86 3B          STX PCH
00C9CB  1  85 3A        NEWPCL: STA PCL
00C9CD  1  B0 F3          BCS XJMP
00C9CF  1  A5 2D        RTNJMP: LDA RTNH
00C9D1  1  48             PHA
00C9D2  1  A5 2C          LDA RTNL
00C9D4  1  48             PHA
00C9D5  1  20 8E CC     REGDSP: JSR CROUT ; DISPLAY USER REG
00C9D8  1  A9 45        RGDSP1: LDA #ACC ; CONTENTS WITH
00C9DA  1  85 40          STA A3L ; LABELS
00C9DC  1  A9 00          LDA #ACC/256
00C9DE  1  85 41          STA A3H
00C9E0  1  A2 FB          LDX #$FB
00C9E2  1  A9 A0        RDSP1: LDA #$A0
00C9E4  1  20 ED CC       JSR COUT
00C9E7  1  BD 1C C9       LDA RTBL-$FB,X
00C9EA  1  20 ED CC       JSR COUT
00C9ED  1  A9 BD          LDA #$BD
00C9EF  1  20 ED CC       JSR COUT
00C9F2  1  B5 4A          LDA ACC+5,X
00C9F4  1  20 DA CC       JSR PRBYTE
00C9F7  1  E8             INX
00C9F8  1  30 E8          BMI RDSP1
00C9FA  1  60             RTS
00C9FB  1  18           BRANCH: CLC ; BRANCH TAKEN,
00C9FC  1  A0 01          LDY #$01 ; ADD LEN+2 TO PC
00C9FE  1  B1 3A          LDA (PCL),Y
00CA00  1  20 54 C8       JSR PCADJ3
00CA03  1  85 3A          STA PCL
00CA05  1  98             TYA
00CA06  1  38             SEC
00CA07  1  B0 A2          BCS PCINC2
00CA09  1  20 4A CE     NBRNCH: JSR SAVE ; NORMAL RETURN AFTER
00CA0C  1  38             SEC ; XEQ USER OF
00CA0D  1  B0 9E          BCS PCINC3 ; GO UPDATE PC
00CA0F  1  EA           INITBL: NOP
00CA10  1  EA             NOP ; DUMMY FILL FOR
00CA11  1  4C 09 CA       JMP NBRNCH ; XEQ AREA
00CA14  1  4C FB C9       JMP BRANCH
00CA17  1  C1           RTBL: .BYTE $C1
00CA18  1  D8             .BYTE $D8
00CA19  1  D9             .BYTE $D9
00CA1A  1  D0             .BYTE $D0
00CA1B  1  D3             .BYTE $D3
00CA1C  1  AD 70 C0     PREAD: LDA PTRIG ; TRIGGER PADDLES
00CA1F  1  A0 00          LDY #$00 ; INIT COUNT
00CA21  1  EA             NOP ; COMPENSATE FOR 1ST COUNT
00CA22  1  EA             NOP
00CA23  1  BD 64 C0     PREAD2: LDA PADDL0,X ; COUNT Y-REG EVERY
00CA26  1  10 04          BPL RTS2D ; 12 USEC
00CA28  1  C8             INY
00CA29  1  D0 F8          BNE PREAD2 ; EXIT AT 255 MAX
00CA2B  1  88             DEY
00CA2C  1  60           RTS2D: RTS
00CA2D  1  A9 00        INIT: LDA #$00 ; CLR STATUS FOR DEBUG
00CA2F  1  85 48          STA STATUS ; SOFTWARE
00CA31  1  AD 56 C0       LDA LORES
00CA34  1  AD 54 C0       LDA LOWSCR ; INIT VIDEO MODE
00CA37  1  AD 51 C0     SETTXT: LDA TXTSET ; SET FOR TEXT MODE
00CA3A  1  A9 00          LDA #$00 ; FULL SCREEN WINDOW
00CA3C  1  F0 0B          BEQ SETWND
00CA3E  1  AD 50 C0     SETGR: LDA TXTCLR ; SET FOR GRAPHICS MODE
00CA41  1  AD 53 C0       LDA MIXSET ; LOWER 4 LINES AS
00CA44  1  20 34 C7       JSR CLRTOP ; TEXT WINDOW
00CA47  1  A9 14          LDA #$14
00CA49  1  85 22        SETWND: STA WNDTOP ; SET FOR 40 COL WINDOW
00CA4B  1  A9 00          LDA #$00 ; TOP IN A-REG,
00CA4D  1  85 20          STA WNDLFT ; BTTM AT LINE 24
00CA4F  1  A9 28          LDA #$28
00CA51  1  85 21          STA WNDWDTH
00CA53  1  A9 18          LDA #$18
00CA55  1  85 23          STA WNDBTM ; VTAB TO ROW 23
00CA57  1  A9 17          LDA #$17
00CA59  1  85 25        TABV: STA CV ; VTABS TO ROW IN A-REG
00CA5B  1  4C 20 CB       JMP VTAB
00CA5E  1  20 A2 CA     MULPM: JSR MD1 ; ABS VAL OF AC AUX
00CA61  1  A0 10        MUL: LDY #$10 ; INDEX FOR 16 BITS
00CA63  1  A5 50        MUL2: LDA ACL ; ACX * AUX + XTND
00CA65  1  4A             LSR A ; TO AC, XTND
00CA66  1  90 0C          BCC MUL4 ; IF NO CARRY,
00CA68  1  18             CLC ; NO PARTIAL PROD.
00CA69  1  A2 FE          LDX #$FE
00CA6B  1  B5 54        MUL3: LDA XTNDL+2,X ; ADD MPLCND (AUX)
00CA6D  1  75 56          ADC AUXL+2,X ; TO PARTIAL PROD
00CA6F  1  95 54          STA XTNDL+2,X ; (XTND)
00CA71  1  E8             INX
00CA72  1  D0 F7          BNE MUL3
00CA74  1  A2 03        MUL4: LDX #$03
00CA76  1  76           MUL5: .BYTE $76
00CA77  1  50             .BYTE $50
00CA78  1  CA             DEX
00CA79  1  10 FB          BPL MUL5
00CA7B  1  88             DEY
00CA7C  1  D0 E5          BNE MUL2
00CA7E  1  60             RTS
00CA7F  1  20 A2 CA     DIVPM: JSR MD1 ; ABS VAL OF AC, AUX.
00CA82  1  A0 10        DIV: LDY #$10 ; INDEX FOR 16 BITS
00CA84  1  06 50        DIV2: ASL ACL
00CA86  1  26 51          ROL ACH
00CA88  1  26 52          ROL XTNDL ; XTND/AUX
00CA8A  1  26 53          ROL XTNDH ; TO AC.
00CA8C  1  38             SEC
00CA8D  1  A5 52          LDA XTNDL
00CA8F  1  E5 54          SBC AUXL ; MOD TO XTND.
00CA91  1  AA             TAX
00CA92  1  A5 53          LDA XTNDH
00CA94  1  E5 55          SBC AUXH
00CA96  1  90 06          BCC DIV3
00CA98  1  86 52          STX XTNDL
00CA9A  1  85 53          STA XTNDH
00CA9C  1  E6 50          INC ACL
00CA9E  1  88           DIV3: DEY
00CA9F  1  D0 E3          BNE DIV2
00CAA1  1  60             RTS
00CAA2  1  A0 00        MD1: LDY #$00 ; ABS VAL OF AC, AUX
00CAA4  1  84 2F          STY SIGN ; WITH RESULT SIGN
00CAA6  1  A2 54          LDX #AUXL ; IN LSB OF SIGN.
00CAA8  1  20 AD CA       JSR MD3
00CAAB  1  A2 50          LDX #ACL
00CAAD  1  B5 01        MD3: LDA LOC1,X ; X SPECIFIES AC OR AUX
00CAAF  1  10 0D          BPL MDRTS
00CAB1  1  38             SEC
00CAB2  1  98             TYA
00CAB3  1  F5 00          SBC LOC0,X ; COMPL SPECIFIED REG
00CAB5  1  95 00          STA LOC0,X ; IF NEG.
00CAB7  1  98             TYA
00CAB8  1  F5 01          SBC LOC1,X
00CABA  1  95 01          STA LOC1,X
00CABC  1  E6 2F          INC SIGN
00CABE  1  60           MDRTS: RTS
00CABF  1  48           BASCALC: PHA ; CALC BASE ADR IN BASL,H
00CAC0  1  4A             LSR A ; FOR GIVEN LINE NO
00CAC1  1  29 03          AND #$03 ; 0<=LINE NO.<=$17
00CAC3  1  09 04          ORA #$04 ; ARG=000ABCDE, GENERATE
00CAC5  1  85 29          STA BASH ; BASH=000001CD
00CAC7  1  68             PLA ; AND
00CAC8  1  29 18          AND #$18 ; BASL=EABAB000
00CACA  1  90 02          BCC BSCLC2
00CACC  1  69 7F          ADC #$7F
00CACE  1  85 28        BSCLC2: STA BASL
00CAD0  1  0A             ASL
00CAD1  1  0A             ASL
00CAD2  1  05 28          ORA BASL
00CAD4  1  85 28          STA BASL
00CAD6  1  60             RTS
00CAD7  1  C9 87        BELL1: CMP #$87 ; BELL CHAR? (CNTRL-G)
00CAD9  1  D0 12          BNE RTS2B ; NO, RETURN
00CADB  1  A9 40          LDA #$40 ; DELAY .01 SECONDS
00CADD  1  20 A6 CB       JSR WAIT
00CAE0  1  A0 C0          LDY #$C0
00CAE2  1  A9 0C        BELL2: LDA #$0C ; TOGGLE SPEAKER AT
00CAE4  1  20 A6 CB       JSR WAIT ; 1 KHZ FOR .1 SEC.
00CAE7  1  AD 30 C0       LDA SPKR
00CAEA  1  88             DEY
00CAEB  1  D0 F5          BNE BELL2
00CAED  1  60           RTS2B: RTS
00CAEE  1  A4 24        STOADV: LDY CH ; CURSOR H INDEX TO Y-REG
00CAF0  1               .ifdef APPLE1
00CAF0  1  EA             NOP
00CAF1  1  EA             NOP
00CAF2  1               .else
00CAF2  1                 STA (BASL),Y ; STORE CHAR IN LINE
00CAF2  1               .endif
00CAF2  1  E6 24        ADVANCE: INC CH ; INCREMENT CURSOR H INDEX
00CAF4  1  A5 24          LDA CH ; (MOVE RIGHT)
00CAF6  1  C5 21          CMP WNDWDTH ; BEYOND WINDOW WIDTH?
00CAF8  1  B0 66          BCS CR ; YES CR TO NEXT LINE
00CAFA  1  60           RTS3: RTS ; NO,RETURN
00CAFB  1  C9 A0        VIDOUT: CMP #$A0 ; CONTROL CHAR?
00CAFD  1  B0 EF          BCS STOADV ; NO,OUTPUT IT.
00CAFF  1  A8             TAY ; INVERSE VIDEO?
00CB00  1  10 EC          BPL STOADV ; YES, OUTPUT IT.
00CB02  1  C9 8D          CMP #$8D ; CR?
00CB04  1  F0 5A          BEQ CR ; YES.
00CB06  1  C9 8A          CMP #$8A ; LINE FEED?
00CB08  1  F0 5A          BEQ LF ; IF SO, DO IT.
00CB0A  1  C9 88          CMP #$88 ; BACK SPACE? (CNTRL-H)
00CB0C  1  D0 C9          BNE BELL1 ; NO, CHECK FOR BELL.
00CB0E  1  C6 24        BS1: DEC CH ; DECREMENT CURSOR H INDEX
00CB10  1  10 E8          BPL RTS3 ; IF POS, OK. ELSE MOVE UP
00CB12  1  A5 21          LDA WNDWDTH ; SET CH TO WNDWDTH-1
00CB14  1  85 24          STA CH
00CB16  1  C6 24         DEC CH ; (RIGHTMOST SCREEN POS)
00CB18  1  A5 22        UP: LDA WNDTOP ; CURSOR V INDEX
00CB1A  1  C5 25          CMP CV
00CB1C  1  B0 0B          BCS RTS4 ; IF TOP LINE THEN RETURN
00CB1E  1  C6 25          DEC CV ; DEC CURSOR V-INDEX
00CB20  1  A5 25        VTAB: LDA CV ; GET CURSOR V-INDEX
00CB22  1  20 BF CA     VTABZ: JSR BASCALC ; GENERATE BASE ADR
00CB25  1  65 20          ADC WNDLFT ; ADD WINDOW LEFT INDEX
00CB27  1  85 28          STA BASL ; TO BASL
00CB29  1  60           RTS4: RTS
00CB2A  1  49 C0        ESC1: EOR #$C0 ; ESC?
00CB2C  1  F0 28          BEQ HOME ; IF SO, DO HOME AND CLEAR
00CB2E  1  69 FD          ADC #$FD ; ESC-A OR B CHECK
00CB30  1  90 C0          BCC ADVANCE ; A, ADVANCE
00CB32  1  F0 DA          BEQ BS1 ; B, BACKSPACE
00CB34  1  69 FD          ADC #$FD ; ESC-C OR D CHECK
00CB36  1  90 2C          BCC LF ; C, DOWN
00CB38  1  F0 DE          BEQ UP ; D, GO UP
00CB3A  1  69 FD          ADC #$FD ; ESC-E OR F CHECK
00CB3C  1  90 5C          BCC CLREOL ; E, CLEAR TO END OF LINE
00CB3E  1  D0 E9          BNE RTS4 ; NOT F, RETURN
00CB40  1  A4 24        CLREOP: LDY CH ; CURSOR H TO Y INDEX
00CB42  1  A5 25          LDA CV ; CURSOR V TO A-REGISTER
00CB44  1  48           CLEOP1: PHA ; SAVE CURRENT LINE ON STK
00CB45  1  20 22 CB       JSR VTABZ ; CALC BASE ADDRESS
00CB48  1  20 9C CB       JSR CLEOLZ ; CLEAR TO EOL, SET CARRY
00CB4B  1  A0 00          LDY #$00 ; CLEAR FROM H INDEX=0 FOR REST
00CB4D  1  68             PLA ; INCREMENT CURRENT LINE
00CB4E  1  69 00          ADC #$00 ; (CARRY IS SET)
00CB50  1  C5 23          CMP WNDBTM ; DONE TO BOTTOM OF WINDOW?
00CB52  1  90 F0          BCC CLEOP1 ; NO, KEEP CLEARING LINES
00CB54  1  B0 CA          BCS VTAB ; YES, TAB TO CURRENT LINE
00CB56  1  A5 22        HOME: LDA WNDTOP ; INIT CURSOR V
00CB58  1  85 25          STA CV ; AND H-INDICES
00CB5A  1  A0 00          LDY #$00
00CB5C  1  84 24          STY CH ; THEN CLEAR TO END OF PAGE
00CB5E  1  F0 E4          BEQ CLEOP1
00CB60  1  A9 00        CR: LDA #$00 ; CURSOR TO LEFT OF INDEX
00CB62  1  85 24          STA CH ; (RET CURSOR H=0)
00CB64  1  E6 25        LF: INC CV ; INCR CURSOR V(DOWN 1 LINE)
00CB66  1  A5 25          LDA CV
00CB68  1  C5 23          CMP WNDBTM ; OFF SCREEN?
00CB6A  1  90 B6          BCC VTABZ ; NO, SET BASE ADDR
00CB6C  1  C6 25          DEC CV ; DECR CURSOR V (BACK TO BOTTOM)
00CB6E  1  A5 22        SCROLL: LDA WNDTOP ; START AT TOP OF SCRL WNDW
00CB70  1  48             PHA
00CB71  1  20 22 CB       JSR VTABZ ; GENERATE BASE ADR
00CB74  1  A5 28        SCRL1: LDA BASL ; COPY BASL,H
00CB76  1  85 2A          STA BAS2L ; TO BAS2L,H
00CB78  1  A5 29          LDA BASH
00CB7A  1  85 2B          STA BAS2H
00CB7C  1  A4 21          LDY WNDWDTH ; INIT Y TO RIGHTMOST INDEX
00CB7E  1  88             DEY ; OF SCROLLING WINDOW
00CB7F  1  68             PLA
00CB80  1  69 01          ADC #$01 ; INCR LINE NUMBER
00CB82  1  C5 23          CMP WNDBTM ; DONE?
00CB84  1  B0 0D          BCS SCRL3 ; YES, FINISH
00CB86  1  48             PHA
00CB87  1  20 22 CB       JSR VTABZ ; FORM BASL,H (BASE ADDR)
00CB8A  1  B1 28        SCRL2: LDA (BASL),Y ; MOVE A CHR UP ON LINE
00CB8C  1               .ifdef APPLE1
00CB8C  1  EA             NOP
00CB8D  1  EA             NOP
00CB8E  1               .else
00CB8E  1                 STA (BAS2L),Y
00CB8E  1               .endif
00CB8E  1  88             DEY ; NEXT CHAR OF LINE
00CB8F  1  10 F9          BPL SCRL2
00CB91  1  30 E1          BMI SCRL1 ; NEXT LINE (ALWAYS TAKEN)
00CB93  1  A0 00        SCRL3: LDY #$00 ; CLEAR BOTTOM LINE
00CB95  1  20 9C CB       JSR CLEOLZ ; GET BASE ADDR FOR BOTTOM LINE
00CB98  1  B0 86          BCS VTAB ; CARRY IS SET
00CB9A  1  A4 24        CLREOL: LDY CH ; CURSOR H INDEX
00CB9C  1  A9 A0        CLEOLZ: LDA #$A0
00CB9E  1               CLEOL2:
00CB9E  1               .ifdef APPLE1
00CB9E  1  EA             NOP
00CB9F  1  EA             NOP
00CBA0  1               .else
00CBA0  1                 STA (BASL),Y ; STORE BLANKS FROM 'HERE'
00CBA0  1               .endif
00CBA0  1  C8             INY ; TO END OF LINES (WNDWDTH)
00CBA1  1  C4 21          CPY WNDWDTH
00CBA3  1  90 F9          BCC CLEOL2
00CBA5  1  60             RTS
00CBA6  1  38           WAIT: SEC
00CBA7  1  48           WAIT2: PHA
00CBA8  1  E9 01        WAIT3: SBC #$01
00CBAA  1  D0 FC          BNE WAIT3 ; 1.0204 USEC
00CBAC  1  68             PLA ; (13+27/2*A+5/2*A*A)
00CBAD  1  E9 01          SBC #$01
00CBAF  1  D0 F6          BNE WAIT2
00CBB1  1  60             RTS
00CBB2  1  E6 42        NXTA4: INC A4L ; INCR 2-BYTE A4
00CBB4  1  D0 02          BNE NXTA1 ; AND A1
00CBB6  1  E6 43          INC A4H
00CBB8  1  A5 3C        NXTA1: LDA A1L ; INCR 2-BYTE A1.
00CBBA  1  C5 3E          CMP A2L
00CBBC  1  A5 3D          LDA A1H ; AND COMPARE TO A2
00CBBE  1  E5 3F          SBC A2H
00CBC0  1  E6 3C          INC A1L ; (CARRY SET IF >=)
00CBC2  1  D0 02          BNE RTS4B
00CBC4  1  E6 3D          INC A1H
00CBC6  1  60           RTS4B: RTS
00CBC7  1               .ifdef APPLE1
00CBC7  1  A0 48        HEADR: LDY #$48 ; WRITE A*256 'LONG 1'
00CBC9  1               .else
00CBC9  1               HEADR: LDY #$4B ; WRITE A*256 'LONG 1'
00CBC9  1               .endif
00CBC9  1  20 D9 CB       JSR ZERDLY ; HALF CYCLES
00CBCC  1  D0 F9          BNE HEADR ; (650 USEC EACH)
00CBCE  1  69 FE          ADC #$FE
00CBD0  1  B0 F5          BCS HEADR ; THEN A 'SHORT 0'
00CBD2  1  A0 21          LDY #$21 ; (400 USEC)
00CBD4  1  20 D9 CB     WRBIT: JSR ZERDLY ; WRITE TWO HALF CYCLES
00CBD7  1  C8             INY ; OF 250 USEC ('0')
00CBD8  1  C8             INY ; OR 500 USEC ('0')
00CBD9  1  88           ZERDLY: DEY
00CBDA  1  D0 FD          BNE ZERDLY
00CBDC  1  90 05          BCC WRTAPE ; Y IS COUNT FOR
00CBDE  1  A0 32          LDY #$32 ; TIMING LOOP
00CBE0  1  88           ONEDLY: DEY
00CBE1  1  D0 FD          BNE ONEDLY
00CBE3  1               .ifdef APPLE1
00CBE3  1  BC 00 C0     WRTAPE: LDY IOADR,X
00CBE6  1  A0 2C          LDY #$2C
00CBE8  1  CA             DEX
00CBE9  1               .else
00CBE9  1               WRTAPE: LDY TAPEOUT
00CBE9  1                 LDY  #$2C
00CBE9  1                 DEX
00CBE9  1               .endif
00CBE9  1  60             RTS
00CBEA  1  A2 08        RDBYTE: LDX #$08 ; 8 BITS TO READ
00CBEC  1  48           RDBYT2: PHA ; READ TWO TRANSITIONS
00CBED  1  20 F8 CB       JSR RD2BIT ; (FIND EDGE)
00CBF0  1  68             PLA
00CBF1  1  2A             ROL ; NEXT BIT
00CBF2  1  A0 3A          LDY #$3A ; COUNT FOR SAMPLES
00CBF4  1  CA             DEX
00CBF5  1  D0 F5          BNE RDBYT2
00CBF7  1  60             RTS
00CBF8  1  20 FB CB     RD2BIT: JSR RDBIT
00CBFB  1  88           RDBIT: DEY ; DECR Y UNTIL
00CBFC  1               .ifdef APPLE1
00CBFC  1  AD 81 C0       LDA $C081 ; TAPE TRANSITION
00CBFF  1  C5 2F          CMP LASTIN
00CC01  1  F0 F8          BEQ RDBIT
00CC03  1  85 2F          STA LASTIN
00CC05  1  C0 80          CPY #$80 ; SET CARRY ON Y
00CC07  1  60             RTS
00CC08  1  EA             NOP
00CC09  1  EA             NOP
00CC0A  1               .else
00CC0A  1                 LDA TAPEIN ; TAPE TRANSITION
00CC0A  1                 EOR LASTIN
00CC0A  1                 BPL RDBIT
00CC0A  1                 EOR LASTIN
00CC0A  1                 STA LASTIN
00CC0A  1                 CPY #$80 ; SET CARRY ON Y
00CC0A  1                 RTS
00CC0A  1               .endif
00CC0A  1  A4 24        RDKEY: LDY CH
00CC0C  1  B1 28          LDA (BASL),Y ; SET SCREEN TO FLASH
00CC0E  1  48             PHA
00CC0F  1  29 3F          AND #$3F
00CC11  1  09 40          ORA #$40
00CC13  1               .ifdef APPLE1
00CC13  1  EA             NOP
00CC14  1  EA             NOP
00CC15  1               .else
00CC15  1                 STA (BASL),Y
00CC15  1               .endif
00CC15  1  68             PLA
00CC16  1               .ifdef APPLE1
00CC16  1  EA             NOP
00CC17  1  EA             NOP
00CC18  1  EA             NOP
00CC19  1               .else
00CC19  1                 JMP (KSWL) ; GO TO USER KEY-IN
00CC19  1               .endif
00CC19  1  E6 4E        KEYIN: INC RNDL
00CC1B  1  D0 02          BNE KEYIN2 ; INCR RND NUMBER
00CC1D  1  E6 4F          INC RNDH
00CC1F  1               KEYIN2:
00CC1F  1               .ifdef APPLE1
00CC1F  1  AD 05 A0       LDA     ACE_LSR        ; Check status.
00CC22  1  29 01          AND     #$01           ; Key ready?
00CC24  1               
00CC24  1                 ; LDA $D011
00CC24  1               .else
00CC24  1                 BIT KBD ; KEY DOWN?
00CC24  1               .endif
00CC24  1                 ; BPL KEYIN ; LOOP
00CC24  1  F0 F3          BEQ KEYIN     ; no key, loop
00CC26  1               .ifdef APPLE1
00CC26  1  EA             NOP
00CC27  1  EA             NOP
00CC28  1               .else
00CC28  1                 STA (BASL),Y ; REPLACE FLASHING SCREEN
00CC28  1               .endif
00CC28  1               .ifdef APPLE1
00CC28  1                 ; LDA $D010 ; GET KEYCODE
00CC28  1  AD 00 A0       LDA ACE_DATA
00CC2B  1  4C 88 C5       JMP L7
00CC2E  1  EA             NOP
00CC2F  1               .else
00CC2F  1                 LDA KBD
00CC2F  1                 BIT KBDSTRB ; CLR KEY STROBE
00CC2F  1                 RTS
00CC2F  1               .endif
00CC2F  1  20 0A CC     ESC: JSR RDKEY ; GET KEYCODE
00CC32  1  20 2A CB       JSR ESC1 ; HANDLE ESC FUNC.
00CC35  1  20 0A CC     RDCHAR: JSR RDKEY ; READ KEY
00CC38  1  C9 9B          CMP #$9B ; ESC?
00CC3A  1  F0 F3          BEQ ESC ; YES, DON'T RETURN
00CC3C  1  60             RTS
00CC3D  1  A5 32        NOTCR: LDA INVFLG
00CC3F  1  48             PHA
00CC40  1  A9 FF          LDA #$FF
00CC42  1  85 32          STA INVFLG ; ECHO USER LINE
00CC44  1  BD 00 02       LDA IN,X ; NON INVERSE
00CC47  1  20 ED CC       JSR COUT
00CC4A  1  68             PLA
00CC4B  1  85 32          STA INVFLG
00CC4D  1  BD 00 02       LDA IN,X
00CC50  1               .ifdef APPLE1
00CC50  1  C9 DF          CMP #$DF ; CHECK FOR EDIT KEYS
00CC52  1               .else
00CC52  1                 CMP #$88 ; CHECK FOR EDIT KEYS
00CC52  1               .endif
00CC52  1  F0 1D          BEQ BCKSPC ; BS, CTRL-X
00CC54  1  C9 98          CMP #$98
00CC56  1  F0 0A          BEQ CANCEL
00CC58  1  E0 F8          CPX #$F8 ; MARGIN?
00CC5A  1  90 03          BCC NOTCR1
00CC5C  1  20 3A CE       JSR BELL ; YES, SOUND BELL
00CC5F  1  E8           NOTCR1: INX ; ADVANCE INPUT INDEX
00CC60  1  D0 13          BNE NXTCHAR
00CC62  1  A9 DC        CANCEL: LDA #$DC ; BACKSLASH AFTER CANCELLED LINE
00CC64  1  20 ED CC       JSR COUT
00CC67  1  20 8E CC     GETLNZ: JSR CROUT ; OUTPUT CR
00CC6A  1  A5 33        GETLN: LDA PROMPT
00CC6C  1  20 ED CC       JSR COUT ; OUTPUT PROMPT CHAR
00CC6F  1  A2 01          LDX #$01 ; INIT INPUT INDEX
00CC71  1  8A           BCKSPC: TXA ; WILL BACKSPACE TO 0
00CC72  1  F0 F3          BEQ GETLNZ
00CC74  1  CA             DEX
00CC75  1  20 35 CC     NXTCHAR: JSR RDCHAR
00CC78  1  C9 95          CMP #PICK ; USE SCREEN CHAR
00CC7A  1  D0 02          BNE CAPTST ; FOR CTRL-U
00CC7C  1  B1 28          LDA (BASL),Y
00CC7E  1  C9 E0        CAPTST: CMP #$E0
00CC80  1  90 02          BCC ADDINP ; CONVERT TO CAPS
00CC82  1  29 DF          AND #$DF
00CC84  1  9D 00 02     ADDINP: STA IN,X ; ADD TO INPUT BUF
00CC87  1  C9 8D          CMP #$8D
00CC89  1  D0 B2          BNE NOTCR
00CC8B  1  20 9A CB       JSR CLREOL ; CLR TO EOL IF CR
00CC8E  1  A9 8D        CROUT: LDA #$8D
00CC90  1  D0 5B          BNE COUT
00CC92  1  A4 3D        PRA1: LDY A1H ; PRINT CR,A1 IN HEX
00CC94  1  A6 3C          LDX A1L
00CC96  1  20 8E CC     PRYX2: JSR CROUT
00CC99  1  20 3E C8       JSR PRNTYX
00CC9C  1  A0 00          LDY #$00
00CC9E  1  A9 AD          LDA #$AD ; PRINT '-'
00CCA0  1  4C ED CC       JMP COUT
00CCA3  1  A5 3C        XAM8: LDA A1L
00CCA5  1  09 07          ORA #$07 ; SET TO FINISH AT
00CCA7  1  85 3E          STA A2L ; MOD 8=7
00CCA9  1  A5 3D          LDA A1H
00CCAB  1  85 3F          STA A2H
00CCAD  1  A5 3C        MODSCHK: LDA A1L
00CCAF  1  29 07          AND #$07
00CCB1  1  D0 03          BNE DATAOUT
00CCB3  1  20 92 CC     XAM: JSR PRA1
00CCB6  1  A9 A0        DATAOUT: LDA #$A0
00CCB8  1  20 ED CC       JSR COUT ; OUTPUT BLANK
00CCBB  1  B1 3C          LDA (A1L),Y
00CCBD  1  20 DA CC       JSR PRBYTE ; OUTPUT BYTE IN HEX
00CCC0  1  20 B8 CB       JSR NXTA1
00CCC3  1  90 E8          BCC MODSCHK ; CHECK IF TIME TO,
00CCC5  1  60           RTS4C: RTS ; PRINT ADDR
00CCC6  1  4A           XAMPM: LSR A ; DETERMINE IF MON
00CCC7  1  90 EA          BCC XAM ; MODE IS XAM
00CCC9  1  4A             LSR A ; ADD, OR SUB
00CCCA  1  4A             LSR A
00CCCB  1  A5 3E          LDA A2L
00CCCD  1  90 02          BCC @ADD
00CCCF  1  49 FF          EOR #$FF ; SUB: FORM 2'S COMPLEMENT
00CCD1  1  65 3C        @ADD: ADC A1L
00CCD3  1  48             PHA
00CCD4  1  A9 BD          LDA #$BD
00CCD6  1  20 ED CC       JSR COUT ; PRINT '=', THEN RESULT
00CCD9  1  68             PLA
00CCDA  1  48           PRBYTE: PHA ; PRINT BYTE AS 2 HEX
00CCDB  1  4A             LSR A ; DIGITS, DESTROYS A-REG
00CCDC  1  4A             LSR A
00CCDD  1  4A             LSR A
00CCDE  1  4A             LSR A
00CCDF  1  20 E5 CC       JSR PRHEXZ
00CCE2  1  68             PLA
00CCE3  1  29 0F        PRHEX: AND #$0F ; PRINT HEX DIG IN A-REG
00CCE5  1  09 B0        PRHEXZ: ORA #$B0 ; LSB'S
00CCE7  1  C9 BA          CMP #$BA
00CCE9  1  90 02          BCC COUT
00CCEB  1  69 06          ADC #$06
00CCED  1               COUT:
00CCED  1               .ifdef APPLE1
00CCED  1  20 79 C5       JSR L3
00CCF0  1               .else
00CCF0  1                JMP (CSWL) ; VECTOR TO USER OUTPUT ROUTINE
00CCF0  1               .endif
00CCF0  1  C9 A0        COUT1: CMP #$A0
00CCF2  1  90 02          BCC COUTZ ; DON'T OUTPUT CTRL'S INVERSE
00CCF4  1  25 32          AND INVFLG ; MASK WITH INVERSE FLAG
00CCF6  1  84 35        COUTZ: STY YSAV1 ; SAV Y-REG
00CCF8  1  48             PHA ; SAV A-REG
00CCF9  1  20 FB CA       JSR VIDOUT ; OUTPUT A-REG AS ASCII
00CCFC  1  68             PLA ; RESTORE A-REG
00CCFD  1  A4 35          LDY YSAV1 ; AND Y-REG
00CCFF  1  60             RTS ; THEN RETURN
00CD00  1  C6 34        BL1: DEC YSAV
00CD02  1  F0 9F          BEQ XAM8
00CD04  1  CA           BLANK: DEX ; BLANK TO MON
00CD05  1  D0 16          BNE SETMDZ ; AFTER BLANK
00CD07  1  C9 BA          CMP #$BA ; DATA STORE MODE?
00CD09  1  D0 BB          BNE XAMPM ; NO, XAM, ADD, OR SUB
00CD0B  1  85 31        STOR: STA MODE ; KEEP IN STORE MODE
00CD0D  1  A5 3E          LDA A2L
00CD0F  1  91 40          STA (A3L),Y ; STORE AS LOW BYTE AS (A3)
00CD11  1  E6 40          INC A3L
00CD13  1  D0 02          BNE RTS5 ; INCR A3, RETURN
00CD15  1  E6 41          INC A3H
00CD17  1  60           RTS5: RTS
00CD18  1  A4 34        SETMODE: LDY YSAV ; SAVE CONVERTED ':', '+',
00CD1A  1  B9 FF 01       LDA IN-1,Y ; '-', '.' AS MODE.
00CD1D  1  85 31        SETMDZ: STA MODE
00CD1F  1  60             RTS
00CD20  1  A2 01        LT: LDX #$01
00CD22  1  B5 3E        LT2: LDA A2L,X ; COPY A2 (2 BYTES) TO
00CD24  1  95 42          STA A4L,X ; A4 AND A5
00CD26  1  95 44          STA A5L,X
00CD28  1  CA             DEX
00CD29  1  10 F7          BPL LT2
00CD2B  1  60             RTS
00CD2C  1  B1 3C        MOVE: LDA (A1L),Y ; MOVE (A1 TO A2) TO
00CD2E  1  91 42          STA (A4L),Y ; (A4)
00CD30  1  20 B2 CB       JSR NXTA4
00CD33  1  90 F7          BCC MOVE
00CD35  1  60             RTS
00CD36  1  B1 3C        VFY: LDA (A1L),Y ; VERIFY (A1 TO A2) WITH
00CD38  1  D1 42          CMP (A4L),Y ; (A4)
00CD3A  1  F0 1C          BEQ VFYOK
00CD3C  1  20 92 CC       JSR PRA1
00CD3F  1  B1 3C          LDA (A1L),Y
00CD41  1  20 DA CC       JSR PRBYTE
00CD44  1  A9 A0          LDA #$A0
00CD46  1  20 ED CC       JSR COUT
00CD49  1  A9 A8          LDA #$A8
00CD4B  1  20 ED CC       JSR COUT
00CD4E  1  B1 42          LDA (A4L),Y
00CD50  1  20 DA CC       JSR PRBYTE
00CD53  1  A9 A9          LDA #$A9
00CD55  1  20 ED CC       JSR COUT
00CD58  1  20 B2 CB     VFYOK: JSR NXTA4
00CD5B  1  90 D9          BCC VFY
00CD5D  1  60             RTS
00CD5E  1  20 75 CD     LIST: JSR A1PC ; MOVE A1 (2 BYTES) TO
00CD61  1  A9 14          LDA #$14 ; PC IF SPEC'D AND
00CD63  1  48           LIST2: PHA ; DISEMBLE 20 INSTRS
00CD64  1  20 CE C7       JSR INSTDSP
00CD67  1  20 51 C8       JSR PCADJ ; ADJUST PC EACH INSTR
00CD6A  1  85 3A          STA PCL
00CD6C  1  84 3B          STY PCH
00CD6E  1  68             PLA
00CD6F  1  38             SEC
00CD70  1  E9 01          SBC #$01 ; NEXT OF 20 INSTRS
00CD72  1  D0 EF          BNE LIST2
00CD74  1  60             RTS
00CD75  1  8A           A1PC: TXA ; IF USER SPEC'D ADR
00CD76  1  F0 07          BEQ A1PCRTS ; COPY FROM A1 TO PC
00CD78  1  B5 3C        A1PCLP: LDA A1L,X
00CD7A  1  95 3A          STA PCL,X
00CD7C  1  CA             DEX
00CD7D  1  10 F9          BPL A1PCLP
00CD7F  1  60           A1PCRTS: RTS
00CD80  1  A0 3F        SETINV: LDY #$3F ; SET FOR INVERSE VID
00CD82  1  D0 02          BNE SETIFLG ; VIA COUT1
00CD84  1  A0 FF        SETNORM: LDY #$FF ; SET FOR NORMAL VID
00CD86  1  84 32        SETIFLG: STY INVFLG
00CD88  1  60             RTS
00CD89  1  A9 00        SETKBD: LDA #$00 ; SIMULATE PORT #0 INPUT
00CD8B  1  85 3E        INPORT: STA A2L ; SPECIFIED (KEYIN ROUTINE)
00CD8D  1  A2 38        INPRT: LDX #KSWL
00CD8F  1  A0 19          LDY #<KEYIN
00CD91  1  D0 08          BNE IOPRT
00CD93  1  A9 00        SETVID: LDA #$00 ; SIMULATE PORT #0 OUTPUT
00CD95  1  85 3E        OUTPORT: STA A2L ; SPECIFIED (COUT1 ROUTINE)
00CD97  1  A2 36        OUTPRT: LDX #CSWL
00CD99  1  A0 F0          LDY #<COUT1
00CD9B  1  A5 3E        IOPRT: LDA A2L ; SET RAM IN/OUT VECTORS
00CD9D  1  29 0F          AND #$0F
00CD9F  1  F0 06          BEQ IOPRT1
00CDA1  1  09 C0          ORA #>IOADR
00CDA3  1  A0 00          LDY #$00
00CDA5  1  F0 02          BEQ IOPRT2
00CDA7  1               .ifdef APPLE1
00CDA7  1  A9 FD        IOPRT1: LDA #$FD
00CDA9  1               .else
00CDA9  1               IOPRT1: LDA #>COUT1
00CDA9  1               .endif
00CDA9  1  94 00        IOPRT2: STY LOC0,X
00CDAB  1  95 01          STA LOC1,X
00CDAD  1  60             RTS
00CDAE  1  EA             NOP
00CDAF  1  EA             NOP
00CDB0  1  4C 00 E0     XBASIC: JMP BASIC ; TO BASIC WITH SCRATCH
00CDB3  1  4C B3 E2     BASCONT: JMP BASIC2 ; CONTINUE BASIC
00CDB6  1  20 75 CD     GO: JSR A1PC ; ADR TO PC IF SPEC'D
00CDB9  1  20 3F CE       JSR RESTORE ; RESTORE META REGS
00CDBC  1  6C 3A 00       JMP (PCL) ; GO TO USER SUBR
00CDBF  1  4C D5 C9     REGZ: JMP REGDSP ; TO REG DISPLAY
00CDC2  1  C6 34        TRACE: DEC YSAV
00CDC4  1  20 75 CD     STEPZ: JSR A1PC ; ADR TO PC IF SPEC'D
00CDC7  1  4C 41 C9       JMP STEP ; TAKE ONE STEP
00CDCA  1  4C F8 03     USR: JMP USRADR ; TO USR SUBR AT USRADR
00CDCD  1  A9 40        WRITE: LDA #$40
00CDCF  1  20 C7 CB       JSR HEADR ; WRITE 10-SEC HEADER
00CDD2  1  A0 27          LDY #$27
00CDD4  1  A2 00        WR1: LDX #$00
00CDD6  1  41 3C          EOR (A1L,X)
00CDD8  1  48             PHA
00CDD9  1  A1 3C          LDA (A1L,X)
00CDDB  1  20 ED CD       JSR WRBYTE
00CDDE  1  20 B8 CB       JSR NXTA1
00CDE1  1  A0 1D          LDY #$1D
00CDE3  1  68             PLA
00CDE4  1  90 EE          BCC WR1
00CDE6  1  A0 22          LDY #$22
00CDE8  1  20 ED CD       JSR WRBYTE
00CDEB  1  F0 4D          BEQ BELL
00CDED  1  A2 10        WRBYTE: LDX #$10
00CDEF  1  0A           WRBYT2: ASL A
00CDF0  1  20 D4 CB       JSR WRBIT
00CDF3  1  D0 FA          BNE WRBYT2
00CDF5  1  60             RTS
00CDF6  1  20 00 CD     CRMON: JSR BL1 ; HANDLE A CR AS BLANK
00CDF9  1  68             PLA ; THEN POP STACK
00CDFA  1  68             PLA ; AND RTN TO MON
00CDFB  1  D0 6C          BNE MONZ
00CDFD  1  20 F8 CB     READ: JSR RD2BIT ; FIND TAPEIN EDGE
00CE00  1  A9 16          LDA #$16
00CE02  1  20 C7 CB       JSR HEADR ; DELAY 3.5 SECONDS
00CE05  1  85 2E          STA CHKSUM ; INIT CHKSUM=$FF
00CE07  1  20 F8 CB       JSR RD2BIT ; FIND TAPEIN EDGE
00CE0A  1  A0 24        RD2: LDY #$24 ; LOOK FOR SYNC BIT
00CE0C  1  20 FB CB       JSR RDBIT ; (SHORT 0)
00CE0F  1  B0 F9          BCS RD2 ; LOOP UNTIL FOUND
00CE11  1  20 FB CB       JSR RDBIT ; SKIP SECOND SYNC H-CYCLE
00CE14  1  A0 3B          LDY #$3B ; INDEX FOR 0/1 TEST
00CE16  1  20 EA CB     RD3: JSR RDBYTE ; READ A BYTE
00CE19  1  81 3C          STA (A1L,X) ; STORE AT (A1)
00CE1B  1  45 2E          EOR CHKSUM
00CE1D  1  85 2E          STA CHKSUM ; UPDATE RUNNING CHKSUM
00CE1F  1  20 B8 CB       JSR NXTA1 ; INC A1, COMPARE TO A2
00CE22  1  A0 35          LDY #$35 ; COMPENSATE 0/1 INDEX
00CE24  1  90 F0          BCC RD3 ; LOOP UNTIL DONE
00CE26  1  20 EA CB       JSR RDBYTE ; READ CHKSUM BYTE
00CE29  1  C5 2E          CMP CHKSUM
00CE2B  1  F0 0D          BEQ BELL ; GOOD, SOUND BELL AND RETURN
00CE2D  1  A9 C5        PRERR: LDA #$C5
00CE2F  1  20 ED CC       JSR COUT ; PRINT "ERR", THEN BELL
00CE32  1  A9 D2          LDA #$D2
00CE34  1  20 ED CC       JSR COUT
00CE37  1  20 ED CC       JSR COUT
00CE3A  1  A9 87        BELL: LDA #$87 ; OUTPUT BELL AND RETURN
00CE3C  1  4C ED CC       JMP COUT
00CE3F  1  A5 48        RESTORE: LDA STATUS ; RESTORE 6502 REG CONTENTS
00CE41  1  48             PHA ; USED BY DEBUG SOFTWARE
00CE42  1  A5 45          LDA ACC
00CE44  1  A6 46        RESTR1: LDX XREG
00CE46  1  A4 47          LDY YREG
00CE48  1  28             PLP
00CE49  1  60             RTS
00CE4A  1  85 45        SAVE: STA ACC ; SAVE 6502 REG CONTENTS
00CE4C  1  86 46        SAV1: STX XREG
00CE4E  1  84 47          STY YREG
00CE50  1  08             PHP
00CE51  1  68             PLA
00CE52  1  85 48          STA STATUS
00CE54  1  BA             TSX
00CE55  1  86 49          STX SPNT
00CE57  1  D8             CLD
00CE58  1  60             RTS
00CE59  1               .ifdef APPLE1
00CE59  1  20 78 C5     RESET: JSR L8 ; SET SCREEN MODE
00CE5C  1               .else
00CE5C  1               RESET: JSR SETNORM ; SET SCREEN MODE
00CE5C  1               .endif
00CE5C  1  20 2D CA       JSR INIT ; AND INIT KBD/SCREEN
00CE5F  1               .ifdef APPLE1
00CE5F  1  20 84 CD       JSR SETNORM ; AS I/O DEV'S
00CE62  1               .else
00CE62  1                 JSR SETVID ; AS I/O DEV'S
00CE62  1               .endif
00CE62  1  20 89 CD       JSR SETKBD
00CE65  1  D8           MON: CLD ; MUST SET HEX MODE!
00CE66  1  20 3A CE       JSR BELL
00CE69  1  A9 AA        MONZ: LDA #$AA ; '*' PROMPT FOR MON
00CE6B  1  85 33          STA PROMPT
00CE6D  1  20 67 CC       JSR GETLNZ ; READ A LINE
00CE70  1  20 C7 CE       JSR ZMODE ; CLEAR MON MODE, SCAN IDX
00CE73  1  20 A7 CE     NXTITM: JSR GETNUM ; GET ITEM, NON-HEX
00CE76  1  84 34          STY YSAV ; CHAR IN A-REG
00CE78  1  A0 17          LDY #$17 ; X-REG=0 IF NO HEX INPUT
00CE7A  1  88           CHRSRCH: DEY
00CE7B  1  30 E8          BMI MON ; NOT FOUND, GO TO MON
00CE7D  1  D9 CC CE       CMP CHRTBL,Y ; FIND CMND CHAR IN TEL
00CE80  1  D0 F8          BNE CHRSRCH
00CE82  1  20 BE CE       JSR TOSUB ; FOUND, CALL CORRESPONDING
00CE85  1  A4 34          LDY YSAV ; SUBROUTINE
00CE87  1  4C 73 CE       JMP NXTITM
00CE8A  1  A2 03        DIG: LDX #$03
00CE8C  1  0A             ASL A
00CE8D  1  0A             ASL A ; GOT HEX DIG,
00CE8E  1  0A             ASL A ; SHIFT INTO A2
00CE8F  1  0A             ASL A
00CE90  1  0A           NXTBIT: ASL A
00CE91  1  26 3E          ROL A2L
00CE93  1  26 3F          ROL A2H
00CE95  1  CA             DEX ; LEAVE X=$FF IF DIG
00CE96  1  10 F8          BPL NXTBIT
00CE98  1  A5 31        NXTBAS: LDA MODE
00CE9A  1  D0 06          BNE NXTBS2 ; IF MODE IS ZERO
00CE9C  1  B5 3F          LDA A2H,X ; THEN COPY A2 TO
00CE9E  1  95 3D          STA A1H,X ; A1 AND A3
00CEA0  1  95 41          STA A3H,X
00CEA2  1  E8           NXTBS2: INX
00CEA3  1  F0 F3          BEQ NXTBAS
00CEA5  1  D0 06          BNE NXTCHR
00CEA7  1  A2 00        GETNUM: LDX #$00 ; CLEAR A2
00CEA9  1  86 3E          STX A2L
00CEAB  1  86 3F          STX A2H
00CEAD  1  B9 00 02     NXTCHR: LDA IN,Y ; GET CHAR
00CEB0  1  C8             INY
00CEB1  1  49 B0          EOR #$B0
00CEB3  1  C9 0A          CMP #$0A
00CEB5  1  90 D3          BCC DIG ; IF HEX DIG, THEN
00CEB7  1  69 88          ADC #$88
00CEB9  1  C9 FA          CMP #$FA
00CEBB  1  B0 CD          BCS DIG
00CEBD  1  60             RTS
00CEBE  1  A9 CD        TOSUB: LDA #>GO ; PUSH HIGH-ORDER
00CEC0  1  48             PHA ; SUBR ADR ON STK
00CEC1  1  B9 E3 CE       LDA SUBTBL,Y ; PUSH LOW-ORDER
00CEC4  1  48             PHA ; SUBR ADR ON STK
00CEC5  1  A5 31          LDA MODE
00CEC7  1  A0 00        ZMODE: LDY #$00 ; CLR MODE, OLD MODE
00CEC9  1  84 31           STY MODE ; TO A-REG
00CECB  1  60              RTS ; GO TO SUBR VIA RTS
00CECC  1  BC           CHRTBL: .BYTE $BC ; F("CTRL-C")
00CECD  1  B2             .BYTE $B2 ; F("CTRL-Y")
00CECE  1  BE             .BYTE $BE ; F("CTRL-E")
00CECF  1  ED             .BYTE $ED ; F("T")
00CED0  1  EF             .BYTE $EF ; F("V")
00CED1  1  C4             .BYTE $C4 ; F("CTRL-K")
00CED2  1  EC             .BYTE $EC ; F("S")
00CED3  1  A9             .BYTE $A9 ; F("CTRL-P")
00CED4  1  BB             .BYTE $BB ; F("CTRL-B")
00CED5  1  A6             .BYTE $A6 ; F("-")
00CED6  1  A4             .BYTE $A4 ; F("+")
00CED7  1  06             .BYTE $06 ; F("M") (F=EX-OR $B0+$89)
00CED8  1  95             .BYTE $95 ; F("<")
00CED9  1  07             .BYTE $07 ; F("N")
00CEDA  1  02             .BYTE $02 ; F("I")
00CEDB  1  05             .BYTE $05 ; F("L")
00CEDC  1  F0             .BYTE $F0 ; F("W")
00CEDD  1  00             .BYTE $00 ; F("G")
00CEDE  1  EB             .BYTE $EB ; F("R")
00CEDF  1  93             .BYTE $93 ; F(":")
00CEE0  1  A7             .BYTE $A7 ; F(".")
00CEE1  1  C6             .BYTE $C6 ; F("CR")
00CEE2  1  99             .BYTE $99 ; F(BLANK)
00CEE3  1               
00CEE3  1  B2           SUBTBL: .BYTE <BASCONT-1
00CEE4  1  C9             .BYTE <USR-1
00CEE5  1  BE             .BYTE <REGZ-1
00CEE6  1  C1             .BYTE <TRACE-1
00CEE7  1  35             .BYTE <VFY-1
00CEE8  1  8C             .BYTE <INPRT-1
00CEE9  1  C3             .BYTE <STEPZ-1
00CEEA  1  96             .BYTE <OUTPRT-1
00CEEB  1  AF             .BYTE <XBASIC-1
00CEEC  1  17             .BYTE <SETMODE-1
00CEED  1  17             .BYTE <SETMODE-1
00CEEE  1  2B             .BYTE <MOVE-1
00CEEF  1  1F             .BYTE <LT-1
00CEF0  1  83             .BYTE <SETNORM-1
00CEF1  1  7F             .BYTE <SETINV-1
00CEF2  1  5D             .BYTE <LIST-1
00CEF3  1  CC             .BYTE <WRITE-1
00CEF4  1  B5             .BYTE <GO-1
00CEF5  1  FC             .BYTE <READ-1
00CEF6  1  17             .BYTE <SETMODE-1
00CEF7  1  17             .BYTE <SETMODE-1
00CEF8  1  F5             .BYTE <CRMON-1
00CEF9  1  03             .BYTE <BLANK-1
00CEFA  1               .ifndef APPLE1
00CEFA  1                 .WORD NMI        ;NMI VECTOR
00CEFA  1                 .WORD RESET      ;RESET VECTOR
00CEFA  1                 .WORD IRQ        ;IRQ VECTOR
00CEFA  1               .endif
00CEFA  1               .ifdef WOZMON
00CEFA  1                 .WORD NMI        ;NMI VECTOR
00CEFA  1                 .WORD RESET      ;RESET VECTOR
00CEFA  1                 .WORD IRQ        ;IRQ VECTOR
00CEFA  1               .endif
00CEFA  1               XQTNZ = $3C
00CEFA  1               
00CEFA  1               .ifdef WOZMON
00CEFA  1               .proc WozMon
00CEFA  1               
00CEFA  1               ;  The WOZ Monitor for the Apple 1
00CEFA  1               ;  Written by Steve Wozniak in 1976
00CEFA  1               
00CEFA  1               
00CEFA  1               ; Page 0 Variables
00CEFA  1               
00CEFA  1               XAML            = $24           ;  Last "opened" location Low
00CEFA  1               XAMH            = $25           ;  Last "opened" location High
00CEFA  1               STL             = $26           ;  Store address Low
00CEFA  1               STH             = $27           ;  Store address High
00CEFA  1               L               = $28           ;  Hex value parsing Low
00CEFA  1               H               = $29           ;  Hex value parsing High
00CEFA  1               YSAV            = $2A           ;  Used to see if hex value is given
00CEFA  1               MODE            = $2B           ;  $00=XAM, $7F=STOR, $AE=BLOCK XAM
00CEFA  1               
00CEFA  1               
00CEFA  1               ; Other Variables
00CEFA  1               
00CEFA  1               IN              = $0200         ;  Input buffer to $027F
00CEFA  1               KBD             = $D010         ;  PIA.A keyboard input
00CEFA  1               KBDCR           = $D011         ;  PIA.A keyboard control register
00CEFA  1               DSP             = $D012         ;  PIA.B display output register
00CEFA  1               DSPCR           = $D013         ;  PIA.B display control register
00CEFA  1               
00CEFA  1               ;               .org $FF00
00CEFA  1                              .export RESET
00CEFA  1               
00CEFA  1               RESET:          CLD             ; Clear decimal arithmetic mode.
00CEFA  1                               CLI
00CEFA  1                               LDY #$7F        ; Mask for DSP data direction register.
00CEFA  1                               STY DSP         ; Set it up.
00CEFA  1                               LDA #$A7        ; KBD and DSP control register mask.
00CEFA  1                               STA KBDCR       ; Enable interrupts, set CA1, CB1, for
00CEFA  1                               STA DSPCR       ; positive edge sense/output mode.
00CEFA  1               NOTCR:          CMP #'_'+$80    ; "_"?
00CEFA  1                               BEQ BACKSPACE   ; Yes.
00CEFA  1                               CMP #$9B        ; ESC?
00CEFA  1                               BEQ ESCAPE      ; Yes.
00CEFA  1                               INY             ; Advance text index.
00CEFA  1                               BPL NEXTCHAR    ; Auto ESC if > 127.
00CEFA  1               ESCAPE:         LDA #'\'+$80    ; "\".
00CEFA  1                               JSR ECHO        ; Output it.
00CEFA  1               GETLINE:        LDA #$8D        ; CR.
00CEFA  1                               JSR ECHO        ; Output it.
00CEFA  1                               LDY #$01        ; Initialize text index.
00CEFA  1               BACKSPACE:      DEY             ; Back up text index.
00CEFA  1                               BMI GETLINE     ; Beyond start of line, reinitialize.
00CEFA  1               NEXTCHAR:       LDA KBDCR       ; Key ready?
00CEFA  1                               BPL NEXTCHAR    ; Loop until ready.
00CEFA  1                               LDA KBD         ; Load character. B7 should be ‘1’.
00CEFA  1                               STA IN,Y        ; Add to text buffer.
00CEFA  1                               JSR ECHO        ; Display character.
00CEFA  1                               CMP #$8D        ; CR?
00CEFA  1                               BNE NOTCR       ; No.
00CEFA  1                               LDY #$FF        ; Reset text index.
00CEFA  1                               LDA #$00        ; For XAM mode.
00CEFA  1                               TAX             ; 0->X.
00CEFA  1               SETSTOR:        ASL             ; Leaves $7B if setting STOR mode.
00CEFA  1               SETMODE:        STA MODE        ; $00=XAM $7B=STOR $AE=BLOK XAM
00CEFA  1               BLSKIP:         INY             ; Advance text index.
00CEFA  1               NEXTITEM:       LDA IN,Y        ; Get character.
00CEFA  1                               CMP #$8D        ; CR?
00CEFA  1                               BEQ GETLINE     ; Yes, done this line.
00CEFA  1                               CMP #'.'+$80    ; "."?
00CEFA  1                               BCC BLSKIP      ; Skip delimiter.
00CEFA  1                               BEQ SETMODE     ; Yes. Set STOR mode.
00CEFA  1                               CMP #':'+$80    ; ":"?
00CEFA  1                               BEQ SETSTOR     ; Yes. Set STOR mode.
00CEFA  1                               CMP #'R'+$80    ; "R"?
00CEFA  1                               BEQ RUN         ; Yes. Run user program.
00CEFA  1                               STX L           ; $00-> L.
00CEFA  1                               STX H           ; and H.
00CEFA  1                               STY YSAV        ; Save Y for comparison.
00CEFA  1               NEXTHEX:        LDA IN,Y        ; Get character for hex test.
00CEFA  1                               EOR #$B0        ; Map digits to $0-9.
00CEFA  1                               CMP #$0A        ; Digit?
00CEFA  1                               BCC DIG         ; Yes.
00CEFA  1                               ADC #$88        ; Map letter "A"-"F" to $FA-FF.
00CEFA  1                               CMP #$FA        ; Hex letter?
00CEFA  1                               BCC NOTHEX      ; No, character not hex.
00CEFA  1               DIG:            ASL
00CEFA  1                               ASL             ; Hex digit to MSD of A.
00CEFA  1                               ASL
00CEFA  1                               ASL
00CEFA  1                               LDX #$04        ; Shift count.
00CEFA  1               HEXSHIFT:       ASL             ; Hex digit left, MSB to carry.
00CEFA  1                               ROL L           ; Rotate into LSD.
00CEFA  1                               ROL H           ;  Rotate into MSD’s.
00CEFA  1                               DEX             ; Done 4 shifts?
00CEFA  1                               BNE HEXSHIFT    ; No, loop.
00CEFA  1                               INY             ; Advance text index.
00CEFA  1                               BNE NEXTHEX     ; Always taken. Check next char for hex.
00CEFA  1               NOTHEX:         CPY YSAV        ; Check if L, H empty (no hex digits).
00CEFA  1                               BEQ ESCAPE      ; Yes, generate ESC sequence.
00CEFA  1                               BIT MODE        ; Test MODE byte.
00CEFA  1                               BVC NOTSTOR     ;  B6=0 STOR 1 for XAM & BLOCK XAM
00CEFA  1                               LDA L           ; LSD’s of hex data.
00CEFA  1                               STA (STL,X)     ; Store at current ‘store index’.
00CEFA  1                               INC STL         ; Increment store index.
00CEFA  1                               BNE NEXTITEM    ; Get next item. (no carry).
00CEFA  1                               INC STH         ; Add carry to ‘store index’ high order.
00CEFA  1               TONEXTITEM:     JMP NEXTITEM    ; Get next command item.
00CEFA  1               RUN:            JMP (XAML)      ; Run at current XAM index.
00CEFA  1               NOTSTOR:        BMI XAMNEXT     ; B7=0 for XAM, 1 for BLOCK XAM.
00CEFA  1                               LDX #$02        ; Byte count.
00CEFA  1               SETADR:         LDA L-1,X       ; Copy hex data to
00CEFA  1                               STA STL-1,X     ; ‘store index’.
00CEFA  1                               STA XAML-1,X    ; And to ‘XAM index’.
00CEFA  1                               DEX             ; Next of 2 bytes.
00CEFA  1                               BNE SETADR      ; Loop unless X=0.
00CEFA  1               NXTPRNT:        BNE PRDATA      ; NE means no address to print.
00CEFA  1                               LDA #$8D        ; CR.
00CEFA  1                               JSR ECHO        ; Output it.
00CEFA  1                               LDA XAMH        ; ‘Examine index’ high-order byte.
00CEFA  1                               JSR PRBYTE      ; Output it in hex format.
00CEFA  1                               LDA XAML        ; Low-order ‘examine index’ byte.
00CEFA  1                               JSR PRBYTE      ; Output it in hex format.
00CEFA  1                               LDA #':'+$80    ; ":".
00CEFA  1                               JSR ECHO        ; Output it.
00CEFA  1               PRDATA:         LDA #$A0        ; Blank.
00CEFA  1                               JSR ECHO        ; Output it.
00CEFA  1                               LDA (XAML,X)    ; Get data byte at ‘examine index’.
00CEFA  1                               JSR PRBYTE      ; Output it in hex format.
00CEFA  1               XAMNEXT:        STX MODE        ; 0->MODE (XAM mode).
00CEFA  1                               LDA XAML
00CEFA  1                               CMP L           ; Compare ‘examine index’ to hex data.
00CEFA  1                               LDA XAMH
00CEFA  1                               SBC H
00CEFA  1                               BCS TONEXTITEM  ; Not less, so no more data to output.
00CEFA  1                               INC XAML
00CEFA  1                               BNE MOD8CHK     ; Increment ‘examine index’.
00CEFA  1                               INC XAMH
00CEFA  1               MOD8CHK:        LDA XAML        ; Check low-order ‘examine index’ byte
00CEFA  1                               AND #$07        ; For MOD 8=0
00CEFA  1                               BPL NXTPRNT     ; Always taken.
00CEFA  1               PRBYTE:         PHA             ; Save A for LSD.
00CEFA  1                               LSR
00CEFA  1                               LSR
00CEFA  1                               LSR             ; MSD to LSD position.
00CEFA  1                               LSR
00CEFA  1                               JSR PRHEX       ; Output hex digit.
00CEFA  1                               PLA             ; Restore A.
00CEFA  1               PRHEX:          AND #$0F        ; Mask LSD for hex print.
00CEFA  1                               ORA #'0'+$80    ; Add "0".
00CEFA  1                               CMP #$BA        ; Digit?
00CEFA  1                               BCC ECHO        ; Yes, output it.
00CEFA  1                               ADC #$06        ; Add offset for letter.
00CEFA  1               ECHO:           BIT DSP         ; bit (B7) cleared yet?
00CEFA  1                               BMI ECHO        ; No, wait for display.
00CEFA  1                               STA DSP         ; Output character. Sets DA.
00CEFA  1                               RTS             ; Return.
00CEFA  1                               BRK             ; unused
00CEFA  1                               BRK             ; unused
00CEFA  1               
00CEFA  1               ; Interrupt Vectors
00CEFA  1               
00CEFA  1                               .WORD $0F00     ; NMI
00CEFA  1                               .WORD RESET     ; RESET
00CEFA  1                               .WORD $0000     ; BRK/IRQ
00CEFA  1               .endproc
00CEFA  1               .endif
00CEFA  1               
