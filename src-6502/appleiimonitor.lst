ca65 V2.19 - Git 3dfe03300
Main file   : appleiimonitor.s
Current file: appleiimonitor.s

000000r 1               .segment "APPLE2_MON"
000000r 1               ; Port of Apple II monitor to Apple 1
000000r 1               ;
000000r 1               ; Original port by Winston Gayler with additional adaptations by
000000r 1               ; Wendell Sander. Source code reverse-engineered and ported to CA65
000000r 1               ; assembler by Jeff Tranter <tranter@pobox.com>.
000000r 1               
000000r 1               ; Define to get Apple 1 version, otherwise generates original Apple II
000000r 1               ; code.
000000r 1               APPLE1 = 1
000000r 1               
000000r 1               ; Define if you want the Apple 1 Woz Monitor included in the build. Only
000000r 1               ; works if start address is $F400.
000000r 1               ;WOZMON = 1
000000r 1               
000000r 1               ; Macro to define a string in ASCII with high bit set on each character.
000000r 1               .macro Str Arg
000000r 1                   .repeat .strlen(Arg), I
000000r 1                   .byte   .strat(Arg, I) | $80
000000r 1                   .endrep
000000r 1               .endmacro
000000r 1               
000000r 1               ; ***********************
000000r 1               ; *                     *
000000r 1               ; * APPLE-II            *
000000r 1               ; * MINI-ASSEMBLER      *
000000r 1               ; *                     *
000000r 1               ; * COPYRIGHT 1977 BY   *
000000r 1               ; * APPLE COMPUTER INC. *
000000r 1               ; *                     *
000000r 1               ; * ALL RIGHTS RESERVED *
000000r 1               ; *                     *
000000r 1               ; * S. WOZNIAK          *
000000r 1               ; * A. BAUM             *
000000r 1               ; ***********************
000000r 1               ; TITLE "APPLE-II MINI-ASSEMBLER"
000000r 1               FORMAT = $2E
000000r 1               LENGTH = $2F
000000r 1               MODE =   $31
000000r 1               PROMPT = $33
000000r 1               YSAV =   $34
000000r 1               L =      $35
000000r 1               PCL =    $3A
000000r 1               PCH =    $3B
000000r 1               A1H =    $3D
000000r 1               A2L =    $3E
000000r 1               A2H =    $3F
000000r 1               A4L =    $42
000000r 1               A4H =    $43
000000r 1               FMT =    $44
000000r 1               IN =     $200
000000r 1               ; INSDS2 = $F88E
000000r 1               ; INSTDSP = $F8D0
000000r 1               ; PRBL2 =  $F94A
000000r 1               ; PCADJ =  $F953
000000r 1               ; CHAR1 =  $F9B4
000000r 1               ; CHAR2 =  $F9BA
000000r 1               ; MNEML =  $F9C0
000000r 1               ; MNEMR =  $FA00
000000r 1               CURSUP = $FC1A
000000r 1               ; GETLNZ = $FD67
000000r 1               ; COUT =   $FDED
000000r 1               ; BL1 =    $FE00
000000r 1               ; A1PCLP = $FE78
000000r 1               ; BELL =   $FF3A
000000r 1               ; GETNUM = $FFA7
000000r 1               ; TOSUB =  $FFBE
000000r 1               ; ZMODE =  $FFC7
000000r 1               ; CHRTBL = $FFCC
000000r 1               
000000r 1               .ifdef APPLE1
000000r 1               ;  .org $3500
000000r 1               ;  .org $6500
000000r 1               ;  .org $7500
000000r 1               ;  .org $B500
000000r 1                 .org $F400
00F400  1               .else
00F400  1                 .org $F500
00F400  1               .endif
00F400  1               
00F400  1                 .export MON
00F400  1                 .export REL
00F400  1               
00F400  1  E9 81        REL: SBC #$81 ; IS FMT COMPATIBLE
00F402  1  4A             LSR ; WITH RELATIVE MODE?
00F403  1  D0 14          BNE ERR3 ; NO.
00F405  1  A4 3F          LDY A2H
00F407  1  A6 3E          LDX A2L ; DOUBLE DECREMENT
00F409  1  D0 01          BNE REL2
00F40B  1  88             DEY
00F40C  1  CA           REL2: DEX
00F40D  1  8A             TXA
00F40E  1  18             CLC
00F40F  1  E5 3A          SBC PCL ; FORM ADDR-PC-2
00F411  1  85 3E          STA A2L
00F413  1  10 01          BPL REL3
00F415  1  C8             INY
00F416  1  98           REL3: TYA
00F417  1  E5 3B          SBC PCH
00F419  1  D0 6B        ERR3: BNE ERR ; ERROR IF >1-BYTE BRANCH
00F41B  1  A4 2F        FINDOP: LDY LENGTH
00F41D  1  B9 3D 00     FNDOP2: LDA A1H,Y ; MOVE INST TO (PC)
00F420  1  91 3A          STA (PCL),Y
00F422  1  88             DEY
00F423  1  10 F8          BPL FNDOP2
00F425  1  EA             NOP
00F426  1  EA             NOP
00F427  1  EA             NOP
00F428  1  EA             NOP
00F429  1  EA             NOP
00F42A  1  EA             NOP
00F42B  1               ; JSR CURSUP
00F42B  1               ; JSR CURSUP ; RESTORE CURSOR
00F42B  1  20 D0 F7       JSR INSTDSP ; TYPE FORMATTED LINE
00F42E  1  20 53 F8       JSR PCADJ ; UPDATE PC
00F431  1  84 3B          STY PCH
00F433  1  85 3A          STA PCL
00F435  1  4C 95 F4       JMP NXTLINE ; GET NEXT LINE
00F438  1  20 BE FE     FAKEMON3: JSR TOSUB ; GO TO DELIM HANDLER
00F43B  1  A4 34          LDY YSAV ; RESTORE Y-INDEX
00F43D  1  20 A7 FE     FAKEMON: JSR GETNUM ; READ PARAM
00F440  1  84 34          STY YSAV ; SAVE Y-INDEX
00F442  1  A0 17          LDY #$17 ; INIT DELIMITER INDEX
00F444  1  88           FAKEMON2: DEY ; CHECK NEXT DELIM
00F445  1  30 4B          BMI RESETZ ; ERR IF UNRECOGNIZED DELIM
00F447  1  D9 CC FE       CMP CHRTBL,Y ; COMPARE WITH DELIM TABLE
00F44A  1  D0 F8          BNE FAKEMON2 ; NO MATCH
00F44C  1  C0 15          CPY #$15 ; MATCH, IS IT CR?
00F44E  1  D0 E8          BNE FAKEMON3 ; NO, HANDLE IT IN MONITOR
00F450  1  A5 31          LDA MODE
00F452  1  A0 00          LDY #$0
00F454  1  C6 34          DEC YSAV
00F456  1  20 00 FD       JSR BL1 ; HANDLE CR OUTSIDE MONITOR
00F459  1  4C 95 F4       JMP NXTLINE
00F45C  1  A5 3D        TRYNEXT: LDA A1H ; GET TRIAL OPCODE
00F45E  1               .ifdef APPLE1
00F45E  1  20 6B F5       JSR L6 ; GET FMT+LENGTH FOR OPCODE
00F461  1               .else
00F461  1                 JSR INSDS2 ; GET FMT+LENGTH FOR OPCODE
00F461  1               .endif
00F461  1  AA             TAX
00F462  1  BD 00 F9       LDA MNEMR,X ; GET LOWER MNEMONIC BYTE
00F465  1  C5 42          CMP A4L ; MATCH?
00F467  1  D0 13          BNE NEXTOP ; NO, TRY NEXT OPCODE.
00F469  1  BD C0 F8       LDA MNEML,X ; GET UPPER MNEMONIC BYTE
00F46C  1  C5 43          CMP A4H ; MATCH?
00F46E  1  D0 0C          BNE NEXTOP ; NO, TRY NEXT OPCODE
00F470  1  A5 44          LDA FMT
00F472  1  A4 2E          LDY FORMAT ; GET TRIAL FORMAT
00F474  1  C0 9D          CPY #$9D ; TRIAL FORMAT RELATIVE?
00F476  1  F0 88          BEQ REL ; YES.
00F478  1  C5 2E        NREL: CMP FORMAT ; SAME FORMAT?
00F47A  1  F0 9F          BEQ FINDOP ; YES.
00F47C  1  C6 3D        NEXTOP: DEC A1H ; NO, TRY NEXT OPCODE
00F47E  1  D0 DC          BNE TRYNEXT
00F480  1  E6 44          INC FMT ; NO MORE, TRY WITH LEN=2
00F482  1  C6 35          DEC L ; WAS L=2 ALREADY?
00F484  1  F0 D6          BEQ TRYNEXT ; NO.
00F486  1  A4 34        ERR: LDY YSAV ; YES, UNRECOGNIZED INST.
00F488  1  98           ERR2: TYA
00F489  1  AA             TAX
00F48A  1  20 4A F8       JSR PRBL2 ; PRINT ^ UNDER LAST READ
00F48D  1  A9 DE          LDA #$DE ; CHAR TO INDICATE ERROR
00F48F  1  20 ED FC       JSR COUT ; POSITION.
00F492  1  20 3A FE     RESETZ: JSR BELL
00F495  1  A9 A1        NXTLINE: LDA #$A1 ; '!'
00F497  1  85 33          STA PROMPT ; INITIALIZE PROMPT
00F499  1  20 67 FC       JSR GETLNZ ; GET LINE.
00F49C  1  20 C7 FE       JSR ZMODE ; INIT SCREEN STUFF
00F49F  1  AD 00 02       LDA IN ; GET CHAR
00F4A2  1  C9 A0          CMP #$A0 ; ASCII BLANK?
00F4A4  1  F0 13          BEQ SPACE ; YES
00F4A6  1  C8             INY
00F4A7  1  C9 A4          CMP #$A4 ; ASCII '$' IN COL 1?
00F4A9  1  F0 92          BEQ FAKEMON ; YES, SIMULATE MONITOR
00F4AB  1  88             DEY ; NO, BACKUP A CHAR
00F4AC  1  20 A7 FE       JSR GETNUM ; GET A NUMBER
00F4AF  1  C9 93          CMP #$93 ; ':' TERMINATOR?
00F4B1  1  D0 D5        ERR4: BNE ERR2 ; NO, ERR.
00F4B3  1  8A             TXA
00F4B4  1  F0 D2          BEQ ERR2 ; NO ADR PRECEDING COLON.
00F4B6  1  20 78 FD       JSR A1PCLP ; MOVE ADR TO PCL, PCH.
00F4B9  1  A9 03        SPACE: LDA #$3 ; COUNT OF CHARS IN MNEMONIC
00F4BB  1  85 3D          STA A1H
00F4BD  1  20 34 F5     NXTMN: JSR GETNSP ; GET FIRST MNEM CHAR.
00F4C0  1  0A           NXTM: ASL A
00F4C1  1  E9 BE          SBC #$BE ; SUBTRACT OFFSET
00F4C3  1  C9 C2          CMP #$C2 ; LEGAL CHAR?
00F4C5  1  90 C1          BCC ERR2 ; NO.
00F4C7  1  0A             ASL A ; COMPRESS-LEFT JUSTIFY
00F4C8  1  0A             ASL A
00F4C9  1  A2 04          LDX #$4
00F4CB  1  0A           NXTM2: ASL A ; DO 5 TRIPLE WORD SHIFTS
00F4CC  1  26 42          ROL A4L
00F4CE  1  26 43          ROL A4H
00F4D0  1  CA             DEX
00F4D1  1  10 F8          BPL NXTM2
00F4D3  1  C6 3D          DEC A1H ; DONE WITH 3 CHARS?
00F4D5  1  F0 F4          BEQ NXTM2 ; YES, BUT DO 1 MORE SHIFT
00F4D7  1  10 E4          BPL NXTMN ; NO
00F4D9  1  A2 05        FORM1: LDX #$5 ; 5 CHARS IN ADDR MODE
00F4DB  1  20 34 F5     FORM2: JSR GETNSP ; GET FIRST CHAR OF ADDR
00F4DE  1  84 34          STY YSAV
00F4E0  1  DD B4 F8       CMP CHAR1,X ; FIRST CHAR MATCH PATTERN?
00F4E3  1  D0 13          BNE FORM3 ; NO
00F4E5  1  20 34 F5       JSR GETNSP ; YES, GET SECOND CHAR
00F4E8  1  DD BA F8       CMP CHAR2,X ; MATCHES SECOND HALF?
00F4EB  1  F0 0D          BEQ FORM5 ; YES.
00F4ED  1  BD BA F8       LDA CHAR2,X ; NO, IS SECOND HALF ZERO?
00F4F0  1  F0 07          BEQ FORM4 ; YES.
00F4F2  1  C9 A4          CMP #$A4 ; NO,SECOND HALF OPTIONAL?
00F4F4  1  F0 03          BEQ FORM4 ; YES.
00F4F6  1  A4 34          LDY YSAV
00F4F8  1  18           FORM3: CLC ; CLEAR BIT-NO MATCH
00F4F9  1  88           FORM4: DEY ; BACK UP 1 CHAR
00F4FA  1  26 44        FORM5: ROL FMT ; FORM FORMAT BYTE
00F4FC  1  E0 03          CPX #$3 ; TIME TO CHECK FOR ADDR.
00F4FE  1  D0 0D          BNE FORM7 ; NO
00F500  1  20 A7 FE       JSR GETNUM ; YES
00F503  1  A5 3F          LDA A2H
00F505  1  F0 01          BEQ FORM6 ; HIGH-ORDER BYTE ZERO
00F507  1  E8             INX ; NO, INCR FOR 2-BYTE
00F508  1  86 35        FORM6: STX L ; STORE LENGTH
00F50A  1  A2 03          LDX #$3 ; RELOAD FORMAT INDEX
00F50C  1  88             DEY ; BACKUP A CHAR
00F50D  1  86 3D        FORM7: STX A1H ; SAVE INDEX
00F50F  1  CA             DEX ; DONE WITH FORMAT CHECK?
00F510  1  10 C9          BPL FORM2 ; NO.
00F512  1  A5 44          LDA FMT ; YES, PUT LENGTH
00F514  1  0A             ASL A ; IN LOW BITS
00F515  1  0A             ASL A
00F516  1  05 35          ORA L
00F518  1  C9 20          CMP #$20
00F51A  1  B0 06          BCS FORM8 ; ADD "$" IF NONZERO LENGTH
00F51C  1  A6 35          LDX L ; AND DON'T ALREADY HAVE IT
00F51E  1  F0 02          BEQ FORM8
00F520  1  09 80          ORA #$80
00F522  1  85 44        FORM8: STA FMT
00F524  1  84 34          STY YSAV
00F526  1  B9 00 02       LDA IN,Y ; GET NEXT NONBLANK
00F529  1  C9 BB          CMP #$BB ; '' START OF COMMENT?
00F52B  1  F0 04          BEQ FORM9 ; YES
00F52D  1  C9 8D          CMP #$8D ; CARRIAGE RETURN?
00F52F  1  D0 80          BNE ERR4 ; NO, ERR.
00F531  1  4C 5C F4     FORM9: JMP TRYNEXT
00F534  1  B9 00 02     GETNSP: LDA IN,Y
00F537  1  C8             INY
00F538  1  C9 A0          CMP #$A0 ; GET NEXT NON BLANK CHAR
00F53A  1  F0 F8          BEQ GETNSP
00F53C  1  60             RTS
00F53D  1               
00F53D  1               ; Add filler bytes so that the Mini-Assembler starts at the documented
00F53D  1               ; entry point at address $F666
00F53D  1  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00F541  1  FF FF FF FF  
00F545  1  FF FF FF FF  
00F54D  1  FF FF FF FF  .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00F551  1  FF FF FF FF  
00F555  1  FF FF FF FF  
00F55D  1  FF           .byte $FF
00F55E  1               
00F55E  1               .ifndef APPLE1
00F55E  1               
00F55E  1               .byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
00F55E  1               
00F55E  1               MINIASM:  JMP   RESETZ
00F55E  1               .endif
00F55E  1               
00F55E  1               ; Apple 1 specific code
00F55E  1               .ifdef APPLE1
00F55E  1  A1 3A          LDA   ($3A,X)
00F560  1  A8             TAY
00F561  1  4A             LSR
00F562  1  90 06          BCC   L0+1
00F564  1  4A             LSR
00F565  1  09             .BYTE $09 ; ORA #
00F566  1  4C 92 F4     MINIASM:  JMP   RESETZ
00F569  1  A1 3A        L0: LDA ($3A,X)
00F56B  1  A8           L6: TAY
00F56C  1  4A             LSR A
00F56D  1  90 06          BCC L1
00F56F  1  4A             LSR A
00F570  1  09 80          ORA #$80
00F572  1  4C 93 F7       JMP   INSDS2
00F575  1  4C 9B F7     L1: JMP   IEVEN
00F578  1  A9 7F        L8: LDA   #$7F ; Initialize 6820
00F57A  1  8D 12 D0       STA   $D012
00F57D  1  A2 A7          LDX   #$A7
00F57F  1  8E 11 D0       STX   $D011
00F582  1  8E 13 D0       STX   $D013
00F585  1  A2 8B          LDX   #$8B ; Initialize Serial Card 300 Baud
00F587  1  8E 04 D0       STX   $D004
00F58A  1  A2 96          LDX   #$96
00F58C  1  8E 05 D0       STX   $D005
00F58F  1  60             RTS
00F590  1  2C 12 D0     L3: BIT   $D012 ; Character Out
00F593  1  30 FB        L2: BMI   L3
00F595  1  8D 12 D0       STA   $D012
00F598  1  60             RTS
00F599  1  C9 9B        L7: CMP   #$9B ; Use Esc for line kill
00F59B  1  D0 02          BNE   L4
00F59D  1  A9 98          LDA   #$98
00F59F  1  C9 88        L4: CMP   #$88 ; Use Control h for Backspace
00F5A1  1  D0 02          BNE   L5
00F5A3  1  A9 DF          LDA   #$DF ; Underscore out
00F5A5  1               .ifdef WOZMON
00F5A5  1                 CMP #$91   ; Control-Q typed?
00F5A5  1                 BNE L5     ; If so, jump to WozMon
00F5A5  1                 JMP RESET
00F5A5  1               .endif
00F5A5  1  60           L5:  RTS
00F5A6  1               .ifdef WOZMON
00F5A6  1                 NOP
00F5A6  1                 NOP
00F5A6  1                 NOP
00F5A6  1               .endif
00F5A6  1               
00F5A6  1               ; 346 filler bytes in place of SWEET16 code
00F5A6  1               
00F5A6  1               .ifndef WOZMON
00F5A6  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00F5AA  1  00 00 00 00  
00F5AE  1  00 00        
00F5B0  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00F5B4  1  00 00 00 00  
00F5B8  1  00 00        
00F5BA  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00F5BE  1  00 00 00 00  
00F5C2  1  00 00        
00F5C4  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00F5C8  1  00 00 00 00  
00F5CC  1  00 00        
00F5CE  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00F5D2  1  00 00 00 00  
00F5D6  1  00 00        
00F5D8  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00F5DC  1  00 00 00 00  
00F5E0  1  00 00        
00F5E2  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00F5E6  1  00 00 00 00  
00F5EA  1  00 00        
00F5EC  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00F5F0  1  00 00 00 00  
00F5F4  1  00 00        
00F5F6  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00F5FA  1  00 00 00 00  
00F5FE  1  00 00        
00F600  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00F604  1  00 00 00 00  
00F608  1  00 00        
00F60A  1               
00F60A  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00F60E  1  00 00 00 00  
00F612  1  00 00        
00F614  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00F618  1  00 00 00 00  
00F61C  1  00 00        
00F61E  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00F622  1  00 00 00 00  
00F626  1  00 00        
00F628  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00F62C  1  00 00 00 00  
00F630  1  00 00        
00F632  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00F636  1  00 00 00 00  
00F63A  1  00 00        
00F63C  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00F640  1  00 00 00 00  
00F644  1  00 00        
00F646  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00F64A  1  00 00 00 00  
00F64E  1  00 00        
00F650  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00F654  1  00 00 00 00  
00F658  1  00 00        
00F65A  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00F65E  1  00 00 00 00  
00F662  1  00 00        
00F664  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00F668  1  00 00 00 00  
00F66C  1  00 00        
00F66E  1               
00F66E  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00F672  1  00 00 00 00  
00F676  1  00 00        
00F678  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00F67C  1  00 00 00 00  
00F680  1  00 00        
00F682  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00F686  1  00 00 00 00  
00F68A  1  00 00        
00F68C  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00F690  1  00 00 00 00  
00F694  1  00 00        
00F696  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00F69A  1  00 00 00 00  
00F69E  1  00 00        
00F6A0  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00F6A4  1  00 00 00 00  
00F6A8  1  00 00        
00F6AA  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00F6AE  1  00 00 00 00  
00F6B2  1  00 00        
00F6B4  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00F6B8  1  00 00 00 00  
00F6BC  1  00 00        
00F6BE  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00F6C2  1  00 00 00 00  
00F6C6  1  00 00        
00F6C8  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00F6CC  1  00 00 00 00  
00F6D0  1  00 00        
00F6D2  1               
00F6D2  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00F6D6  1  00 00 00 00  
00F6DA  1  00 00        
00F6DC  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00F6E0  1  00 00 00 00  
00F6E4  1  00 00        
00F6E6  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00F6EA  1  00 00 00 00  
00F6EE  1  00 00        
00F6F0  1  00 00 00 00  .byte 0,0,0,0,0,0,0,0,0,0
00F6F4  1  00 00 00 00  
00F6F8  1  00 00        
00F6FA  1  00 00 00 00  .byte 0,0,0,0,0,0
00F6FE  1  00 00        
00F700  1               
00F700  1               .else
00F700  1               
00F700  1               ; 336 filler bytes in place of SWEET16 code
00F700  1               
00F700  1               .byte 0,0,0,0,0,0,0,0,0,0
00F700  1               .byte 0,0,0,0,0,0,0,0,0,0
00F700  1               .byte 0,0,0,0,0,0,0,0,0,0
00F700  1               .byte 0,0,0,0,0,0,0,0,0,0
00F700  1               .byte 0,0,0,0,0,0,0,0,0,0
00F700  1               .byte 0,0,0,0,0,0,0,0,0,0
00F700  1               .byte 0,0,0,0,0,0,0,0,0,0
00F700  1               .byte 0,0,0,0,0,0,0,0,0,0
00F700  1               .byte 0,0,0,0,0,0,0,0,0,0
00F700  1               .byte 0,0,0,0,0,0,0,0,0,0
00F700  1               
00F700  1               .byte 0,0,0,0,0,0,0,0,0,0
00F700  1               .byte 0,0,0,0,0,0,0,0,0,0
00F700  1               .byte 0,0,0,0,0,0,0,0,0,0
00F700  1               .byte 0,0,0,0,0,0,0,0,0,0
00F700  1               .byte 0,0,0,0,0,0,0,0,0,0
00F700  1               .byte 0,0,0,0,0,0,0,0,0,0
00F700  1               .byte 0,0,0,0,0,0,0,0,0,0
00F700  1               .byte 0,0,0,0,0,0,0,0,0,0
00F700  1               .byte 0,0,0,0,0,0,0,0,0,0
00F700  1               .byte 0,0,0,0,0,0,0,0,0,0
00F700  1               
00F700  1               .byte 0,0,0,0,0,0,0,0,0,0
00F700  1               .byte 0,0,0,0,0,0,0,0,0,0
00F700  1               .byte 0,0,0,0,0,0,0,0,0,0
00F700  1               .byte 0,0,0,0,0,0,0,0,0,0
00F700  1               .byte 0,0,0,0,0,0,0,0,0,0
00F700  1               .byte 0,0,0,0,0,0,0,0,0,0
00F700  1               .byte 0,0,0,0,0,0,0,0,0,0
00F700  1               .byte 0,0,0,0,0,0,0,0,0,0
00F700  1               .byte 0,0,0,0,0,0,0,0,0,0
00F700  1               .byte 0,0,0,0,0,0,0,0,0,0
00F700  1               
00F700  1               .byte 0,0,0,0,0,0,0,0,0,0
00F700  1               .byte 0,0,0,0,0,0,0,0,0,0
00F700  1               .byte 0,0,0,0,0,0,0,0,0,0
00F700  1               .byte 0,0,0,0,0,0
00F700  1               
00F700  1               .endif
00F700  1               
00F700  1               .else
00F700  1               
00F700  1               ; Add filler bytes up to documented SWEET16 entry point at
00F700  1               ; address $X689
00F700  1               .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
00F700  1               .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
00F700  1               
00F700  1               ; ***********************
00F700  1               ; *                     *
00F700  1               ; * APPLE-II PSEUDO     *
00F700  1               ; * MACHINE INTERPRETER *
00F700  1               ; *                     *
00F700  1               ; * COPYRIGHT 1977      *
00F700  1               ; * APPLE COMPUTER INC  *
00F700  1               ; *                     *
00F700  1               ; * ALL RIGHTS RESERVED *
00F700  1               ; * S. WOZNIAK          *
00F700  1               ; *                     *
00F700  1               ; ***********************
00F700  1               ; TITLE "SWEET16 INTERPRETER"
00F700  1               R0L = $0
00F700  1               R0H = $1
00F700  1               R14H = $1D
00F700  1               R15L = $1E
00F700  1               R15H = $1F
00F700  1               SW16PAG = $F7
00F700  1               ; SAVE = $FF4A
00F700  1               ; RESTORE = $FF3F
00F700  1               ;  .ORG $F689
00F700  1               SW16: JSR SAVE ; PRESERVE 6502 REG CONTENTS
00F700  1                 PLA
00F700  1                 STA R15L ; INIT SWEET16 PC
00F700  1                 PLA ; FROM RETURN
00F700  1                 STA R15H ; ADDRESS
00F700  1               SW16B: JSR SW16C ; INTERPRET AND EXECUTE
00F700  1                 JMP SW16B ; ONE SWEET16 INSTR.
00F700  1               SW16C: INC R15L
00F700  1                 BNE SW16D ; INCR SWEET16 PC FOR FETCH
00F700  1                 INC R15H
00F700  1               SW16D: LDA #SW16PAG
00F700  1                 PHA ; PUSH ON STACK FOR RTS
00F700  1                 LDY #$0
00F700  1                 LDA (R15L),Y ; FETCH INSTR
00F700  1                 AND #$F ; MASK REG SPECIFICATION
00F700  1                 ASL A ; DOUBLE FOR TWO BYTE REGISTERS
00F700  1                 TAX ; TO X REG FOR INDEXING
00F700  1                 LSR A
00F700  1                 EOR (R15L),Y ; NOW HAVE OPCODE
00F700  1                 BEQ TOBR ; IF ZERO THEN NON-REG OP
00F700  1                 STX R14H ; INDICATE'PRIOR RESULT REG'
00F700  1                 LSR A
00F700  1                 LSR A ; OPCODE*2 TO LSB'S
00F700  1                 LSR A
00F700  1                 TAY ; TO Y REG FOR INDEXING
00F700  1                 LDA OPTBL-2,Y ; LOW ORDER ADR BYTE
00F700  1                 PHA ; ONTO STACK
00F700  1                 RTS ; GOTO REG-OP ROUTINE
00F700  1               TOBR: INC R15L
00F700  1                 BNE TOBR2 ; INCR PC
00F700  1                 INC R15H
00F700  1               TOBR2: LDA BRTBL,X ; LOW ORDER ADR BYTE
00F700  1                 PHA ; ONTO STACK FOR NON-REG OP
00F700  1                 LDA R14H ; 'PRIOR RESULT REG' INDEX
00F700  1                 LSR A ; PREPARE CARRY FOR BC, BNC.
00F700  1                 RTS ; GOTO NON-REG OP ROUTINE
00F700  1               RTNZ: PLA ; POP RETURN ADDRESS
00F700  1                 PLA
00F700  1                 JSR RESTORE ; RESTORE 6502 REG CONTENTS
00F700  1                 JMP (R15L) ; RETURN TO 6502 CODE VIA PC
00F700  1               SETZ: LDA (R15L),Y ; HIGH-ORDER BYTE OF CONSTANT
00F700  1                 STA R0H,X
00F700  1                 DEY
00F700  1                 LDA (R15L),Y ; LOW-ORDER BYTE OF CONSTANT
00F700  1                 STA R0L,X
00F700  1                 TYA ; Y-REG CONTAINS 1
00F700  1                 SEC
00F700  1                 ADC R15L ; ADD 2 TO PC
00F700  1                 STA R15L
00F700  1                 BCC SET2
00F700  1                 INC R15H
00F700  1               SET2: RTS
00F700  1               OPTBL: .BYTE <SET-1 ; 1X
00F700  1               BRTBL: .BYTE <RTN-1 ; 0
00F700  1                 .BYTE <LD-1 ; 2X
00F700  1                 .BYTE <BR-1 ; 1
00F700  1                 .BYTE <ST-1 ; 3X
00F700  1                 .BYTE <BNC-1 ; 2
00F700  1                 .BYTE <LDAT-1 ; 4X
00F700  1                 .BYTE <BC-1 ; 3
00F700  1                 .BYTE <STAT-1 ; 5X
00F700  1                 .BYTE <BP-1 ; 4
00F700  1                 .BYTE <LDDAT-1 ; 6X
00F700  1                 .BYTE <BM-1 ; 5
00F700  1                 .BYTE <STDAT-1 ; 7X
00F700  1                 .BYTE <BZ-1 ; 6
00F700  1                 .BYTE <POP-1 ; 8X
00F700  1                 .BYTE <BNZ-1 ; 7
00F700  1                 .BYTE <STPAT-1 ; 9X
00F700  1                 .BYTE <BM1-1 ; 8
00F700  1                 .BYTE <ADD-1 ; AX
00F700  1                 .BYTE <BNM1-1 ; 9
00F700  1                 .BYTE <SUB-1 ; BX
00F700  1                 .BYTE <BK-1 ; A
00F700  1                 .BYTE <POPD-1 ; CX
00F700  1                 .BYTE <RS-1 ; B
00F700  1                 .BYTE <CPR-1 ; DX
00F700  1                 .BYTE <BS-1 ; C
00F700  1                 .BYTE <INR-1 ; EX
00F700  1                 .BYTE <NUL-1 ; D
00F700  1                 .BYTE <DCR-1 ; FX
00F700  1                 .BYTE <NUL-1 ; E
00F700  1                 .BYTE <NUL-1 ; UNUSED
00F700  1                 .BYTE <NUL-1 ; F
00F700  1               SET: BPL SETZ ; ALWAYS TAKEN
00F700  1               LD: LDA R0L,X
00F700  1               BK = LD+1
00F700  1                 STA R0L
00F700  1                 LDA R0H,X ; MOVE RX TO R0
00F700  1                 STA R0H
00F700  1                 RTS
00F700  1               ST: LDA R0L
00F700  1                 STA R0L,X ; MOVE R0 TO RX
00F700  1                 LDA R0H
00F700  1                 STA R0H,X
00F700  1                 RTS
00F700  1               STAT: LDA R0L
00F700  1               STAT2: STA (R0L,X) ; STORE BYTE INDIRECT
00F700  1                 LDY #$0
00F700  1               STAT3: STY R14H ; INDICATE R0 IS RESULT NEG
00F700  1               INR: INC R0L,X
00F700  1                 BNE INR2 ; INCR RX
00F700  1                 INC R0H,X
00F700  1               INR2: RTS
00F700  1               LDAT: LDA (R0L,X) ; LOAD INDIRECT (RX)
00F700  1                 STA R0L ; TO R0
00F700  1                 LDY #$0
00F700  1                 STY R0H ; ZERO HIGH-ORDER R0 BYTE
00F700  1                 BEQ STAT3 ; ALWAYS TAKEN
00F700  1               POP: LDY #$0 ; HIGH ORDER BYTE = 0
00F700  1                 BEQ POP2 ; ALWAYS TAKEN
00F700  1               POPD: JSR DCR ; DECR RX
00F700  1                 LDA (R0L,X) ; POP HIGH ORDER BYTE @RX
00F700  1                 TAY ; SAVE IN Y-REG
00F700  1               POP2: JSR DCR ; DECR RX
00F700  1                 LDA (R0L,X) ; LOW-ORDER BYTE
00F700  1                 STA R0L ; TO R0
00F700  1                 STY R0H
00F700  1               POP3: LDY #$0 ; INDICATE R0 AS LAST RESULT REG
00F700  1                 STY R14H
00F700  1                 RTS
00F700  1               LDDAT: JSR LDAT ; LOW-ORDER BYTE TO R0, INCR RX
00F700  1                 LDA (R0L,X) ; HIGH-ORDER BYTE TO R0
00F700  1                 STA R0H
00F700  1                 JMP INR ; INCR RX
00F700  1               STDAT: JSR STAT ; STORE INDIRECT LOW-ORDER
00F700  1                 LDA R0H ; BYTE AND INCR RX. THEN
00F700  1                 STA (R0L,X) ; STORE HIGH-ORDER BYTE.
00F700  1                 JMP INR ; INCR RX AND RETURN
00F700  1               STPAT: JSR DCR ; DECR RX
00F700  1                 LDA R0L
00F700  1                 STA (R0L,X) ; STORE R0 LOW BYTE @RX
00F700  1                 JMP POP3 ; INDICATE R0 AS LAST RSLT REG
00F700  1               DCR: LDA R0L,X
00F700  1                 BNE DCR2 ; DECR RX
00F700  1                 DEC R0H,X
00F700  1               DCR2: DEC R0L,X
00F700  1                 RTS
00F700  1               SUB: LDY #$0 ; RESULT TO R0
00F700  1               CPR: SEC ; NOTE Y-REG = 13*2 FOR CPR
00F700  1                 LDA R0L
00F700  1                 SBC R0L,X
00F700  1                 STA R0L,Y ; R0-RX TO RY
00F700  1                 LDA R0H
00F700  1                 SBC R0H,X
00F700  1               SUB2: STA R0H,Y
00F700  1                 TYA ; LAST RESULT REG*2
00F700  1                 ADC #$0 ; CARRY TO LSB
00F700  1                 STA R14H
00F700  1                 RTS
00F700  1               ADD: LDA R0L
00F700  1                 ADC R0L,X
00F700  1                 STA R0L ; R0+RX TO R0
00F700  1                 LDA R0H
00F700  1                 ADC R0H,X
00F700  1                 LDY #$0 ; R0 FOR RESULT
00F700  1                 BEQ SUB2 ; FINISH ADD
00F700  1               BS: LDA R15L ; NOTE X-REG IS 12*2!
00F700  1                 JSR STAT2 ; PUSH LOW PC BYTE VIA R12
00F700  1                 LDA R15H
00F700  1                 JSR STAT2 ; PUSH HIGH-ORDER PC BYTE
00F700  1               BR: CLC
00F700  1               BNC: BCS BNC2 ; NO CARRY TEST
00F700  1               BR1: LDA (R15L),Y ; DISPLACEMENT BYTE
00F700  1                 BPL BR2
00F700  1                 DEY
00F700  1               BR2: ADC R15L ; ADD TO PC
00F700  1                 STA R15L
00F700  1                 TYA
00F700  1                 ADC R15H
00F700  1                 STA R15H
00F700  1               BNC2: RTS
00F700  1               BC: BCS BR
00F700  1                 RTS
00F700  1               BP: ASL A ; DOUBLE RESULT-REG INDEX
00F700  1                 TAX ; TO X REG FOR INDEXING
00F700  1                 LDA R0H,X ; TEST FOR PLUS
00F700  1                 BPL BR1 ; BRANCH IF SO
00F700  1                 RTS
00F700  1               BM: ASL A ; DOUBLE RESULT-REG INDEX
00F700  1                 TAX
00F700  1                 LDA R0H,X ; TEST FOR MINUS
00F700  1                 BMI BR1
00F700  1                 RTS
00F700  1               BZ: ASL A ; DOUBLE RESULT-REG INDEX
00F700  1                 TAX
00F700  1                 LDA R0L,X ; TEST FOR ZERO
00F700  1                 ORA R0H,X ; (BOTH BYTES)
00F700  1                 BEQ BR1 ; BRANCH IF SO
00F700  1                 RTS
00F700  1               BNZ: ASL A ; DOUBLE RESULT-REG INDEX
00F700  1                 TAX
00F700  1                 LDA R0L,X ; TEST FOR NON-ZERO
00F700  1                 ORA R0H,X ; (BOTH BYTES)
00F700  1                 BNE BR1 ; BRANCH IF SO
00F700  1                 RTS
00F700  1               BM1: ASL A ; DOUBLE RESULT-REG INDEX
00F700  1                 TAX
00F700  1                 LDA R0L,X ; CHECK BOTH BYTES
00F700  1                 AND R0H,X ; FOR $FF (MINUS 1)
00F700  1                 EOR #$FF
00F700  1                 BEQ BR1 ; BRANCH IF SO
00F700  1                 RTS
00F700  1               BNM1: ASL A ; DOUBLE RESULT-REG INDEX
00F700  1                 TAX
00F700  1                 LDA R0L,X
00F700  1                 AND R0H,X ; CHECK BOTH BYTES FOR NO $FF
00F700  1                 EOR #$FF
00F700  1                 BNE BR1 ; BRANCH IF NOT MINUS 1
00F700  1               NUL: RTS
00F700  1               RS: LDX #$18 ; 12*2 FOR R12 AS STACK POINTER
00F700  1                 JSR DCR ; DECR STACK POINTER
00F700  1                 LDA (R0L,X) ; POP HIGH RETURN ADDRESS TO PC
00F700  1                 STA R15H
00F700  1                 JSR DCR ; SAME FOR LOW-ORDER BYTE
00F700  1                 LDA (R0L,X)
00F700  1                 STA R15L
00F700  1                RTS
00F700  1               RTN: JMP RTNZ
00F700  1               
00F700  1               ; Padding bytes to make System Monitor start at $F800
00F700  1                 .byte 0,0,0
00F700  1               
00F700  1               .endif
00F700  1               
00F700  1               ; ***************************
00F700  1               ; *                         *
00F700  1               ; * APPLE II                *
00F700  1               ; * SYSTEM MONITOR          *
00F700  1               ; *                         *
00F700  1               ; * COPYRIGHT 1977 BY       *
00F700  1               ; * APPLE COMPUTER, INC.    *
00F700  1               ; *                         *
00F700  1               ; * ALL RIGHTS RESERVED     *
00F700  1               ; *                         *
00F700  1               ; * S. WOZNIAK              *
00F700  1               ; * A. BAUM                 *
00F700  1               ; *                         *
00F700  1               ; ***************************
00F700  1               ; TITLE "APPLE II SYSTEM MONITOR"
00F700  1               LOC0 = $00
00F700  1               LOC1 = $01
00F700  1               WNDLFT = $20
00F700  1               WNDWDTH = $21
00F700  1               WNDTOP = $22
00F700  1               WNDBTM = $23
00F700  1               CH = $24
00F700  1               CV = $25
00F700  1               GBASL = $26
00F700  1               GBASH = $27
00F700  1               BASL = $28
00F700  1               BASH = $29
00F700  1               BAS2L = $2A
00F700  1               BAS2H = $2B
00F700  1               H2 = $2C
00F700  1               LMNEM = $2C
00F700  1               RTNL = $2C
00F700  1               V2 = $2D
00F700  1               RMNEM = $2D
00F700  1               RTNH = $2D
00F700  1               MASK = $2E
00F700  1               CHKSUM = $2E
00F700  1               ; FORMAT = $2E
00F700  1               LASTIN = $2F
00F700  1               ; LENGTH = $2F
00F700  1               SIGN = $2F
00F700  1               COLOR = $30
00F700  1               ; MODE = $31
00F700  1               INVFLG = $32
00F700  1               ; PROMPT = $33
00F700  1               ; YSAV = $34
00F700  1               YSAV1 = $35
00F700  1               CSWL = $36
00F700  1               CSWH = $37
00F700  1               KSWL = $38
00F700  1               KSWH = $39
00F700  1               ; PCL = $3A
00F700  1               ; PCH = $3B
00F700  1               XQT = $3C
00F700  1               A1L = $3C
00F700  1               ; A1H = $3D
00F700  1               ;A2L = $3E
00F700  1               ;A2H = $3F
00F700  1               A3L = $40
00F700  1               A3H = $41
00F700  1               ;A4L = $42
00F700  1               ;A4H = $43
00F700  1               A5L = $44
00F700  1               A5H = $45
00F700  1               ACC = $45
00F700  1               XREG = $46
00F700  1               YREG = $47
00F700  1               STATUS = $48
00F700  1               SPNT = $49
00F700  1               RNDL = $4E
00F700  1               RNDH = $4F
00F700  1               ACL = $50
00F700  1               ACH = $51
00F700  1               XTNDL = $52
00F700  1               XTNDH = $53
00F700  1               AUXL = $54
00F700  1               AUXH = $55
00F700  1               PICK = $95
00F700  1               ; IN = $0200
00F700  1               USRADR = $03F8
00F700  1               NMI = $03FB
00F700  1               IRQLOC = $03FE
00F700  1               IOADR = $C000
00F700  1               KBD = $C000
00F700  1               KBDSTRB = $C010
00F700  1               TAPEOUT = $C020
00F700  1               SPKR = $C030
00F700  1               TXTCLR = $C050
00F700  1               TXTSET = $C051
00F700  1               MIXCLR = $C052
00F700  1               MIXSET = $C053
00F700  1               LOWSCR = $C054
00F700  1               HISCR = $C055
00F700  1               LORES = $C056
00F700  1               HIRES = $C057
00F700  1               TAPEIN = $C060
00F700  1               PADDL0 = $C064
00F700  1               PTRIG = $C070
00F700  1               BASIC = $E000
00F700  1               .ifdef APPLE1
00F700  1               BASIC2 = $E2B3
00F700  1               .else
00F700  1               BASIC2 = $E003
00F700  1               .endif
00F700  1               ; ORG $F800 ROM START ADDRESS
00F700  1  4A           PLOT: LSR ; Y-COORD/2
00F701  1  08             PHP ; SAVE LSB IN CARRY
00F702  1  20 47 F7       JSR GBASCALC ; CALC BASE ADR IN GBASL,H
00F705  1  28             PLP ; RESTORE LSB FROM CARRY
00F706  1  A9 0F          LDA #$0F ; MASK $0F IF EVEN
00F708  1  90 02          BCC RTMASK
00F70A  1  69 E0          ADC #$E0 ; MASK $F0 IF ODD
00F70C  1  85 2E        RTMASK: STA MASK
00F70E  1  B1 26        PLOT1: LDA (GBASL),Y ; DATA
00F710  1  45 30          EOR COLOR ; EOR COLOR
00F712  1  25 2E          AND MASK ; AND MASK
00F714  1  51 26          EOR (GBASL),Y ; XOR DATA
00F716  1  91 26          STA (GBASL),Y ; TO DATA
00F718  1  60             RTS
00F719  1  20 00 F7     HLINE: JSR PLOT ; PLOT SQUARE
00F71C  1  C4 2C        HLINE1: CPY H2 ; DONE?
00F71E  1  B0 11          BCS RTS1 ; YES, RETURN
00F720  1  C8             INY ; NO, INCR INDEX (X-COORD)
00F721  1  20 0E F7       JSR PLOT1 ; PLOT NEXT SQUARE
00F724  1  90 F6          BCC HLINE1 ; ALWAYS TAKEN
00F726  1  69 01        VLINEZ: ADC #$01 ; NEXT Y-COORD
00F728  1  48           VLINE: PHA ; SAVE ON STACK
00F729  1  20 00 F7       JSR PLOT ; PLOT SQUARE
00F72C  1  68             PLA
00F72D  1  C5 2D          CMP V2 ; DONE?
00F72F  1  90 F5          BCC VLINEZ ; NO, LOOP
00F731  1  60           RTS1: RTS
00F732  1  A0 2F        CLRSCR: LDY #$2F ; MAX Y, FULL SCRN CLR
00F734  1  D0 02          BNE CLRSC2 ; ALWAYS TAKEN
00F736  1  A0 27        CLRTOP: LDY #$27 ; MAX Y, TOP SCREEN CLR
00F738  1  84 2D        CLRSC2: STY V2 ; STORE AS BOTTOM COORD
00F73A  1               ; FOR VLINE CALLS
00F73A  1  A0 27          LDY #$27 ; RIGHTMOST X-COORD (COLUMN)
00F73C  1  A9 00        CLRSC3: LDA #$00 ; TOP COORD FOR VLINE CALLS
00F73E  1  85 30          STA COLOR ; CLEAR COLOR (BLACK)
00F740  1  20 28 F7       JSR VLINE ; DRAW VLINE
00F743  1  88             DEY ; NEXT LEFTMOST X-COORD
00F744  1  10 F6          BPL CLRSC3 ; LOOP UNTIL DONE
00F746  1  60             RTS
00F747  1  48           GBASCALC: PHA ; FOR INPUT 000DEFGH
00F748  1  4A             LSR
00F749  1  29 03          AND #$03
00F74B  1  09 04          ORA #$04 ; GENERATE GBASH=000001FG
00F74D  1  85 27          STA GBASH
00F74F  1  68             PLA ; AND GBASL=HDEDE000
00F750  1  29 18          AND #$18
00F752  1  90 02          BCC GBCALC
00F754  1  69 7F          ADC #$7F
00F756  1  85 26        GBCALC: STA GBASL
00F758  1  0A             ASL A
00F759  1  0A             ASL A
00F75A  1  05 26          ORA GBASL
00F75C  1  85 26          STA GBASL
00F75E  1  60             RTS
00F75F  1  A5 30        NXTCOL: LDA COLOR ; INCREMENT COLOR BY 3
00F761  1  18             CLC
00F762  1  69 03          ADC #$03
00F764  1  29 0F        SETCOL: AND #$0F ; SETS COLOR=17*A MOD 16
00F766  1  85 30          STA COLOR
00F768  1  0A             ASL A ; BOTH HALF BYTES OF COLOR EQUAL
00F769  1  0A             ASL A
00F76A  1  0A             ASL A
00F76B  1  0A             ASL A
00F76C  1  05 30          ORA COLOR
00F76E  1  85 30          STA COLOR
00F770  1  60             RTS
00F771  1  4A           SCRN: LSR A ; READ SCREEN Y-COORD/2
00F772  1  08             PHP ; SAVE LSB (CARRY)
00F773  1  20 47 F7       JSR GBASCALC ; CALC BASE ADDRESS
00F776  1  B1 26          LDA (GBASL),Y ; GET BYTE
00F778  1  28             PLP ; RESTORE LSB FROM CARRY
00F779  1  90 04        SCRN2: BCC RTMSKZ ; IF EVEN, USE LO H
00F77B  1  4A             LSR A
00F77C  1  4A             LSR A
00F77D  1  4A             LSR A ; SHIFT HIGH HALF BYTE DOWN
00F77E  1  4A             LSR A
00F77F  1  29 0F        RTMSKZ: AND #$0F ; MASK 4-BITS
00F781  1  60             RTS
00F782  1  A6 3A        INSDS1: LDX PCL ; PRINT PCL,H
00F784  1  A4 3B          LDY PCH
00F786  1  20 96 FC       JSR PRYX2
00F789  1  20 48 F8       JSR PRBLNK ; FOLLOWED BY A BLANK
00F78C  1               .ifdef APPLE1
00F78C  1  4C 69 F5       JMP L0
00F78F  1  EA             NOP
00F790  1  EA             NOP
00F791  1  EA             NOP
00F792  1  EA             NOP
00F793  1               INSDS2:
00F793  1               .else
00F793  1                 LDA (PCL,X) ; GET OP CODE
00F793  1               INSDS2: TAY
00F793  1                 LSR A ; EVEN/ODD TEST
00F793  1                 BCC IEVEN
00F793  1                 ROR ; BIT 1 TEST
00F793  1               .endif
00F793  1  B0 10          BCS ERR1 ; XXXXXX11 INVALID OP
00F795  1  C9 A2          CMP #$A2
00F797  1  F0 0C          BEQ ERR1 ; OPCODE $89 INVALID
00F799  1  29 87          AND #$87 ; MASK BITS
00F79B  1  4A           IEVEN: LSR A ; LSB INTO CARRY FOR L/R TEST
00F79C  1  AA             TAX
00F79D  1  BD 62 F8       LDA FMT1,X ; GET FORMAT INDEX BYTE
00F7A0  1  20 79 F7       JSR SCRN2 ; R/L H-BYTE ON CARRY
00F7A3  1  D0 04          BNE GETFMT
00F7A5  1  A0 80        ERR1: LDY #$80 ; SUBSTITUTE $80 FOR INVALID OPS
00F7A7  1  A9 00          LDA #$00 ; SET PRINT FORMAT INDEX TO 0
00F7A9  1  AA           GETFMT: TAX
00F7AA  1  BD A6 F8       LDA FMT2,X ; INDEX INTO PRINT FORMAT TABLE
00F7AD  1  85 2E          STA FORMAT ; SAVE FOR ADR FIELD FORMATTING
00F7AF  1  29 03          AND #$03 ; MASK FOR 2-BIT LENGTH (P=1 BYTE, 1=2 BYTE, 2=3 BYTE)
00F7B1  1  85 2F          STA LENGTH
00F7B3  1  98             TYA ; OPCODE
00F7B4  1  29 8F          AND #$8F ; MASK FOR 1XXX1010 TEST
00F7B6  1  AA             TAX ; SAVE IT
00F7B7  1  98             TYA ; OPCODE TO A AGAIN
00F7B8  1  A0 03          LDY #$03
00F7BA  1  E0 8A          CPX #$8A
00F7BC  1  F0 0B          BEQ MNNDX3
00F7BE  1  4A           MNNDX1: LSR A
00F7BF  1  90 08          BCC MNNDX3 ; FORM INDEX INTO MNEMONIC TABLE
00F7C1  1  4A             LSR A
00F7C2  1  4A           MNNDX2: LSR A ; 1) 1XXX1010->00101XXX
00F7C3  1  09 20          ORA #$20 ; 2) XXXYYY01->00111XXX
00F7C5  1  88             DEY ; 3) XXXYYY10->00110XXX
00F7C6  1  D0 FA          BNE MNNDX2 ; 4) XXXYY100->00100XXX
00F7C8  1  C8             INY ; 5) XXXXX000->000XXXXX
00F7C9  1  88           MNNDX3: DEY
00F7CA  1  D0 F2          BNE MNNDX1
00F7CC  1  60             RTS
00F7CD  1  FF FF FF       .BYTE $FF,$FF,$FF
00F7D0  1  20 82 F7     INSTDSP: JSR INSDS1 ; GEN FMT, LEN BYTES
00F7D3  1  48             PHA ; SAVE MNEMONIC TABLE INDEX
00F7D4  1  B1 3A        PRNTOP: LDA (PCL),Y
00F7D6  1  20 DA FC       JSR PRBYTE
00F7D9  1  A2 01          LDX #$01 ; PRINT 2 BLANKS
00F7DB  1  20 4A F8     PRNTBL: JSR PRBL2
00F7DE  1  C4 2F          CPY LENGTH ; PRINT INST (1-3 BYTES)
00F7E0  1  C8             INY ; IN A 12 CHR FIELD
00F7E1  1  90 F1          BCC PRNTOP
00F7E3  1  A2 03          LDX #$03 ; CHAR COUNT FOR MNEMONIC PRINT
00F7E5  1  C0 04          CPY #$04
00F7E7  1  90 F2          BCC PRNTBL
00F7E9  1  68             PLA ; RECOVER MNEMONIC INDEX
00F7EA  1  A8             TAY
00F7EB  1  B9 C0 F8       LDA MNEML,Y
00F7EE  1  85 2C          STA LMNEM ; FETCH 3-CHAR MNEMONIC
00F7F0  1  B9 00 F9       LDA MNEMR,Y ; (PACKED IN 2-BYTES)
00F7F3  1  85 2D          STA RMNEM
00F7F5  1  A9 00        PRMN1: LDA #$00
00F7F7  1  A0 05          LDY #$05
00F7F9  1  06 2D        PRMN2: ASL RMNEM ; SHIFT 5 BITS OF
00F7FB  1  26 2C          ROL LMNEM ; CHARACTER INTO A
00F7FD  1  2A             ROL ; (CLEARS CARRY)
00F7FE  1  88             DEY
00F7FF  1  D0 F8          BNE PRMN2
00F801  1  69 BF          ADC #$BF ; ADD "?" OFFSET
00F803  1  20 ED FC       JSR COUT ; OUTPUT A CHAR OF MNEM
00F806  1  CA             DEX
00F807  1  D0 EC          BNE PRMN1
00F809  1  20 48 F8       JSR PRBLNK ; OUTPUT 3 BLANKS
00F80C  1  A4 2F          LDY LENGTH
00F80E  1  A2 06          LDX #$06 ; CNT FOR 6 FORMAT BITS
00F810  1  E0 03        PRADR1: CPX #$03
00F812  1  F0 1C          BEQ PRADR5 ; IF X=3 THEN ADDR.
00F814  1  06 2E        PRADR2: ASL FORMAT
00F816  1  90 0E          BCC PRADR3
00F818  1  BD B3 F8       LDA CHAR1-1,X
00F81B  1  20 ED FC       JSR COUT
00F81E  1  BD B9 F8       LDA CHAR2-1,X
00F821  1  F0 03          BEQ PRADR3
00F823  1  20 ED FC       JSR COUT
00F826  1  CA           PRADR3: DEX
00F827  1  D0 E7          BNE PRADR1
00F829  1  60             RTS
00F82A  1  88           PRADR4: DEY
00F82B  1  30 E7          BMI PRADR2
00F82D  1  20 DA FC       JSR PRBYTE
00F830  1  A5 2E        PRADR5: LDA FORMAT
00F832  1  C9 E8          CMP #$E8 ; HANDLE REL ADR MODE
00F834  1  B1 3A          LDA (PCL),Y ; SPECIAL (PRINT TARGET,
00F836  1  90 F2          BCC PRADR4 ; NOT OFFSET)
00F838  1  20 56 F8     RELADR: JSR PCADJ3
00F83B  1  AA             TAX ; PCL,PCH+OFFSET+1 TO A,Y
00F83C  1  E8             INX
00F83D  1  D0 01          BNE PRNTYX ; +1 TO Y,X
00F83F  1  C8             INY
00F840  1  98           PRNTYX: TYA
00F841  1  20 DA FC     PRNTAX: JSR PRBYTE ; OUTPUT TARGET ADR
00F844  1  8A           PRNTX: TXA ; OF BRANCH AND RETURN
00F845  1  4C DA FC       JMP PRBYTE
00F848  1  A2 03        PRBLNK: LDX #$03 ; BLANK COUNT
00F84A  1  A9 A0        PRBL2: LDA #$A0 ; LOAD A SPACE
00F84C  1  20 ED FC     PRBL3: JSR COUT ; OUTPUT A BLANK
00F84F  1  CA             DEX
00F850  1  D0 F8          BNE PRBL2 ; LOOP UNTIL COUNT=0
00F852  1  60             RTS
00F853  1  38           PCADJ: SEC ; 0=1-BYTE, 1=2-BYTE
00F854  1  A5 2F        PCADJ2: LDA LENGTH ; 2=3-BYTE
00F856  1  A4 3B        PCADJ3: LDY PCH
00F858  1  AA             TAX ; TEST DISPLACEMENT SIGN
00F859  1  10 01          BPL PCADJ4 ; (FOR REL BRANCH)
00F85B  1  88             DEY ; EXTEND NEG BY DEC PCH
00F85C  1  65 3A        PCADJ4: ADC PCL
00F85E  1  90 01          BCC RTS2 ; PCL+LENGTH(OR DISPL)+1 TO A
00F860  1  C8             INY ; CARRY INTO Y (PCH)
00F861  1  60           RTS2: RTS
00F862  1               ; FMT1 BYTES: XXXXXXY0 INSTRS
00F862  1               ; IF Y=0 THEN LEFT HALF BYTE
00F862  1               ; IF Y=1 THEN RIGHT HALF BYTE
00F862  1               ; (X=INDEX)
00F862  1  04 20 54 30  FMT1: .BYTE $04,$20,$54,$30,$0D
00F866  1  0D           
00F867  1  80 04 90 03    .BYTE $80,$04,$90,$03,$22
00F86B  1  22           
00F86C  1  54 33 0D 80    .BYTE $54,$33,$0D,$80,$04
00F870  1  04           
00F871  1  90 04 20 54    .BYTE $90,$04,$20,$54,$33
00F875  1  33           
00F876  1  0D 80 04 90    .BYTE $0D,$80,$04,$90,$04
00F87A  1  04           
00F87B  1  20 54 3B 0D    .BYTE $20,$54,$3B,$0D,$80
00F87F  1  80           
00F880  1  04 90 00 22    .BYTE $04,$90,$00,$22,$44
00F884  1  44           
00F885  1  33 0D C8 44    .BYTE $33,$0D,$C8,$44,$00
00F889  1  00           
00F88A  1  11 22 44 33    .BYTE $11,$22,$44,$33,$0D
00F88E  1  0D           
00F88F  1  C8 44 A9 01    .BYTE $C8,$44,$A9,$01,$22
00F893  1  22           
00F894  1  44 33 0D 80    .BYTE $44,$33,$0D,$80,$04
00F898  1  04           
00F899  1  90 01 22 44    .BYTE $90,$01,$22,$44,$33
00F89D  1  33           
00F89E  1  0D 80 04 90    .BYTE $0D,$80,$04,$90
00F8A2  1  26 31 87 9A    .BYTE $26,$31,$87,$9A ; $ZZXXXY01 INSTR'S
00F8A6  1  00           FMT2: .BYTE $00 ; ERR
00F8A7  1  21             .BYTE $21 ; IMM
00F8A8  1  81             .BYTE $81 ; Z-PAGE
00F8A9  1  82             .BYTE $82 ; ABS
00F8AA  1  00             .BYTE $00 ; IMPLIED
00F8AB  1  00             .BYTE $00 ; ACCUMULATOR
00F8AC  1  59             .BYTE $59 ; (ZPAG,X)
00F8AD  1  4D             .BYTE $4D ; (ZPAG),Y
00F8AE  1  91             .BYTE $91 ; ZPAG,X
00F8AF  1  92             .BYTE $92 ; ABS,X
00F8B0  1  86             .BYTE $86 ; ABS,Y
00F8B1  1  4A             .BYTE $4A ; (ABS)
00F8B2  1  85             .BYTE $85 ; ZPAG,Y
00F8B3  1  9D             .BYTE $9D ; RELATIVE
00F8B4  1  AC A9 AC A3  CHAR1: Str ",),#($"
00F8B8  1  A8 A4        
00F8BA  1  D9 00 D8 A4  CHAR2: .BYTE $D9,$00,$D8,$A4,$A4,$00
00F8BE  1  A4 00        
00F8C0  1               ; CHAR2: "Y",0,"X$$",0
00F8C0  1               ; MNEML IS OF FORM:
00F8C0  1               ; (A) XXXXX000
00F8C0  1               ; (B) XXXYY100
00F8C0  1               ; (C) 1XXX1010
00F8C0  1               ; (D) XXXYYY10
00F8C0  1               ; (E) XXXYYY01
00F8C0  1               ; (X=INDEX)
00F8C0  1  1C 8A 1C 23  MNEML: .BYTE $1C,$8A,$1C,$23,$5D,$8B
00F8C4  1  5D 8B        
00F8C6  1  1B A1 9D 8A    .BYTE $1B,$A1,$9D,$8A,$1D,$23
00F8CA  1  1D 23        
00F8CC  1  9D 8B 1D A1    .BYTE $9D,$8B,$1D,$A1,$00,$29
00F8D0  1  00 29        
00F8D2  1  19 AE 69 A8    .BYTE $19,$AE,$69,$A8,$19,$23
00F8D6  1  19 23        
00F8D8  1  24 53 1B 23    .BYTE $24,$53,$1B,$23,$24,$53
00F8DC  1  24 53        
00F8DE  1  19 A1          .BYTE $19,$A1 ; (A) FORMAT ABOVE
00F8E0  1  00 1A 5B 5B    .BYTE $00,$1A,$5B,$5B,$A5,$69
00F8E4  1  A5 69        
00F8E6  1  24 24          .BYTE $24,$24 ; (B) FORMAT
00F8E8  1  AE AE A8 AD    .BYTE $AE,$AE,$A8,$AD,$29,$00
00F8EC  1  29 00        
00F8EE  1  7C 00          .BYTE $7C,$00 ; (C) FORMAT
00F8F0  1  15 9C 6D 9C    .BYTE $15,$9C,$6D,$9C,$A5,$69
00F8F4  1  A5 69        
00F8F6  1  29 53          .BYTE $29,$53 ; (D) FORMAT
00F8F8  1  84 13 34 11    .BYTE $84,$13,$34,$11,$A5,$69
00F8FC  1  A5 69        
00F8FE  1  23 A0          .BYTE $23,$A0 ; (E) FORMAT
00F900  1  D8 62 5A 48  MNEMR: .BYTE $D8,$62,$5A,$48,$26,$62
00F904  1  26 62        
00F906  1  94 88 54 44    .BYTE $94,$88,$54,$44,$C8,$54
00F90A  1  C8 54        
00F90C  1  68 44 E8 94    .BYTE $68,$44,$E8,$94,$00,$B4
00F910  1  00 B4        
00F912  1  08 84 74 B4    .BYTE $08,$84,$74,$B4,$28,$6E
00F916  1  28 6E        
00F918  1  74 F4 CC 4A    .BYTE $74,$F4,$CC,$4A,$72,$F2
00F91C  1  72 F2        
00F91E  1  A4 8A          .BYTE $A4,$8A ; (A) FORMAT
00F920  1  00 AA A2 A2    .BYTE $00,$AA,$A2,$A2,$74,$74
00F924  1  74 74        
00F926  1  74 72          .BYTE $74,$72 ; (B) FORMAT
00F928  1  44 68 B2 32    .BYTE $44,$68,$B2,$32,$B2,$00
00F92C  1  B2 00        
00F92E  1  22 00          .BYTE $22,$00 ; (C) FORMAT
00F930  1  1A 1A 26 26    .BYTE $1A,$1A,$26,$26,$72,$72
00F934  1  72 72        
00F936  1  88 C8          .BYTE $88,$C8 ; (D) FORMAT
00F938  1  C4 CA 26 48    .BYTE $C4,$CA,$26,$48,$44,$44
00F93C  1  44 44        
00F93E  1  A2 C8          .BYTE $A2,$C8 ; (E) FORMAT
00F940  1  FF FF FF       .BYTE $FF,$FF,$FF
00F943  1  20 D0 F7     STEP: JSR INSTDSP ; DISASSEMBLE ONE INST
00F946  1  68             PLA ; AT (PCL,H)
00F947  1  85 2C          STA RTNL ; ADJUST TO USER
00F949  1  68             PLA ; STACK. SAVE
00F94A  1  85 2D          STA RTNH ; RTN ADR.
00F94C  1  A2 08          LDX #$08
00F94E  1  BD 10 FA     XQINIT: LDA INITBL-1,X ; INIT XEQ AREA
00F951  1  95 3C          STA XQT,X
00F953  1  CA             DEX
00F954  1  D0 F8          BNE XQINIT
00F956  1  A1 3A          LDA (PCL,X) ; USER OPCODE BYTE
00F958  1  F0 42          BEQ XBRK ; SPECIAL IF BREAK
00F95A  1  A4 2F          LDY LENGTH ; LEN FROM DISASSEMBLY
00F95C  1  C9 20          CMP #$20
00F95E  1  F0 59          BEQ XJSR ; HANDLE JSR, RTS, JMP,
00F960  1  C9 60          CMP #$60 ; JMP (), RTI SPECIAL
00F962  1  F0 45          BEQ XRTS
00F964  1  C9 4C          CMP #$4C
00F966  1  F0 5C          BEQ XJMP
00F968  1  C9 6C          CMP #$6C
00F96A  1  F0 59          BEQ XJMPAT
00F96C  1  C9 40          CMP #$40
00F96E  1  F0 35          BEQ XRTI
00F970  1  29 1F          AND #$1F
00F972  1  49 14          EOR #$14
00F974  1  C9 04          CMP #$04 ; COPY USER INST TO XEQ AREA
00F976  1  F0 02          BEQ XQ2 ; WITH TRAILING NOPS
00F978  1  B1 3A        XQ1: LDA (PCL),Y ; CHANGE REL BRANCH
00F97A  1  99 3C 00     XQ2: STA XQT,Y ; DISP TO 4 FOR
00F97D  1  88             DEY ; JMP TO BRANCH OR
00F97E  1  10 F8          BPL XQ1 ; NBRANCH FROM XEQ.
00F980  1  20 3F FE       JSR RESTORE ; RESTORE USER REG CONTENTS.
00F983  1  4C 3C 00       JMP XQT ; XEQ USER OP FROM RAM
00F986  1  85 45        IRQ: STA ACC ; (RETURN TO NBRANCH)
00F988  1  68             PLA
00F989  1  48             PHA ; **IRQ HANDLER
00F98A  1  0A             ASL A
00F98B  1  0A             ASL A
00F98C  1  0A             ASL A
00F98D  1  30 03          BMI BREAK ; TEST FOR BREAK
00F98F  1  6C FE 03       JMP (IRQLOC) ; USER ROUTINE VECTOR IN RAM
00F992  1  28           BREAK: PLP
00F993  1  20 4C FE       JSR SAV1 ; SAVE REG'S ON BREAK
00F996  1  68             PLA ; INCLUDING PC
00F997  1  85 3A          STA PCL
00F999  1  68             PLA
00F99A  1  85 3B          STA PCH
00F99C  1  20 82 F7     XBRK: JSR INSDS1 ; PRINT USER PC.
00F99F  1  20 DA F9       JSR RGDSP1 ; AND REG'S
00F9A2  1  4C 65 FE       JMP MON ; GO TO MONITOR
00F9A5  1  18           XRTI: CLC
00F9A6  1  68             PLA ; SIMULATE RTI BY EXPECTING
00F9A7  1  85 48          STA STATUS ; STATUS FROM STACK, THEN RTS
00F9A9  1  68           XRTS: PLA ; RTS SIMULATION
00F9AA  1  85 3A          STA PCL ; EXTRACT PC FROM STACK
00F9AC  1  68             PLA ; AND UPDATE PC BY 1 (LEN=0)
00F9AD  1  85 3B        PCINC2: STA PCH
00F9AF  1  A5 2F        PCINC3: LDA LENGTH ; UPDATE PC BY LEN
00F9B1  1  20 56 F8       JSR PCADJ3
00F9B4  1  84 3B          STY PCH
00F9B6  1  18             CLC
00F9B7  1  90 14          BCC NEWPCL
00F9B9  1  18           XJSR: CLC
00F9BA  1  20 54 F8       JSR PCADJ2 ; UPDATE PC AND PUSH
00F9BD  1  AA             TAX ; ONTO STACH FOR
00F9BE  1  98             TYA ; JSR SIMULATE
00F9BF  1  48             PHA
00F9C0  1  8A             TXA
00F9C1  1  48             PHA
00F9C2  1  A0 02          LDY #$02
00F9C4  1  18           XJMP: CLC
00F9C5  1  B1 3A        XJMPAT: LDA (PCL),Y
00F9C7  1  AA             TAX ; LOAD PC FOR JMP,
00F9C8  1  88             DEY ; (JMP) SIMULATE.
00F9C9  1  B1 3A          LDA (PCL),Y
00F9CB  1  86 3B          STX PCH
00F9CD  1  85 3A        NEWPCL: STA PCL
00F9CF  1  B0 F3          BCS XJMP
00F9D1  1  A5 2D        RTNJMP: LDA RTNH
00F9D3  1  48             PHA
00F9D4  1  A5 2C          LDA RTNL
00F9D6  1  48             PHA
00F9D7  1  20 8E FC     REGDSP: JSR CROUT ; DISPLAY USER REG
00F9DA  1  A9 45        RGDSP1: LDA #ACC ; CONTENTS WITH
00F9DC  1  85 40          STA A3L ; LABELS
00F9DE  1  A9 00          LDA #ACC/256
00F9E0  1  85 41          STA A3H
00F9E2  1  A2 FB          LDX #$FB
00F9E4  1  A9 A0        RDSP1: LDA #$A0
00F9E6  1  20 ED FC       JSR COUT
00F9E9  1  BD 1E F9       LDA RTBL-$FB,X
00F9EC  1  20 ED FC       JSR COUT
00F9EF  1  A9 BD          LDA #$BD
00F9F1  1  20 ED FC       JSR COUT
00F9F4  1  B5 4A          LDA ACC+5,X
00F9F6  1  20 DA FC       JSR PRBYTE
00F9F9  1  E8             INX
00F9FA  1  30 E8          BMI RDSP1
00F9FC  1  60             RTS
00F9FD  1  18           BRANCH: CLC ; BRANCH TAKEN,
00F9FE  1  A0 01          LDY #$01 ; ADD LEN+2 TO PC
00FA00  1  B1 3A          LDA (PCL),Y
00FA02  1  20 56 F8       JSR PCADJ3
00FA05  1  85 3A          STA PCL
00FA07  1  98             TYA
00FA08  1  38             SEC
00FA09  1  B0 A2          BCS PCINC2
00FA0B  1  20 4A FE     NBRNCH: JSR SAVE ; NORMAL RETURN AFTER
00FA0E  1  38             SEC ; XEQ USER OF
00FA0F  1  B0 9E          BCS PCINC3 ; GO UPDATE PC
00FA11  1  EA           INITBL: NOP
00FA12  1  EA             NOP ; DUMMY FILL FOR
00FA13  1  4C 0B FA       JMP NBRNCH ; XEQ AREA
00FA16  1  4C FD F9       JMP BRANCH
00FA19  1  C1           RTBL: .BYTE $C1
00FA1A  1  D8             .BYTE $D8
00FA1B  1  D9             .BYTE $D9
00FA1C  1  D0             .BYTE $D0
00FA1D  1  D3             .BYTE $D3
00FA1E  1  AD 70 C0     PREAD: LDA PTRIG ; TRIGGER PADDLES
00FA21  1  A0 00          LDY #$00 ; INIT COUNT
00FA23  1  EA             NOP ; COMPENSATE FOR 1ST COUNT
00FA24  1  EA             NOP
00FA25  1  BD 64 C0     PREAD2: LDA PADDL0,X ; COUNT Y-REG EVERY
00FA28  1  10 04          BPL RTS2D ; 12 USEC
00FA2A  1  C8             INY
00FA2B  1  D0 F8          BNE PREAD2 ; EXIT AT 255 MAX
00FA2D  1  88             DEY
00FA2E  1  60           RTS2D: RTS
00FA2F  1  A9 00        INIT: LDA #$00 ; CLR STATUS FOR DEBUG
00FA31  1  85 48          STA STATUS ; SOFTWARE
00FA33  1  AD 56 C0       LDA LORES
00FA36  1  AD 54 C0       LDA LOWSCR ; INIT VIDEO MODE
00FA39  1  AD 51 C0     SETTXT: LDA TXTSET ; SET FOR TEXT MODE
00FA3C  1  A9 00          LDA #$00 ; FULL SCREEN WINDOW
00FA3E  1  F0 0B          BEQ SETWND
00FA40  1  AD 50 C0     SETGR: LDA TXTCLR ; SET FOR GRAPHICS MODE
00FA43  1  AD 53 C0       LDA MIXSET ; LOWER 4 LINES AS
00FA46  1  20 36 F7       JSR CLRTOP ; TEXT WINDOW
00FA49  1  A9 14          LDA #$14
00FA4B  1  85 22        SETWND: STA WNDTOP ; SET FOR 40 COL WINDOW
00FA4D  1  A9 00          LDA #$00 ; TOP IN A-REG,
00FA4F  1  85 20          STA WNDLFT ; BTTM AT LINE 24
00FA51  1  A9 28          LDA #$28
00FA53  1  85 21          STA WNDWDTH
00FA55  1  A9 18          LDA #$18
00FA57  1  85 23          STA WNDBTM ; VTAB TO ROW 23
00FA59  1  A9 17          LDA #$17
00FA5B  1  85 25        TABV: STA CV ; VTABS TO ROW IN A-REG
00FA5D  1  4C 22 FB       JMP VTAB
00FA60  1  20 A4 FA     MULPM: JSR MD1 ; ABS VAL OF AC AUX
00FA63  1  A0 10        MUL: LDY #$10 ; INDEX FOR 16 BITS
00FA65  1  A5 50        MUL2: LDA ACL ; ACX * AUX + XTND
00FA67  1  4A             LSR A ; TO AC, XTND
00FA68  1  90 0C          BCC MUL4 ; IF NO CARRY,
00FA6A  1  18             CLC ; NO PARTIAL PROD.
00FA6B  1  A2 FE          LDX #$FE
00FA6D  1  B5 54        MUL3: LDA XTNDL+2,X ; ADD MPLCND (AUX)
00FA6F  1  75 56          ADC AUXL+2,X ; TO PARTIAL PROD
00FA71  1  95 54          STA XTNDL+2,X ; (XTND)
00FA73  1  E8             INX
00FA74  1  D0 F7          BNE MUL3
00FA76  1  A2 03        MUL4: LDX #$03
00FA78  1  76           MUL5: .BYTE $76
00FA79  1  50             .BYTE $50
00FA7A  1  CA             DEX
00FA7B  1  10 FB          BPL MUL5
00FA7D  1  88             DEY
00FA7E  1  D0 E5          BNE MUL2
00FA80  1  60             RTS
00FA81  1  20 A4 FA     DIVPM: JSR MD1 ; ABS VAL OF AC, AUX.
00FA84  1  A0 10        DIV: LDY #$10 ; INDEX FOR 16 BITS
00FA86  1  06 50        DIV2: ASL ACL
00FA88  1  26 51          ROL ACH
00FA8A  1  26 52          ROL XTNDL ; XTND/AUX
00FA8C  1  26 53          ROL XTNDH ; TO AC.
00FA8E  1  38             SEC
00FA8F  1  A5 52          LDA XTNDL
00FA91  1  E5 54          SBC AUXL ; MOD TO XTND.
00FA93  1  AA             TAX
00FA94  1  A5 53          LDA XTNDH
00FA96  1  E5 55          SBC AUXH
00FA98  1  90 06          BCC DIV3
00FA9A  1  86 52          STX XTNDL
00FA9C  1  85 53          STA XTNDH
00FA9E  1  E6 50          INC ACL
00FAA0  1  88           DIV3: DEY
00FAA1  1  D0 E3          BNE DIV2
00FAA3  1  60             RTS
00FAA4  1  A0 00        MD1: LDY #$00 ; ABS VAL OF AC, AUX
00FAA6  1  84 2F          STY SIGN ; WITH RESULT SIGN
00FAA8  1  A2 54          LDX #AUXL ; IN LSB OF SIGN.
00FAAA  1  20 AF FA       JSR MD3
00FAAD  1  A2 50          LDX #ACL
00FAAF  1  B5 01        MD3: LDA LOC1,X ; X SPECIFIES AC OR AUX
00FAB1  1  10 0D          BPL MDRTS
00FAB3  1  38             SEC
00FAB4  1  98             TYA
00FAB5  1  F5 00          SBC LOC0,X ; COMPL SPECIFIED REG
00FAB7  1  95 00          STA LOC0,X ; IF NEG.
00FAB9  1  98             TYA
00FABA  1  F5 01          SBC LOC1,X
00FABC  1  95 01          STA LOC1,X
00FABE  1  E6 2F          INC SIGN
00FAC0  1  60           MDRTS: RTS
00FAC1  1  48           BASCALC: PHA ; CALC BASE ADR IN BASL,H
00FAC2  1  4A             LSR A ; FOR GIVEN LINE NO
00FAC3  1  29 03          AND #$03 ; 0<=LINE NO.<=$17
00FAC5  1  09 04          ORA #$04 ; ARG=000ABCDE, GENERATE
00FAC7  1  85 29          STA BASH ; BASH=000001CD
00FAC9  1  68             PLA ; AND
00FACA  1  29 18          AND #$18 ; BASL=EABAB000
00FACC  1  90 02          BCC BSCLC2
00FACE  1  69 7F          ADC #$7F
00FAD0  1  85 28        BSCLC2: STA BASL
00FAD2  1  0A             ASL
00FAD3  1  0A             ASL
00FAD4  1  05 28          ORA BASL
00FAD6  1  85 28          STA BASL
00FAD8  1  60             RTS
00FAD9  1  C9 87        BELL1: CMP #$87 ; BELL CHAR? (CNTRL-G)
00FADB  1  D0 12          BNE RTS2B ; NO, RETURN
00FADD  1  A9 40          LDA #$40 ; DELAY .01 SECONDS
00FADF  1  20 A8 FB       JSR WAIT
00FAE2  1  A0 C0          LDY #$C0
00FAE4  1  A9 0C        BELL2: LDA #$0C ; TOGGLE SPEAKER AT
00FAE6  1  20 A8 FB       JSR WAIT ; 1 KHZ FOR .1 SEC.
00FAE9  1  AD 30 C0       LDA SPKR
00FAEC  1  88             DEY
00FAED  1  D0 F5          BNE BELL2
00FAEF  1  60           RTS2B: RTS
00FAF0  1  A4 24        STOADV: LDY CH ; CURSOR H INDEX TO Y-REG
00FAF2  1               .ifdef APPLE1
00FAF2  1  EA             NOP
00FAF3  1  EA             NOP
00FAF4  1               .else
00FAF4  1                 STA (BASL),Y ; STORE CHAR IN LINE
00FAF4  1               .endif
00FAF4  1  E6 24        ADVANCE: INC CH ; INCREMENT CURSOR H INDEX
00FAF6  1  A5 24          LDA CH ; (MOVE RIGHT)
00FAF8  1  C5 21          CMP WNDWDTH ; BEYOND WINDOW WIDTH?
00FAFA  1  B0 66          BCS CR ; YES CR TO NEXT LINE
00FAFC  1  60           RTS3: RTS ; NO,RETURN
00FAFD  1  C9 A0        VIDOUT: CMP #$A0 ; CONTROL CHAR?
00FAFF  1  B0 EF          BCS STOADV ; NO,OUTPUT IT.
00FB01  1  A8             TAY ; INVERSE VIDEO?
00FB02  1  10 EC          BPL STOADV ; YES, OUTPUT IT.
00FB04  1  C9 8D          CMP #$8D ; CR?
00FB06  1  F0 5A          BEQ CR ; YES.
00FB08  1  C9 8A          CMP #$8A ; LINE FEED?
00FB0A  1  F0 5A          BEQ LF ; IF SO, DO IT.
00FB0C  1  C9 88          CMP #$88 ; BACK SPACE? (CNTRL-H)
00FB0E  1  D0 C9          BNE BELL1 ; NO, CHECK FOR BELL.
00FB10  1  C6 24        BS1: DEC CH ; DECREMENT CURSOR H INDEX
00FB12  1  10 E8          BPL RTS3 ; IF POS, OK. ELSE MOVE UP
00FB14  1  A5 21          LDA WNDWDTH ; SET CH TO WNDWDTH-1
00FB16  1  85 24          STA CH
00FB18  1  C6 24         DEC CH ; (RIGHTMOST SCREEN POS)
00FB1A  1  A5 22        UP: LDA WNDTOP ; CURSOR V INDEX
00FB1C  1  C5 25          CMP CV
00FB1E  1  B0 0B          BCS RTS4 ; IF TOP LINE THEN RETURN
00FB20  1  C6 25          DEC CV ; DEC CURSOR V-INDEX
00FB22  1  A5 25        VTAB: LDA CV ; GET CURSOR V-INDEX
00FB24  1  20 C1 FA     VTABZ: JSR BASCALC ; GENERATE BASE ADR
00FB27  1  65 20          ADC WNDLFT ; ADD WINDOW LEFT INDEX
00FB29  1  85 28          STA BASL ; TO BASL
00FB2B  1  60           RTS4: RTS
00FB2C  1  49 C0        ESC1: EOR #$C0 ; ESC?
00FB2E  1  F0 28          BEQ HOME ; IF SO, DO HOME AND CLEAR
00FB30  1  69 FD          ADC #$FD ; ESC-A OR B CHECK
00FB32  1  90 C0          BCC ADVANCE ; A, ADVANCE
00FB34  1  F0 DA          BEQ BS1 ; B, BACKSPACE
00FB36  1  69 FD          ADC #$FD ; ESC-C OR D CHECK
00FB38  1  90 2C          BCC LF ; C, DOWN
00FB3A  1  F0 DE          BEQ UP ; D, GO UP
00FB3C  1  69 FD          ADC #$FD ; ESC-E OR F CHECK
00FB3E  1  90 5C          BCC CLREOL ; E, CLEAR TO END OF LINE
00FB40  1  D0 E9          BNE RTS4 ; NOT F, RETURN
00FB42  1  A4 24        CLREOP: LDY CH ; CURSOR H TO Y INDEX
00FB44  1  A5 25          LDA CV ; CURSOR V TO A-REGISTER
00FB46  1  48           CLEOP1: PHA ; SAVE CURRENT LINE ON STK
00FB47  1  20 24 FB       JSR VTABZ ; CALC BASE ADDRESS
00FB4A  1  20 9E FB       JSR CLEOLZ ; CLEAR TO EOL, SET CARRY
00FB4D  1  A0 00          LDY #$00 ; CLEAR FROM H INDEX=0 FOR REST
00FB4F  1  68             PLA ; INCREMENT CURRENT LINE
00FB50  1  69 00          ADC #$00 ; (CARRY IS SET)
00FB52  1  C5 23          CMP WNDBTM ; DONE TO BOTTOM OF WINDOW?
00FB54  1  90 F0          BCC CLEOP1 ; NO, KEEP CLEARING LINES
00FB56  1  B0 CA          BCS VTAB ; YES, TAB TO CURRENT LINE
00FB58  1  A5 22        HOME: LDA WNDTOP ; INIT CURSOR V
00FB5A  1  85 25          STA CV ; AND H-INDICES
00FB5C  1  A0 00          LDY #$00
00FB5E  1  84 24          STY CH ; THEN CLEAR TO END OF PAGE
00FB60  1  F0 E4          BEQ CLEOP1
00FB62  1  A9 00        CR: LDA #$00 ; CURSOR TO LEFT OF INDEX
00FB64  1  85 24          STA CH ; (RET CURSOR H=0)
00FB66  1  E6 25        LF: INC CV ; INCR CURSOR V(DOWN 1 LINE)
00FB68  1  A5 25          LDA CV
00FB6A  1  C5 23          CMP WNDBTM ; OFF SCREEN?
00FB6C  1  90 B6          BCC VTABZ ; NO, SET BASE ADDR
00FB6E  1  C6 25          DEC CV ; DECR CURSOR V (BACK TO BOTTOM)
00FB70  1  A5 22        SCROLL: LDA WNDTOP ; START AT TOP OF SCRL WNDW
00FB72  1  48             PHA
00FB73  1  20 24 FB       JSR VTABZ ; GENERATE BASE ADR
00FB76  1  A5 28        SCRL1: LDA BASL ; COPY BASL,H
00FB78  1  85 2A          STA BAS2L ; TO BAS2L,H
00FB7A  1  A5 29          LDA BASH
00FB7C  1  85 2B          STA BAS2H
00FB7E  1  A4 21          LDY WNDWDTH ; INIT Y TO RIGHTMOST INDEX
00FB80  1  88             DEY ; OF SCROLLING WINDOW
00FB81  1  68             PLA
00FB82  1  69 01          ADC #$01 ; INCR LINE NUMBER
00FB84  1  C5 23          CMP WNDBTM ; DONE?
00FB86  1  B0 0D          BCS SCRL3 ; YES, FINISH
00FB88  1  48             PHA
00FB89  1  20 24 FB       JSR VTABZ ; FORM BASL,H (BASE ADDR)
00FB8C  1  B1 28        SCRL2: LDA (BASL),Y ; MOVE A CHR UP ON LINE
00FB8E  1               .ifdef APPLE1
00FB8E  1  EA             NOP
00FB8F  1  EA             NOP
00FB90  1               .else
00FB90  1                 STA (BAS2L),Y
00FB90  1               .endif
00FB90  1  88             DEY ; NEXT CHAR OF LINE
00FB91  1  10 F9          BPL SCRL2
00FB93  1  30 E1          BMI SCRL1 ; NEXT LINE (ALWAYS TAKEN)
00FB95  1  A0 00        SCRL3: LDY #$00 ; CLEAR BOTTOM LINE
00FB97  1  20 9E FB       JSR CLEOLZ ; GET BASE ADDR FOR BOTTOM LINE
00FB9A  1  B0 86          BCS VTAB ; CARRY IS SET
00FB9C  1  A4 24        CLREOL: LDY CH ; CURSOR H INDEX
00FB9E  1  A9 A0        CLEOLZ: LDA #$A0
00FBA0  1               CLEOL2:
00FBA0  1               .ifdef APPLE1
00FBA0  1  EA             NOP
00FBA1  1  EA             NOP
00FBA2  1               .else
00FBA2  1                 STA (BASL),Y ; STORE BLANKS FROM 'HERE'
00FBA2  1               .endif
00FBA2  1  C8             INY ; TO END OF LINES (WNDWDTH)
00FBA3  1  C4 21          CPY WNDWDTH
00FBA5  1  90 F9          BCC CLEOL2
00FBA7  1  60             RTS
00FBA8  1  38           WAIT: SEC
00FBA9  1  48           WAIT2: PHA
00FBAA  1  E9 01        WAIT3: SBC #$01
00FBAC  1  D0 FC          BNE WAIT3 ; 1.0204 USEC
00FBAE  1  68             PLA ; (13+27/2*A+5/2*A*A)
00FBAF  1  E9 01          SBC #$01
00FBB1  1  D0 F6          BNE WAIT2
00FBB3  1  60             RTS
00FBB4  1  E6 42        NXTA4: INC A4L ; INCR 2-BYTE A4
00FBB6  1  D0 02          BNE NXTA1 ; AND A1
00FBB8  1  E6 43          INC A4H
00FBBA  1  A5 3C        NXTA1: LDA A1L ; INCR 2-BYTE A1.
00FBBC  1  C5 3E          CMP A2L
00FBBE  1  A5 3D          LDA A1H ; AND COMPARE TO A2
00FBC0  1  E5 3F          SBC A2H
00FBC2  1  E6 3C          INC A1L ; (CARRY SET IF >=)
00FBC4  1  D0 02          BNE RTS4B
00FBC6  1  E6 3D          INC A1H
00FBC8  1  60           RTS4B: RTS
00FBC9  1               .ifdef APPLE1
00FBC9  1  A0 48        HEADR: LDY #$48 ; WRITE A*256 'LONG 1'
00FBCB  1               .else
00FBCB  1               HEADR: LDY #$4B ; WRITE A*256 'LONG 1'
00FBCB  1               .endif
00FBCB  1  20 DB FB       JSR ZERDLY ; HALF CYCLES
00FBCE  1  D0 F9          BNE HEADR ; (650 USEC EACH)
00FBD0  1  69 FE          ADC #$FE
00FBD2  1  B0 F5          BCS HEADR ; THEN A 'SHORT 0'
00FBD4  1  A0 21          LDY #$21 ; (400 USEC)
00FBD6  1  20 DB FB     WRBIT: JSR ZERDLY ; WRITE TWO HALF CYCLES
00FBD9  1  C8             INY ; OF 250 USEC ('0')
00FBDA  1  C8             INY ; OR 500 USEC ('0')
00FBDB  1  88           ZERDLY: DEY
00FBDC  1  D0 FD          BNE ZERDLY
00FBDE  1  90 05          BCC WRTAPE ; Y IS COUNT FOR
00FBE0  1  A0 32          LDY #$32 ; TIMING LOOP
00FBE2  1  88           ONEDLY: DEY
00FBE3  1  D0 FD          BNE ONEDLY
00FBE5  1               .ifdef APPLE1
00FBE5  1  BC 00 C0     WRTAPE: LDY IOADR,X
00FBE8  1  A0 2C          LDY #$2C
00FBEA  1  CA             DEX
00FBEB  1               .else
00FBEB  1               WRTAPE: LDY TAPEOUT
00FBEB  1                 LDY  #$2C
00FBEB  1                 DEX
00FBEB  1               .endif
00FBEB  1  60             RTS
00FBEC  1  A2 08        RDBYTE: LDX #$08 ; 8 BITS TO READ
00FBEE  1  48           RDBYT2: PHA ; READ TWO TRANSITIONS
00FBEF  1  20 FA FB       JSR RD2BIT ; (FIND EDGE)
00FBF2  1  68             PLA
00FBF3  1  2A             ROL ; NEXT BIT
00FBF4  1  A0 3A          LDY #$3A ; COUNT FOR SAMPLES
00FBF6  1  CA             DEX
00FBF7  1  D0 F5          BNE RDBYT2
00FBF9  1  60             RTS
00FBFA  1  20 FD FB     RD2BIT: JSR RDBIT
00FBFD  1  88           RDBIT: DEY ; DECR Y UNTIL
00FBFE  1               .ifdef APPLE1
00FBFE  1  AD 81 C0       LDA $C081 ; TAPE TRANSITION
00FC01  1  C5 2F          CMP LASTIN
00FC03  1  F0 F8          BEQ RDBIT
00FC05  1  85 2F          STA LASTIN
00FC07  1  C0 80          CPY #$80 ; SET CARRY ON Y
00FC09  1  60             RTS
00FC0A  1  EA             NOP
00FC0B  1  EA             NOP
00FC0C  1               .else
00FC0C  1                 LDA TAPEIN ; TAPE TRANSITION
00FC0C  1                 EOR LASTIN
00FC0C  1                 BPL RDBIT
00FC0C  1                 EOR LASTIN
00FC0C  1                 STA LASTIN
00FC0C  1                 CPY #$80 ; SET CARRY ON Y
00FC0C  1                 RTS
00FC0C  1               .endif
00FC0C  1  A4 24        RDKEY: LDY CH
00FC0E  1  B1 28          LDA (BASL),Y ; SET SCREEN TO FLASH
00FC10  1  48             PHA
00FC11  1  29 3F          AND #$3F
00FC13  1  09 40          ORA #$40
00FC15  1               .ifdef APPLE1
00FC15  1  EA             NOP
00FC16  1  EA             NOP
00FC17  1               .else
00FC17  1                 STA (BASL),Y
00FC17  1               .endif
00FC17  1  68             PLA
00FC18  1               .ifdef APPLE1
00FC18  1  EA             NOP
00FC19  1  EA             NOP
00FC1A  1  EA             NOP
00FC1B  1               .else
00FC1B  1                 JMP (KSWL) ; GO TO USER KEY-IN
00FC1B  1               .endif
00FC1B  1  E6 4E        KEYIN: INC RNDL
00FC1D  1  D0 02          BNE KEYIN2 ; INCR RND NUMBER
00FC1F  1  E6 4F          INC RNDH
00FC21  1               KEYIN2:
00FC21  1               .ifdef APPLE1
00FC21  1  AD 11 D0       LDA $D011
00FC24  1               .else
00FC24  1                 BIT KBD ; KEY DOWN?
00FC24  1               .endif
00FC24  1  10 F5          BPL KEYIN ; LOOP
00FC26  1               .ifdef APPLE1
00FC26  1  EA             NOP
00FC27  1  EA             NOP
00FC28  1               .else
00FC28  1                 STA (BASL),Y ; REPLACE FLASHING SCREEN
00FC28  1               .endif
00FC28  1               .ifdef APPLE1
00FC28  1  AD 10 D0       LDA $D010 ; GET KEYCODE
00FC2B  1  4C 99 F5       JMP L7
00FC2E  1  EA             NOP
00FC2F  1               .else
00FC2F  1                 LDA KBD
00FC2F  1                 BIT KBDSTRB ; CLR KEY STROBE
00FC2F  1                 RTS
00FC2F  1               .endif
00FC2F  1  20 0C FC     ESC: JSR RDKEY ; GET KEYCODE
00FC32  1  20 2C FB       JSR ESC1 ; HANDLE ESC FUNC.
00FC35  1  20 0C FC     RDCHAR: JSR RDKEY ; READ KEY
00FC38  1  C9 9B          CMP #$9B ; ESC?
00FC3A  1  F0 F3          BEQ ESC ; YES, DON'T RETURN
00FC3C  1  60             RTS
00FC3D  1  A5 32        NOTCR: LDA INVFLG
00FC3F  1  48             PHA
00FC40  1  A9 FF          LDA #$FF
00FC42  1  85 32          STA INVFLG ; ECHO USER LINE
00FC44  1  BD 00 02       LDA IN,X ; NON INVERSE
00FC47  1  20 ED FC       JSR COUT
00FC4A  1  68             PLA
00FC4B  1  85 32          STA INVFLG
00FC4D  1  BD 00 02       LDA IN,X
00FC50  1               .ifdef APPLE1
00FC50  1  C9 DF          CMP #$DF ; CHECK FOR EDIT KEYS
00FC52  1               .else
00FC52  1                 CMP #$88 ; CHECK FOR EDIT KEYS
00FC52  1               .endif
00FC52  1  F0 1D          BEQ BCKSPC ; BS, CTRL-X
00FC54  1  C9 98          CMP #$98
00FC56  1  F0 0A          BEQ CANCEL
00FC58  1  E0 F8          CPX #$F8 ; MARGIN?
00FC5A  1  90 03          BCC NOTCR1
00FC5C  1  20 3A FE       JSR BELL ; YES, SOUND BELL
00FC5F  1  E8           NOTCR1: INX ; ADVANCE INPUT INDEX
00FC60  1  D0 13          BNE NXTCHAR
00FC62  1  A9 DC        CANCEL: LDA #$DC ; BACKSLASH AFTER CANCELLED LINE
00FC64  1  20 ED FC       JSR COUT
00FC67  1  20 8E FC     GETLNZ: JSR CROUT ; OUTPUT CR
00FC6A  1  A5 33        GETLN: LDA PROMPT
00FC6C  1  20 ED FC       JSR COUT ; OUTPUT PROMPT CHAR
00FC6F  1  A2 01          LDX #$01 ; INIT INPUT INDEX
00FC71  1  8A           BCKSPC: TXA ; WILL BACKSPACE TO 0
00FC72  1  F0 F3          BEQ GETLNZ
00FC74  1  CA             DEX
00FC75  1  20 35 FC     NXTCHAR: JSR RDCHAR
00FC78  1  C9 95          CMP #PICK ; USE SCREEN CHAR
00FC7A  1  D0 02          BNE CAPTST ; FOR CTRL-U
00FC7C  1  B1 28          LDA (BASL),Y
00FC7E  1  C9 E0        CAPTST: CMP #$E0
00FC80  1  90 02          BCC ADDINP ; CONVERT TO CAPS
00FC82  1  29 DF          AND #$DF
00FC84  1  9D 00 02     ADDINP: STA IN,X ; ADD TO INPUT BUF
00FC87  1  C9 8D          CMP #$8D
00FC89  1  D0 B2          BNE NOTCR
00FC8B  1  20 9C FB       JSR CLREOL ; CLR TO EOL IF CR
00FC8E  1  A9 8D        CROUT: LDA #$8D
00FC90  1  D0 5B          BNE COUT
00FC92  1  A4 3D        PRA1: LDY A1H ; PRINT CR,A1 IN HEX
00FC94  1  A6 3C          LDX A1L
00FC96  1  20 8E FC     PRYX2: JSR CROUT
00FC99  1  20 40 F8       JSR PRNTYX
00FC9C  1  A0 00          LDY #$00
00FC9E  1  A9 AD          LDA #$AD ; PRINT '-'
00FCA0  1  4C ED FC       JMP COUT
00FCA3  1  A5 3C        XAM8: LDA A1L
00FCA5  1  09 07          ORA #$07 ; SET TO FINISH AT
00FCA7  1  85 3E          STA A2L ; MOD 8=7
00FCA9  1  A5 3D          LDA A1H
00FCAB  1  85 3F          STA A2H
00FCAD  1  A5 3C        MODSCHK: LDA A1L
00FCAF  1  29 07          AND #$07
00FCB1  1  D0 03          BNE DATAOUT
00FCB3  1  20 92 FC     XAM: JSR PRA1
00FCB6  1  A9 A0        DATAOUT: LDA #$A0
00FCB8  1  20 ED FC       JSR COUT ; OUTPUT BLANK
00FCBB  1  B1 3C          LDA (A1L),Y
00FCBD  1  20 DA FC       JSR PRBYTE ; OUTPUT BYTE IN HEX
00FCC0  1  20 BA FB       JSR NXTA1
00FCC3  1  90 E8          BCC MODSCHK ; CHECK IF TIME TO,
00FCC5  1  60           RTS4C: RTS ; PRINT ADDR
00FCC6  1  4A           XAMPM: LSR A ; DETERMINE IF MON
00FCC7  1  90 EA          BCC XAM ; MODE IS XAM
00FCC9  1  4A             LSR A ; ADD, OR SUB
00FCCA  1  4A             LSR A
00FCCB  1  A5 3E          LDA A2L
00FCCD  1  90 02          BCC @ADD
00FCCF  1  49 FF          EOR #$FF ; SUB: FORM 2'S COMPLEMENT
00FCD1  1  65 3C        @ADD: ADC A1L
00FCD3  1  48             PHA
00FCD4  1  A9 BD          LDA #$BD
00FCD6  1  20 ED FC       JSR COUT ; PRINT '=', THEN RESULT
00FCD9  1  68             PLA
00FCDA  1  48           PRBYTE: PHA ; PRINT BYTE AS 2 HEX
00FCDB  1  4A             LSR A ; DIGITS, DESTROYS A-REG
00FCDC  1  4A             LSR A
00FCDD  1  4A             LSR A
00FCDE  1  4A             LSR A
00FCDF  1  20 E5 FC       JSR PRHEXZ
00FCE2  1  68             PLA
00FCE3  1  29 0F        PRHEX: AND #$0F ; PRINT HEX DIG IN A-REG
00FCE5  1  09 B0        PRHEXZ: ORA #$B0 ; LSB'S
00FCE7  1  C9 BA          CMP #$BA
00FCE9  1  90 02          BCC COUT
00FCEB  1  69 06          ADC #$06
00FCED  1               COUT:
00FCED  1               .ifdef APPLE1
00FCED  1  20 90 F5       JSR L3
00FCF0  1               .else
00FCF0  1                JMP (CSWL) ; VECTOR TO USER OUTPUT ROUTINE
00FCF0  1               .endif
00FCF0  1  C9 A0        COUT1: CMP #$A0
00FCF2  1  90 02          BCC COUTZ ; DON'T OUTPUT CTRL'S INVERSE
00FCF4  1  25 32          AND INVFLG ; MASK WITH INVERSE FLAG
00FCF6  1  84 35        COUTZ: STY YSAV1 ; SAV Y-REG
00FCF8  1  48             PHA ; SAV A-REG
00FCF9  1  20 FD FA       JSR VIDOUT ; OUTPUT A-REG AS ASCII
00FCFC  1  68             PLA ; RESTORE A-REG
00FCFD  1  A4 35          LDY YSAV1 ; AND Y-REG
00FCFF  1  60             RTS ; THEN RETURN
00FD00  1  C6 34        BL1: DEC YSAV
00FD02  1  F0 9F          BEQ XAM8
00FD04  1  CA           BLANK: DEX ; BLANK TO MON
00FD05  1  D0 16          BNE SETMDZ ; AFTER BLANK
00FD07  1  C9 BA          CMP #$BA ; DATA STORE MODE?
00FD09  1  D0 BB          BNE XAMPM ; NO, XAM, ADD, OR SUB
00FD0B  1  85 31        STOR: STA MODE ; KEEP IN STORE MODE
00FD0D  1  A5 3E          LDA A2L
00FD0F  1  91 40          STA (A3L),Y ; STORE AS LOW BYTE AS (A3)
00FD11  1  E6 40          INC A3L
00FD13  1  D0 02          BNE RTS5 ; INCR A3, RETURN
00FD15  1  E6 41          INC A3H
00FD17  1  60           RTS5: RTS
00FD18  1  A4 34        SETMODE: LDY YSAV ; SAVE CONVERTED ':', '+',
00FD1A  1  B9 FF 01       LDA IN-1,Y ; '-', '.' AS MODE.
00FD1D  1  85 31        SETMDZ: STA MODE
00FD1F  1  60             RTS
00FD20  1  A2 01        LT: LDX #$01
00FD22  1  B5 3E        LT2: LDA A2L,X ; COPY A2 (2 BYTES) TO
00FD24  1  95 42          STA A4L,X ; A4 AND A5
00FD26  1  95 44          STA A5L,X
00FD28  1  CA             DEX
00FD29  1  10 F7          BPL LT2
00FD2B  1  60             RTS
00FD2C  1  B1 3C        MOVE: LDA (A1L),Y ; MOVE (A1 TO A2) TO
00FD2E  1  91 42          STA (A4L),Y ; (A4)
00FD30  1  20 B4 FB       JSR NXTA4
00FD33  1  90 F7          BCC MOVE
00FD35  1  60             RTS
00FD36  1  B1 3C        VFY: LDA (A1L),Y ; VERIFY (A1 TO A2) WITH
00FD38  1  D1 42          CMP (A4L),Y ; (A4)
00FD3A  1  F0 1C          BEQ VFYOK
00FD3C  1  20 92 FC       JSR PRA1
00FD3F  1  B1 3C          LDA (A1L),Y
00FD41  1  20 DA FC       JSR PRBYTE
00FD44  1  A9 A0          LDA #$A0
00FD46  1  20 ED FC       JSR COUT
00FD49  1  A9 A8          LDA #$A8
00FD4B  1  20 ED FC       JSR COUT
00FD4E  1  B1 42          LDA (A4L),Y
00FD50  1  20 DA FC       JSR PRBYTE
00FD53  1  A9 A9          LDA #$A9
00FD55  1  20 ED FC       JSR COUT
00FD58  1  20 B4 FB     VFYOK: JSR NXTA4
00FD5B  1  90 D9          BCC VFY
00FD5D  1  60             RTS
00FD5E  1  20 75 FD     LIST: JSR A1PC ; MOVE A1 (2 BYTES) TO
00FD61  1  A9 14          LDA #$14 ; PC IF SPEC'D AND
00FD63  1  48           LIST2: PHA ; DISEMBLE 20 INSTRS
00FD64  1  20 D0 F7       JSR INSTDSP
00FD67  1  20 53 F8       JSR PCADJ ; ADJUST PC EACH INSTR
00FD6A  1  85 3A          STA PCL
00FD6C  1  84 3B          STY PCH
00FD6E  1  68             PLA
00FD6F  1  38             SEC
00FD70  1  E9 01          SBC #$01 ; NEXT OF 20 INSTRS
00FD72  1  D0 EF          BNE LIST2
00FD74  1  60             RTS
00FD75  1  8A           A1PC: TXA ; IF USER SPEC'D ADR
00FD76  1  F0 07          BEQ A1PCRTS ; COPY FROM A1 TO PC
00FD78  1  B5 3C        A1PCLP: LDA A1L,X
00FD7A  1  95 3A          STA PCL,X
00FD7C  1  CA             DEX
00FD7D  1  10 F9          BPL A1PCLP
00FD7F  1  60           A1PCRTS: RTS
00FD80  1  A0 3F        SETINV: LDY #$3F ; SET FOR INVERSE VID
00FD82  1  D0 02          BNE SETIFLG ; VIA COUT1
00FD84  1  A0 FF        SETNORM: LDY #$FF ; SET FOR NORMAL VID
00FD86  1  84 32        SETIFLG: STY INVFLG
00FD88  1  60             RTS
00FD89  1  A9 00        SETKBD: LDA #$00 ; SIMULATE PORT #0 INPUT
00FD8B  1  85 3E        INPORT: STA A2L ; SPECIFIED (KEYIN ROUTINE)
00FD8D  1  A2 38        INPRT: LDX #KSWL
00FD8F  1  A0 1B          LDY #<KEYIN
00FD91  1  D0 08          BNE IOPRT
00FD93  1  A9 00        SETVID: LDA #$00 ; SIMULATE PORT #0 OUTPUT
00FD95  1  85 3E        OUTPORT: STA A2L ; SPECIFIED (COUT1 ROUTINE)
00FD97  1  A2 36        OUTPRT: LDX #CSWL
00FD99  1  A0 F0          LDY #<COUT1
00FD9B  1  A5 3E        IOPRT: LDA A2L ; SET RAM IN/OUT VECTORS
00FD9D  1  29 0F          AND #$0F
00FD9F  1  F0 06          BEQ IOPRT1
00FDA1  1  09 C0          ORA #>IOADR
00FDA3  1  A0 00          LDY #$00
00FDA5  1  F0 02          BEQ IOPRT2
00FDA7  1               .ifdef APPLE1
00FDA7  1  A9 FD        IOPRT1: LDA #$FD
00FDA9  1               .else
00FDA9  1               IOPRT1: LDA #>COUT1
00FDA9  1               .endif
00FDA9  1  94 00        IOPRT2: STY LOC0,X
00FDAB  1  95 01          STA LOC1,X
00FDAD  1  60             RTS
00FDAE  1  EA             NOP
00FDAF  1  EA             NOP
00FDB0  1  4C 00 E0     XBASIC: JMP BASIC ; TO BASIC WITH SCRATCH
00FDB3  1  4C B3 E2     BASCONT: JMP BASIC2 ; CONTINUE BASIC
00FDB6  1  20 75 FD     GO: JSR A1PC ; ADR TO PC IF SPEC'D
00FDB9  1  20 3F FE       JSR RESTORE ; RESTORE META REGS
00FDBC  1  6C 3A 00       JMP (PCL) ; GO TO USER SUBR
00FDBF  1  4C D7 F9     REGZ: JMP REGDSP ; TO REG DISPLAY
00FDC2  1  C6 34        TRACE: DEC YSAV
00FDC4  1  20 75 FD     STEPZ: JSR A1PC ; ADR TO PC IF SPEC'D
00FDC7  1  4C 43 F9       JMP STEP ; TAKE ONE STEP
00FDCA  1  4C F8 03     USR: JMP USRADR ; TO USR SUBR AT USRADR
00FDCD  1  A9 40        WRITE: LDA #$40
00FDCF  1  20 C9 FB       JSR HEADR ; WRITE 10-SEC HEADER
00FDD2  1  A0 27          LDY #$27
00FDD4  1  A2 00        WR1: LDX #$00
00FDD6  1  41 3C          EOR (A1L,X)
00FDD8  1  48             PHA
00FDD9  1  A1 3C          LDA (A1L,X)
00FDDB  1  20 ED FD       JSR WRBYTE
00FDDE  1  20 BA FB       JSR NXTA1
00FDE1  1  A0 1D          LDY #$1D
00FDE3  1  68             PLA
00FDE4  1  90 EE          BCC WR1
00FDE6  1  A0 22          LDY #$22
00FDE8  1  20 ED FD       JSR WRBYTE
00FDEB  1  F0 4D          BEQ BELL
00FDED  1  A2 10        WRBYTE: LDX #$10
00FDEF  1  0A           WRBYT2: ASL A
00FDF0  1  20 D6 FB       JSR WRBIT
00FDF3  1  D0 FA          BNE WRBYT2
00FDF5  1  60             RTS
00FDF6  1  20 00 FD     CRMON: JSR BL1 ; HANDLE A CR AS BLANK
00FDF9  1  68             PLA ; THEN POP STACK
00FDFA  1  68             PLA ; AND RTN TO MON
00FDFB  1  D0 6C          BNE MONZ
00FDFD  1  20 FA FB     READ: JSR RD2BIT ; FIND TAPEIN EDGE
00FE00  1  A9 16          LDA #$16
00FE02  1  20 C9 FB       JSR HEADR ; DELAY 3.5 SECONDS
00FE05  1  85 2E          STA CHKSUM ; INIT CHKSUM=$FF
00FE07  1  20 FA FB       JSR RD2BIT ; FIND TAPEIN EDGE
00FE0A  1  A0 24        RD2: LDY #$24 ; LOOK FOR SYNC BIT
00FE0C  1  20 FD FB       JSR RDBIT ; (SHORT 0)
00FE0F  1  B0 F9          BCS RD2 ; LOOP UNTIL FOUND
00FE11  1  20 FD FB       JSR RDBIT ; SKIP SECOND SYNC H-CYCLE
00FE14  1  A0 3B          LDY #$3B ; INDEX FOR 0/1 TEST
00FE16  1  20 EC FB     RD3: JSR RDBYTE ; READ A BYTE
00FE19  1  81 3C          STA (A1L,X) ; STORE AT (A1)
00FE1B  1  45 2E          EOR CHKSUM
00FE1D  1  85 2E          STA CHKSUM ; UPDATE RUNNING CHKSUM
00FE1F  1  20 BA FB       JSR NXTA1 ; INC A1, COMPARE TO A2
00FE22  1  A0 35          LDY #$35 ; COMPENSATE 0/1 INDEX
00FE24  1  90 F0          BCC RD3 ; LOOP UNTIL DONE
00FE26  1  20 EC FB       JSR RDBYTE ; READ CHKSUM BYTE
00FE29  1  C5 2E          CMP CHKSUM
00FE2B  1  F0 0D          BEQ BELL ; GOOD, SOUND BELL AND RETURN
00FE2D  1  A9 C5        PRERR: LDA #$C5
00FE2F  1  20 ED FC       JSR COUT ; PRINT "ERR", THEN BELL
00FE32  1  A9 D2          LDA #$D2
00FE34  1  20 ED FC       JSR COUT
00FE37  1  20 ED FC       JSR COUT
00FE3A  1  A9 87        BELL: LDA #$87 ; OUTPUT BELL AND RETURN
00FE3C  1  4C ED FC       JMP COUT
00FE3F  1  A5 48        RESTORE: LDA STATUS ; RESTORE 6502 REG CONTENTS
00FE41  1  48             PHA ; USED BY DEBUG SOFTWARE
00FE42  1  A5 45          LDA ACC
00FE44  1  A6 46        RESTR1: LDX XREG
00FE46  1  A4 47          LDY YREG
00FE48  1  28             PLP
00FE49  1  60             RTS
00FE4A  1  85 45        SAVE: STA ACC ; SAVE 6502 REG CONTENTS
00FE4C  1  86 46        SAV1: STX XREG
00FE4E  1  84 47          STY YREG
00FE50  1  08             PHP
00FE51  1  68             PLA
00FE52  1  85 48          STA STATUS
00FE54  1  BA             TSX
00FE55  1  86 49          STX SPNT
00FE57  1  D8             CLD
00FE58  1  60             RTS
00FE59  1               .ifdef APPLE1
00FE59  1  20 78 F5     RESET: JSR L8 ; SET SCREEN MODE
00FE5C  1               .else
00FE5C  1               RESET: JSR SETNORM ; SET SCREEN MODE
00FE5C  1               .endif
00FE5C  1  20 2F FA       JSR INIT ; AND INIT KBD/SCREEN
00FE5F  1               .ifdef APPLE1
00FE5F  1  20 84 FD       JSR SETNORM ; AS I/O DEV'S
00FE62  1               .else
00FE62  1                 JSR SETVID ; AS I/O DEV'S
00FE62  1               .endif
00FE62  1  20 89 FD       JSR SETKBD
00FE65  1  D8           MON: CLD ; MUST SET HEX MODE!
00FE66  1  20 3A FE       JSR BELL
00FE69  1  A9 AA        MONZ: LDA #$AA ; '*' PROMPT FOR MON
00FE6B  1  85 33          STA PROMPT
00FE6D  1  20 67 FC       JSR GETLNZ ; READ A LINE
00FE70  1  20 C7 FE       JSR ZMODE ; CLEAR MON MODE, SCAN IDX
00FE73  1  20 A7 FE     NXTITM: JSR GETNUM ; GET ITEM, NON-HEX
00FE76  1  84 34          STY YSAV ; CHAR IN A-REG
00FE78  1  A0 17          LDY #$17 ; X-REG=0 IF NO HEX INPUT
00FE7A  1  88           CHRSRCH: DEY
00FE7B  1  30 E8          BMI MON ; NOT FOUND, GO TO MON
00FE7D  1  D9 CC FE       CMP CHRTBL,Y ; FIND CMND CHAR IN TEL
00FE80  1  D0 F8          BNE CHRSRCH
00FE82  1  20 BE FE       JSR TOSUB ; FOUND, CALL CORRESPONDING
00FE85  1  A4 34          LDY YSAV ; SUBROUTINE
00FE87  1  4C 73 FE       JMP NXTITM
00FE8A  1  A2 03        DIG: LDX #$03
00FE8C  1  0A             ASL A
00FE8D  1  0A             ASL A ; GOT HEX DIG,
00FE8E  1  0A             ASL A ; SHIFT INTO A2
00FE8F  1  0A             ASL A
00FE90  1  0A           NXTBIT: ASL A
00FE91  1  26 3E          ROL A2L
00FE93  1  26 3F          ROL A2H
00FE95  1  CA             DEX ; LEAVE X=$FF IF DIG
00FE96  1  10 F8          BPL NXTBIT
00FE98  1  A5 31        NXTBAS: LDA MODE
00FE9A  1  D0 06          BNE NXTBS2 ; IF MODE IS ZERO
00FE9C  1  B5 3F          LDA A2H,X ; THEN COPY A2 TO
00FE9E  1  95 3D          STA A1H,X ; A1 AND A3
00FEA0  1  95 41          STA A3H,X
00FEA2  1  E8           NXTBS2: INX
00FEA3  1  F0 F3          BEQ NXTBAS
00FEA5  1  D0 06          BNE NXTCHR
00FEA7  1  A2 00        GETNUM: LDX #$00 ; CLEAR A2
00FEA9  1  86 3E          STX A2L
00FEAB  1  86 3F          STX A2H
00FEAD  1  B9 00 02     NXTCHR: LDA IN,Y ; GET CHAR
00FEB0  1  C8             INY
00FEB1  1  49 B0          EOR #$B0
00FEB3  1  C9 0A          CMP #$0A
00FEB5  1  90 D3          BCC DIG ; IF HEX DIG, THEN
00FEB7  1  69 88          ADC #$88
00FEB9  1  C9 FA          CMP #$FA
00FEBB  1  B0 CD          BCS DIG
00FEBD  1  60             RTS
00FEBE  1  A9 FD        TOSUB: LDA #>GO ; PUSH HIGH-ORDER
00FEC0  1  48             PHA ; SUBR ADR ON STK
00FEC1  1  B9 E3 FE       LDA SUBTBL,Y ; PUSH LOW-ORDER
00FEC4  1  48             PHA ; SUBR ADR ON STK
00FEC5  1  A5 31          LDA MODE
00FEC7  1  A0 00        ZMODE: LDY #$00 ; CLR MODE, OLD MODE
00FEC9  1  84 31           STY MODE ; TO A-REG
00FECB  1  60              RTS ; GO TO SUBR VIA RTS
00FECC  1  BC           CHRTBL: .BYTE $BC ; F("CTRL-C")
00FECD  1  B2             .BYTE $B2 ; F("CTRL-Y")
00FECE  1  BE             .BYTE $BE ; F("CTRL-E")
00FECF  1  ED             .BYTE $ED ; F("T")
00FED0  1  EF             .BYTE $EF ; F("V")
00FED1  1  C4             .BYTE $C4 ; F("CTRL-K")
00FED2  1  EC             .BYTE $EC ; F("S")
00FED3  1  A9             .BYTE $A9 ; F("CTRL-P")
00FED4  1  BB             .BYTE $BB ; F("CTRL-B")
00FED5  1  A6             .BYTE $A6 ; F("-")
00FED6  1  A4             .BYTE $A4 ; F("+")
00FED7  1  06             .BYTE $06 ; F("M") (F=EX-OR $B0+$89)
00FED8  1  95             .BYTE $95 ; F("<")
00FED9  1  07             .BYTE $07 ; F("N")
00FEDA  1  02             .BYTE $02 ; F("I")
00FEDB  1  05             .BYTE $05 ; F("L")
00FEDC  1  F0             .BYTE $F0 ; F("W")
00FEDD  1  00             .BYTE $00 ; F("G")
00FEDE  1  EB             .BYTE $EB ; F("R")
00FEDF  1  93             .BYTE $93 ; F(":")
00FEE0  1  A7             .BYTE $A7 ; F(".")
00FEE1  1  C6             .BYTE $C6 ; F("CR")
00FEE2  1  99             .BYTE $99 ; F(BLANK)
00FEE3  1               
00FEE3  1  B2           SUBTBL: .BYTE <BASCONT-1
00FEE4  1  C9             .BYTE <USR-1
00FEE5  1  BE             .BYTE <REGZ-1
00FEE6  1  C1             .BYTE <TRACE-1
00FEE7  1  35             .BYTE <VFY-1
00FEE8  1  8C             .BYTE <INPRT-1
00FEE9  1  C3             .BYTE <STEPZ-1
00FEEA  1  96             .BYTE <OUTPRT-1
00FEEB  1  AF             .BYTE <XBASIC-1
00FEEC  1  17             .BYTE <SETMODE-1
00FEED  1  17             .BYTE <SETMODE-1
00FEEE  1  2B             .BYTE <MOVE-1
00FEEF  1  1F             .BYTE <LT-1
00FEF0  1  83             .BYTE <SETNORM-1
00FEF1  1  7F             .BYTE <SETINV-1
00FEF2  1  5D             .BYTE <LIST-1
00FEF3  1  CC             .BYTE <WRITE-1
00FEF4  1  B5             .BYTE <GO-1
00FEF5  1  FC             .BYTE <READ-1
00FEF6  1  17             .BYTE <SETMODE-1
00FEF7  1  17             .BYTE <SETMODE-1
00FEF8  1  F5             .BYTE <CRMON-1
00FEF9  1  03             .BYTE <BLANK-1
00FEFA  1               .ifndef APPLE1
00FEFA  1                 .WORD NMI        ;NMI VECTOR
00FEFA  1                 .WORD RESET      ;RESET VECTOR
00FEFA  1                 .WORD IRQ        ;IRQ VECTOR
00FEFA  1               .endif
00FEFA  1               .ifdef WOZMON
00FEFA  1                 .WORD NMI        ;NMI VECTOR
00FEFA  1                 .WORD RESET      ;RESET VECTOR
00FEFA  1                 .WORD IRQ        ;IRQ VECTOR
00FEFA  1               .endif
00FEFA  1               XQTNZ = $3C
00FEFA  1               
00FEFA  1               .ifdef WOZMON
00FEFA  1               .proc WozMon
00FEFA  1               
00FEFA  1               ;  The WOZ Monitor for the Apple 1
00FEFA  1               ;  Written by Steve Wozniak in 1976
00FEFA  1               
00FEFA  1               
00FEFA  1               ; Page 0 Variables
00FEFA  1               
00FEFA  1               XAML            = $24           ;  Last "opened" location Low
00FEFA  1               XAMH            = $25           ;  Last "opened" location High
00FEFA  1               STL             = $26           ;  Store address Low
00FEFA  1               STH             = $27           ;  Store address High
00FEFA  1               L               = $28           ;  Hex value parsing Low
00FEFA  1               H               = $29           ;  Hex value parsing High
00FEFA  1               YSAV            = $2A           ;  Used to see if hex value is given
00FEFA  1               MODE            = $2B           ;  $00=XAM, $7F=STOR, $AE=BLOCK XAM
00FEFA  1               
00FEFA  1               
00FEFA  1               ; Other Variables
00FEFA  1               
00FEFA  1               IN              = $0200         ;  Input buffer to $027F
00FEFA  1               KBD             = $D010         ;  PIA.A keyboard input
00FEFA  1               KBDCR           = $D011         ;  PIA.A keyboard control register
00FEFA  1               DSP             = $D012         ;  PIA.B display output register
00FEFA  1               DSPCR           = $D013         ;  PIA.B display control register
00FEFA  1               
00FEFA  1               ;               .org $FF00
00FEFA  1                              .export RESET
00FEFA  1               
00FEFA  1               RESET:          CLD             ; Clear decimal arithmetic mode.
00FEFA  1                               CLI
00FEFA  1                               LDY #$7F        ; Mask for DSP data direction register.
00FEFA  1                               STY DSP         ; Set it up.
00FEFA  1                               LDA #$A7        ; KBD and DSP control register mask.
00FEFA  1                               STA KBDCR       ; Enable interrupts, set CA1, CB1, for
00FEFA  1                               STA DSPCR       ; positive edge sense/output mode.
00FEFA  1               NOTCR:          CMP #'_'+$80    ; "_"?
00FEFA  1                               BEQ BACKSPACE   ; Yes.
00FEFA  1                               CMP #$9B        ; ESC?
00FEFA  1                               BEQ ESCAPE      ; Yes.
00FEFA  1                               INY             ; Advance text index.
00FEFA  1                               BPL NEXTCHAR    ; Auto ESC if > 127.
00FEFA  1               ESCAPE:         LDA #'\'+$80    ; "\".
00FEFA  1                               JSR ECHO        ; Output it.
00FEFA  1               GETLINE:        LDA #$8D        ; CR.
00FEFA  1                               JSR ECHO        ; Output it.
00FEFA  1                               LDY #$01        ; Initialize text index.
00FEFA  1               BACKSPACE:      DEY             ; Back up text index.
00FEFA  1                               BMI GETLINE     ; Beyond start of line, reinitialize.
00FEFA  1               NEXTCHAR:       LDA KBDCR       ; Key ready?
00FEFA  1                               BPL NEXTCHAR    ; Loop until ready.
00FEFA  1                               LDA KBD         ; Load character. B7 should be ‘1’.
00FEFA  1                               STA IN,Y        ; Add to text buffer.
00FEFA  1                               JSR ECHO        ; Display character.
00FEFA  1                               CMP #$8D        ; CR?
00FEFA  1                               BNE NOTCR       ; No.
00FEFA  1                               LDY #$FF        ; Reset text index.
00FEFA  1                               LDA #$00        ; For XAM mode.
00FEFA  1                               TAX             ; 0->X.
00FEFA  1               SETSTOR:        ASL             ; Leaves $7B if setting STOR mode.
00FEFA  1               SETMODE:        STA MODE        ; $00=XAM $7B=STOR $AE=BLOK XAM
00FEFA  1               BLSKIP:         INY             ; Advance text index.
00FEFA  1               NEXTITEM:       LDA IN,Y        ; Get character.
00FEFA  1                               CMP #$8D        ; CR?
00FEFA  1                               BEQ GETLINE     ; Yes, done this line.
00FEFA  1                               CMP #'.'+$80    ; "."?
00FEFA  1                               BCC BLSKIP      ; Skip delimiter.
00FEFA  1                               BEQ SETMODE     ; Yes. Set STOR mode.
00FEFA  1                               CMP #':'+$80    ; ":"?
00FEFA  1                               BEQ SETSTOR     ; Yes. Set STOR mode.
00FEFA  1                               CMP #'R'+$80    ; "R"?
00FEFA  1                               BEQ RUN         ; Yes. Run user program.
00FEFA  1                               STX L           ; $00-> L.
00FEFA  1                               STX H           ; and H.
00FEFA  1                               STY YSAV        ; Save Y for comparison.
00FEFA  1               NEXTHEX:        LDA IN,Y        ; Get character for hex test.
00FEFA  1                               EOR #$B0        ; Map digits to $0-9.
00FEFA  1                               CMP #$0A        ; Digit?
00FEFA  1                               BCC DIG         ; Yes.
00FEFA  1                               ADC #$88        ; Map letter "A"-"F" to $FA-FF.
00FEFA  1                               CMP #$FA        ; Hex letter?
00FEFA  1                               BCC NOTHEX      ; No, character not hex.
00FEFA  1               DIG:            ASL
00FEFA  1                               ASL             ; Hex digit to MSD of A.
00FEFA  1                               ASL
00FEFA  1                               ASL
00FEFA  1                               LDX #$04        ; Shift count.
00FEFA  1               HEXSHIFT:       ASL             ; Hex digit left, MSB to carry.
00FEFA  1                               ROL L           ; Rotate into LSD.
00FEFA  1                               ROL H           ;  Rotate into MSD’s.
00FEFA  1                               DEX             ; Done 4 shifts?
00FEFA  1                               BNE HEXSHIFT    ; No, loop.
00FEFA  1                               INY             ; Advance text index.
00FEFA  1                               BNE NEXTHEX     ; Always taken. Check next char for hex.
00FEFA  1               NOTHEX:         CPY YSAV        ; Check if L, H empty (no hex digits).
00FEFA  1                               BEQ ESCAPE      ; Yes, generate ESC sequence.
00FEFA  1                               BIT MODE        ; Test MODE byte.
00FEFA  1                               BVC NOTSTOR     ;  B6=0 STOR 1 for XAM & BLOCK XAM
00FEFA  1                               LDA L           ; LSD’s of hex data.
00FEFA  1                               STA (STL,X)     ; Store at current ‘store index’.
00FEFA  1                               INC STL         ; Increment store index.
00FEFA  1                               BNE NEXTITEM    ; Get next item. (no carry).
00FEFA  1                               INC STH         ; Add carry to ‘store index’ high order.
00FEFA  1               TONEXTITEM:     JMP NEXTITEM    ; Get next command item.
00FEFA  1               RUN:            JMP (XAML)      ; Run at current XAM index.
00FEFA  1               NOTSTOR:        BMI XAMNEXT     ; B7=0 for XAM, 1 for BLOCK XAM.
00FEFA  1                               LDX #$02        ; Byte count.
00FEFA  1               SETADR:         LDA L-1,X       ; Copy hex data to
00FEFA  1                               STA STL-1,X     ; ‘store index’.
00FEFA  1                               STA XAML-1,X    ; And to ‘XAM index’.
00FEFA  1                               DEX             ; Next of 2 bytes.
00FEFA  1                               BNE SETADR      ; Loop unless X=0.
00FEFA  1               NXTPRNT:        BNE PRDATA      ; NE means no address to print.
00FEFA  1                               LDA #$8D        ; CR.
00FEFA  1                               JSR ECHO        ; Output it.
00FEFA  1                               LDA XAMH        ; ‘Examine index’ high-order byte.
00FEFA  1                               JSR PRBYTE      ; Output it in hex format.
00FEFA  1                               LDA XAML        ; Low-order ‘examine index’ byte.
00FEFA  1                               JSR PRBYTE      ; Output it in hex format.
00FEFA  1                               LDA #':'+$80    ; ":".
00FEFA  1                               JSR ECHO        ; Output it.
00FEFA  1               PRDATA:         LDA #$A0        ; Blank.
00FEFA  1                               JSR ECHO        ; Output it.
00FEFA  1                               LDA (XAML,X)    ; Get data byte at ‘examine index’.
00FEFA  1                               JSR PRBYTE      ; Output it in hex format.
00FEFA  1               XAMNEXT:        STX MODE        ; 0->MODE (XAM mode).
00FEFA  1                               LDA XAML
00FEFA  1                               CMP L           ; Compare ‘examine index’ to hex data.
00FEFA  1                               LDA XAMH
00FEFA  1                               SBC H
00FEFA  1                               BCS TONEXTITEM  ; Not less, so no more data to output.
00FEFA  1                               INC XAML
00FEFA  1                               BNE MOD8CHK     ; Increment ‘examine index’.
00FEFA  1                               INC XAMH
00FEFA  1               MOD8CHK:        LDA XAML        ; Check low-order ‘examine index’ byte
00FEFA  1                               AND #$07        ; For MOD 8=0
00FEFA  1                               BPL NXTPRNT     ; Always taken.
00FEFA  1               PRBYTE:         PHA             ; Save A for LSD.
00FEFA  1                               LSR
00FEFA  1                               LSR
00FEFA  1                               LSR             ; MSD to LSD position.
00FEFA  1                               LSR
00FEFA  1                               JSR PRHEX       ; Output hex digit.
00FEFA  1                               PLA             ; Restore A.
00FEFA  1               PRHEX:          AND #$0F        ; Mask LSD for hex print.
00FEFA  1                               ORA #'0'+$80    ; Add "0".
00FEFA  1                               CMP #$BA        ; Digit?
00FEFA  1                               BCC ECHO        ; Yes, output it.
00FEFA  1                               ADC #$06        ; Add offset for letter.
00FEFA  1               ECHO:           BIT DSP         ; bit (B7) cleared yet?
00FEFA  1                               BMI ECHO        ; No, wait for display.
00FEFA  1                               STA DSP         ; Output character. Sets DA.
00FEFA  1                               RTS             ; Return.
00FEFA  1                               BRK             ; unused
00FEFA  1                               BRK             ; unused
00FEFA  1               
00FEFA  1               ; Interrupt Vectors
00FEFA  1               
00FEFA  1                               .WORD $0F00     ; NMI
00FEFA  1                               .WORD RESET     ; RESET
00FEFA  1                               .WORD $0000     ; BRK/IRQ
00FEFA  1               .endproc
00FEFA  1               .endif
00FEFA  1               
